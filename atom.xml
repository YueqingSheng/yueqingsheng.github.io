<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yueqingsheng.github.io</id>
    <title>Random thoughts</title>
    <updated>2020-06-27T05:32:06.865Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yueqingsheng.github.io"/>
    <link rel="self" href="https://yueqingsheng.github.io/atom.xml"/>
    <subtitle>Don&apos;t Learn to Code — Learn to Automate</subtitle>
    <logo>https://yueqingsheng.github.io/images/avatar.png</logo>
    <icon>https://yueqingsheng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Random thoughts</rights>
    <entry>
        <title type="html"><![CDATA[递归]]></title>
        <id>https://yueqingsheng.github.io/di-gui/</id>
        <link href="https://yueqingsheng.github.io/di-gui/">
        </link>
        <updated>2020-06-26T08:07:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="递归模板记住递归是对每一层做的操作">递归模板，记住递归是对每一层做的操作</h2>
<figure data-type="image" tabindex="1"><img src="https://yueqingsheng.github.io/post-images/1593212226238.png" alt="" loading="lazy"></figure>
<h2 id="二叉树的最大深度">二叉树的最大深度</h2>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        ldepth = self.maxDepth(root.left) + 1 
        rdepth = self.maxDepth(root.right) + 1
        return max(ldepth, rdepth) 
</code></pre>
<p>可以把判断叶子节点去掉的原因，可以多走一层走到叶子节点下一层发现没有就返回上来0。每走一层就加1，走到叶子节点下一层，返回0 +1 也是一样的。</p>
<p>官方解法，每往下走一层就+1， 然后每层取左右两边最大的深度</p>
<pre><code class="language-python">class Solution:
    def maxDepth(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot; 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[  树、二叉树]]></title>
        <id>https://yueqingsheng.github.io/shu-er-cha-shu/</id>
        <link href="https://yueqingsheng.github.io/shu-er-cha-shu/">
        </link>
        <updated>2020-06-25T18:29:23.000Z</updated>
        <content type="html"><![CDATA[<p>数跟图的区别是有没有闭环<br>
<img src="https://yueqingsheng.github.io/post-images/1593196326489.png" alt="" loading="lazy"></p>
<h2 id="二叉搜索树">二叉搜索树：</h2>
<h3 id="遍历">遍历</h3>
<p><img src="https://yueqingsheng.github.io/post-images/1593198432381.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1593198530487.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1593198604293.png" alt="" loading="lazy"><br>
查询，插入 logn<br>
插入：先查找位置，再插入<br>
删除，去第一个大于parent node的节点。<br>
平均 O(log(n)) 最差情况 O(n)</p>
<h2 id="题目1-n-叉树前序遍历">题目1： N 叉树前序遍历</h2>
<p>给定一个 N 叉树，返回其节点值的前序遍历。<br>
<img src="https://yueqingsheng.github.io/post-images/1593201852265.png" alt="" loading="lazy"></p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def preorder(self, root: 'Node') -&gt; List[int]:
        path = []
        def traverse(node):
            if node:
                path.append(node.val)
                for n in node.children:
                    traverse(n)
        traverse(root)
        return path
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表]]></title>
        <id>https://yueqingsheng.github.io/lian-biao/</id>
        <link href="https://yueqingsheng.github.io/lian-biao/">
        </link>
        <updated>2020-06-25T01:49:36.000Z</updated>
        <content type="html"><![CDATA[<p>数组访问 O(1), 添加删除 O(n)<br>
链表访问O(n), 添加删除 O(1)</p>
<h2 id="跳表">跳表</h2>
<p>log(n)<br>
基于有序的链表 Redis  LevelDB<br>
<img src="https://yueqingsheng.github.io/post-images/1593179884875.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1593179968260.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1593180120060.png" alt="" loading="lazy"></p>
<h3 id="python-swap">python swap</h3>
<p>x, y = y, x</p>
<h2 id="题目1-删除排序数组中的重复项">题目1： 删除排序数组中的重复项</h2>
<h3 id="解法1一开始的思路是把数组循环一遍有重复的就删除掉on2-的效率">解法1：一开始的思路是把数组循环一遍，有重复的就删除掉，O(n^2) 的效率</h3>
<p>数组循环删除的方法，复制一遍数组或者使用反向遍历<br>
为什么反向遍历不会出现 index 的错误？<br>
This implies that if you iterate the list back to front, if you remove an item at the current index, everything to it's right shifts left - but that doesn't matter, since you've already dealt with all the elements to the right of the current position, and you're moving left - the next element to the left is unaffected by the change, and so the iterator gives you the element you expect.<br>
a b c x d<br>
a b c d</p>
<blockquote>
<p>python range<br>
range(start, stop, step)<br>
reverse: range(len(x)-1, -1, -1)</p>
</blockquote>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if len(nums) == 1:
            return len(nums)
        for i in range(len(nums)-1,0,-1):
            if nums[i] == nums[i-1]:
                nums.pop(i)
        return len(nums)
</code></pre>
<h3 id="解法2-双指针-on">解法2： 双指针  O(n)</h3>
<p>一个指针指向要放不同element的下标，另外一个指针用来搜索下一个要放的元素</p>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        i = 0
        for j in range(len(nums)):
            if nums[i] != nums[j]:
                nums[i+1] = nums[j]
                i = i + 1
        return len(nums[:i+1])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法基础]]></title>
        <id>https://yueqingsheng.github.io/shi-jian-fu-za-du-he-kong-jian-fu-za-du-fen-xi/</id>
        <link href="https://yueqingsheng.github.io/shi-jian-fu-za-du-he-kong-jian-fu-za-du-fen-xi/">
        </link>
        <updated>2020-06-23T00:18:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="时间复杂度和空间复杂度分析">时间复杂度和空间复杂度分析</h1>
<h2 id="时间复杂度">时间复杂度：</h2>
<p>Big O noataion<br>
<img src="https://yueqingsheng.github.io/post-images/1593131066367.png" alt="" loading="lazy"></p>
<p>递归分析：<br>
<img src="https://yueqingsheng.github.io/post-images/1593131294007.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1593131391447.png" alt="" loading="lazy"></p>
<p>Master Theorem<br>
<img src="https://yueqingsheng.github.io/post-images/1593144733931.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1593131483674.png" alt="" loading="lazy"><br>
二叉树遍历 O(n)<br>
DFS, BFS O(n)</p>
<h2 id="空间复杂度">空间复杂度</h2>
<figure data-type="image" tabindex="1"><img src="https://yueqingsheng.github.io/post-images/1593145072638.png" alt="" loading="lazy"></figure>
<ol>
<li>方向</li>
<li>学历，读研？<br>
mobile shuffer regnet<br>
backpropation<br>
传统算法<br>
互联网行业，实体<br>
网站：<br>
应届生论坛<br>
公众号：校招实验室<br>
牛客网<br>
校招：<br>
大学宣讲会<br>
Boss直聘<br>
小公司-&gt;大公司</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[周报 6月1期]]></title>
        <id>https://yueqingsheng.github.io/zhou-bao-6-yue-1-qi/</id>
        <link href="https://yueqingsheng.github.io/zhou-bao-6-yue-1-qi/">
        </link>
        <updated>2020-06-22T02:00:31.000Z</updated>
        <content type="html"><![CDATA[<p>getaway 短假 We're planning a romantic getaway to the south of France.<br>
inviting 诱人的<br>
laid-back 放松</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows 本地运行 Jupyter 作业教程]]></title>
        <id>https://yueqingsheng.github.io/windows-ben-di-yun-xing-jupyter-zuo-ye-jiao-cheng/</id>
        <link href="https://yueqingsheng.github.io/windows-ben-di-yun-xing-jupyter-zuo-ye-jiao-cheng/">
        </link>
        <updated>2020-06-20T05:04:45.000Z</updated>
        <content type="html"><![CDATA[<p>推荐 Anaconda 傻瓜式安装，安装完后启动 Jupyter<br>
<img src="https://yueqingsheng.github.io/post-images/1592759276980.png" alt="" loading="lazy"></p>
<p>直接在本地运行下载下来的 notebook 会有几个问题，提供下解决方案：</p>
<h2 id="1-error-invalid-requirement">1. ERROR: Invalid requirement: '#'</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592759420716.png" alt="" loading="lazy"><br>
当命令行语句和注释在同一行时候会报错，可以把同行的注释去掉，或者挪到上面</p>
<h2 id="2-module-could-not-be-found-找不到雅达利-乒乓环境">2. module could not be found 找不到雅达利 乒乓环境</h2>
<p>做如下几步</p>
<ol>
<li>
<p>卸载 gym and atari-py (If already installed):<br>
pip uninstall atari-py<br>
pip uninstall gym[atari]</p>
</li>
<li>
<p>下载 VS build 工具 : https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16</p>
</li>
<li>
<p>运行并选择  &quot;C++ build tools&quot;安装.<br>
<img src="https://yueqingsheng.github.io/post-images/1592759774751.png" alt="" loading="lazy"></p>
</li>
<li>
<p>重启电脑</p>
</li>
<li>
<p>安装 cmake, atari-py and gym<br>
pip install cmake<br>
pip install atari-py<br>
pip install gym[atari]</p>
</li>
<li>
<p>跑一下测试:<br>
import atari_py<br>
print(atari_py.list_games())<br>
如果成功会 print 下面</p>
</li>
</ol>
<pre><code class="language-python">['adventure', 'air_raid', 'alien', 'amidar', 'assault', 'asterix', 'asteroids', 'atlantis', 'bank_heist', 'battle_zone', 'beam_rider', 'berzerk', 'bowling', 'boxing', 'breakout', 'carnival', 'centipede', 'chopper_command', 'crazy_climber', 'defender', 'demon_attack', 'double_dunk', 'elevator_action', 'enduro', 'fishing_derby', 'freeway', 'frostbite', 'gopher', 'gravitar', 'hero', 'ice_hockey', 'jamesbond', 'journey_escape', 'kaboom', 'kangaroo', 'krull', 'kung_fu_master', 'montezuma_revenge', 'ms_pacman', 'name_this_game', 'phoenix', 'pitfall', 'pong', 'pooyan', 'private_eye', 'qbert', 'riverraid', 'road_runner', 'robotank', 'seaquest', 'skiing', 'solaris', 'space_invaders', 'star_gunner', 'tennis', 'time_pilot', 'tutankham', 'up_n_down', 'venture', 'video_pinball', 'wizard_of_wor', 'yars_revenge', 'zaxxon']
</code></pre>
<h2 id="3-wrn-found-non-empty-cuda_visible_devices-but-parl-found-that-paddle-was-not-complied-with-cuda-which-may-cause-issues-keneral-dead">3. WRN Found non-empty CUDA_VISIBLE_DEVICES. But PARL found that Paddle was not complied with CUDA, which may cause issues. keneral dead</h2>
<p>这个错误 Kernel 会挂掉，然后无限重启，主要是 检测到了电脑里的GPU, 但是没有安装 Cuda 导致的。 因为这里我们只使用 CPU 来跑，所以把 GPU 检测关闭就好了<br>
在最后运行代码前加上这两行：</p>
<pre><code class="language-python">import os
os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;-1&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强化学习 Day5 连续空间动作 DDPG]]></title>
        <id>https://yueqingsheng.github.io/qiang-hua-xue-xi-day5-lian-xu-kong-jian-dong-zuo-ddpg/</id>
        <link href="https://yueqingsheng.github.io/qiang-hua-xue-xi-day5-lian-xu-kong-jian-dong-zuo-ddpg/">
        </link>
        <updated>2020-06-19T15:21:00.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://yueqingsheng.github.io/post-images/1592752914800.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592752944679.png" alt="" loading="lazy"><br>
DQN 扩展到连续控制动作空间<br>
策略网络负责对外展示动作, critc 对action 打分，action -&gt; Q value，迎合评委网络使 Q 尽可能高<br>
<img src="https://yueqingsheng.github.io/post-images/1592753557001.png" alt="" loading="lazy"><br>
Q 网络逼近 Q-target, 使用 MSE<br>
Q target 不稳定，所以专门建立 target_Q 和 target_P 网络（next_action ）<br>
<img src="https://yueqingsheng.github.io/post-images/1592753707568.png" alt="" loading="lazy"><br>
为了防止 target_Q 网络更新, (定期copy), 需要 stop gradient<br>
<img src="https://yueqingsheng.github.io/post-images/1592754333762.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592754555792.png" alt="" loading="lazy"><br>
只更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>, 所以minimize 中 传入要更新的 actor 参数<br>
<img src="https://yueqingsheng.github.io/post-images/1592754856731.png" alt="" loading="lazy"></p>
<h2 id="总结">总结</h2>
<figure data-type="image" tabindex="1"><img src="https://yueqingsheng.github.io/post-images/1592754975966.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统设计7 GFS]]></title>
        <id>https://yueqingsheng.github.io/xi-tong-she-ji-7-gfs/</id>
        <link href="https://yueqingsheng.github.io/xi-tong-she-ji-7-gfs/">
        </link>
        <updated>2020-06-18T17:13:25.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yueqingsheng.github.io/post-images/1592838132417.png" alt="" loading="lazy"></figure>
<h2 id="scenario">Scenario</h2>
<figure data-type="image" tabindex="2"><img src="https://yueqingsheng.github.io/post-images/1592937998924.png" alt="" loading="lazy"></figure>
<h2 id="service">Service</h2>
<p>clinet + Server<br>
多台机器怎么沟通？<br>
<img src="https://yueqingsheng.github.io/post-images/1592938077078.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592938113585.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592938321692.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592938364579.png" alt="" loading="lazy"></p>
<h2 id="storage">Storage</h2>
<h2 id="保存一个文件">保存一个文件</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592938764791.png" alt="" loading="lazy"><br>
MetaData 的访问更多，A, B 两种存储结构<br>
机械硬盘，磁头调需要时间，所以选择A<br>
文件内容分段储存还是连续存储，B 适合修改或追加内容<br>
<img src="https://yueqingsheng.github.io/post-images/1592938947650.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592939145448.png" alt="" loading="lazy"><br>
100T，block 太多，增加 block 大小， 4k -&gt; 64M, 劣势浪费了小空间， 4m 占用了64m空间<br>
<img src="https://yueqingsheng.github.io/post-images/1592939321203.png" alt="" loading="lazy"><br>
10P，一台电脑 0.1P<br>
offset 可以只存在 Chunk server 上<br>
<img src="https://yueqingsheng.github.io/post-images/1592939740947.png" alt="" loading="lazy"><br>
换格子不用通知 Master<br>
<img src="https://yueqingsheng.github.io/post-images/1592939893628.png" alt="" loading="lazy"></p>
<h2 id="read-write">Read &amp; Write</h2>
<h3 id="写入">写入</h3>
<p>一次写入还是多次写入，传输单位是Chunk<br>
<img src="https://yueqingsheng.github.io/post-images/1592940093322.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592940144296.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592940260498.png" alt="" loading="lazy"><br>
和Master 沟通，直接给chunk server 写<br>
<img src="https://yueqingsheng.github.io/post-images/1592940431060.png" alt="" loading="lazy"></p>
<h3 id="读入">读入</h3>
<p><img src="https://yueqingsheng.github.io/post-images/1592940583035.png" alt="" loading="lazy"><br>
并行从不同 Chunk server 读入<br>
<img src="https://yueqingsheng.github.io/post-images/1592940638455.png" alt="" loading="lazy"></p>
<h2 id="scale">Scale</h2>
<p>单 Master<br>
<img src="https://yueqingsheng.github.io/post-images/1592940743044.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592940828767.png" alt="" loading="lazy"><br>
检查损坏<br>
CheckSum, XOR(exclusive OR) 相同为0， 不同为1，有误检情况，极低<br>
<img src="https://yueqingsheng.github.io/post-images/1592941171998.png" alt="" loading="lazy"><br>
1 个 cheksum 4bytes, 1 个 chunk 1个 chunksum<br>
<img src="https://yueqingsheng.github.io/post-images/1592941328271.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592941393981.png" alt="" loading="lazy"></p>
<h3 id="replica-备份">Replica 备份</h3>
<p><img src="https://yueqingsheng.github.io/post-images/1592941646023.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592941630620.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592941717310.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592941741519.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942222483.png" alt="" loading="lazy"><br>
B. 单次通讯<br>
<img src="https://yueqingsheng.github.io/post-images/1592941853201.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592941886863.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592941945801.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942052569.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942111752.png" alt="" loading="lazy"></p>
<h2 id="实战">实战</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592942352741.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942408792.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942469829.png" alt="" loading="lazy"><br>
QPS<br>
<img src="https://yueqingsheng.github.io/post-images/1592942546504.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942743390.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942782661.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592942892343.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强化学习 Day 4 基于策略方法]]></title>
        <id>https://yueqingsheng.github.io/qiang-hua-xue-xi-day-4-ji-yu-ce-lue-fang-fa/</id>
        <link href="https://yueqingsheng.github.io/qiang-hua-xue-xi-day-4-ji-yu-ce-lue-fang-fa/">
        </link>
        <updated>2020-06-18T06:28:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="value-based-vs-policy-based">Value-based vs policy-based</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592591392361.png" alt="" loading="lazy"><br>
policy based :  直接求action<br>
policy based:  输出动作的概率<br>
<img src="https://yueqingsheng.github.io/post-images/1592591618895.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592591641683.png" alt="" loading="lazy"><br>
最后一层 softmax<br>
episode: 每轮游戏<br>
优化目的： max 每个episode的总reward<br>
<img src="https://yueqingsheng.github.io/post-images/1592602759204.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592602819167.png" alt="" loading="lazy"><br>
环境的随机性无法控制</p>
<h2 id="期望回报">期望回报</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592603030920.png" alt="" loading="lazy"><br>
环境概率是未知的， N是 episode数。</p>
<h3 id="优化策略函数">优化策略函数</h3>
<p><img src="https://yueqingsheng.github.io/post-images/1592603189106.png" alt="" loading="lazy"><br>
优化目标 期望回报最大， 梯度上升<br>
<img src="https://yueqingsheng.github.io/post-images/1592610701005.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592623362667.png" alt="" loading="lazy"><br>
蒙特卡洛每个 Episode 更新一次， 时序差分每个action更新一次<br>
<img src="https://yueqingsheng.github.io/post-images/1592623555097.png" alt="" loading="lazy"><br>
根据公式反向推到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<h2 id="reinforce">Reinforce</h2>
<p>每个 Episode , 通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>s</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>t</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(s_t, a_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 求出 G_t, 对于每一步使用 ln 函数更新神经网络参数值<br>
<img src="https://yueqingsheng.github.io/post-images/1592624092549.png" alt="" loading="lazy"><br>
类比 Cross entrophy, 因为sum_ln 不一定是正确的acition, 只是真实的action, 所以需要乘上总奖励系数 G<br>
<img src="https://yueqingsheng.github.io/post-images/1592624728691.png" alt="" loading="lazy"></p>
<h3 id="流程图">流程图</h3>
<figure data-type="image" tabindex="1"><img src="https://yueqingsheng.github.io/post-images/1592625148267.png" alt="" loading="lazy"></figure>
<h2 id="总结">总结</h2>
<figure data-type="image" tabindex="2"><img src="https://yueqingsheng.github.io/post-images/1592625752484.png" alt="" loading="lazy"></figure>
<p><img src="https://yueqingsheng.github.io/post-images/1592626079005.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592626129133.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统设计6 聊天系统]]></title>
        <id>https://yueqingsheng.github.io/xi-tong-she-ji-6-liao-tian-xi-tong/</id>
        <link href="https://yueqingsheng.github.io/xi-tong-she-ji-6-liao-tian-xi-tong/">
        </link>
        <updated>2020-06-16T18:56:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="设计微信">设计微信</h2>
<h2 id="scenario">Scenario</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592496158173.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592496270302.png" alt="" loading="lazy"><br>
微信不是点对点通信？ 不是，可以留言。历史消息存在服务器，留一段时间(缓冲期)删除，或者不删除。</p>
<h2 id="service">Service</h2>
<figure data-type="image" tabindex="1"><img src="https://yueqingsheng.github.io/post-images/1592496789439.png" alt="" loading="lazy"></figure>
<h2 id="storage">Storage</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592499919444.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592500035973.png" alt="" loading="lazy"></p>
<h3 id="thread-table-会话">Thread table (会话)</h3>
<p><img src="https://yueqingsheng.github.io/post-images/1592690543672.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592690857535.png" alt="" loading="lazy"><br>
有些信息是私有的，未读，静音<br>
<img src="https://yueqingsheng.github.io/post-images/1592691079629.png" alt="" loading="lazy"></p>
<h4 id="方法-1">方法 1</h4>
<p><img src="https://yueqingsheng.github.io/post-images/1592691168124.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592691312651.png" alt="" loading="lazy"><br>
私有的信息存在 User thread, 如何知道参与人，查找所有表里有相同therad_id， primary key = userId + thread id<br>
弊端：需要跨表查询比较慢</p>
<h4 id="方法-2">方法 2</h4>
<p><img src="https://yueqingsheng.github.io/post-images/1592691650849.png" alt="" loading="lazy"><br>
实际情况下使用cache , 减少跨表次数。</p>
<h3 id="通过-参与者-查询-thread-id">通过 参与者 查询 thread id</h3>
<figure data-type="image" tabindex="2"><img src="https://yueqingsheng.github.io/post-images/1592692220394.png" alt="" loading="lazy"></figure>
<h2 id="message-存储结构写多读少">Message 存储结构（写多读少）</h2>
<h3 id="nosqloptimize-for-write">Nosql(optimize for write)</h3>
<figure data-type="image" tabindex="3"><img src="https://yueqingsheng.github.io/post-images/1592692649085.png" alt="" loading="lazy"></figure>
<h2 id="thread-sql">Thread SQL</h2>
<figure data-type="image" tabindex="4"><img src="https://yueqingsheng.github.io/post-images/1592692933866.png" alt="" loading="lazy"></figure>
<h3 id="nosql">NoSQL</h3>
<p><img src="https://yueqingsheng.github.io/post-images/1592692999885.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592707081552.png" alt="" loading="lazy"></p>
<h2 id="可行解">可行解</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592707202439.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592707251898.png" alt="" loading="lazy"></p>
<h2 id="scale">Scale</h2>
<p>实时<br>
Push notification<br>
<img src="https://yueqingsheng.github.io/post-images/1592707456643.png" alt="" loading="lazy"><br>
局限性： 无法支持 Web 端<br>
Socket: 支持 Server push 给客户端<br>
<img src="https://yueqingsheng.github.io/post-images/1592707919405.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592708079822.png" alt="" loading="lazy"></p>
<h2 id="channel-service-支持群聊">Channel Service 支持群聊</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592708303585.png" alt="" loading="lazy"><br>
channel service 里的 key 就是 channel 的名字，value 是在这个 channel 下有哪些人。<br>
因为 channel 是一个 key-value 的存储结构，value 是一个 set，支持用户上下线（增删），所以 Redis 是可以很好支持 value 是 set 的一种 key-value 结构。</p>
<h3 id="q-a">Q &amp; A</h3>
<figure data-type="image" tabindex="5"><img src="https://yueqingsheng.github.io/post-images/1592708930601.png" alt="" loading="lazy"></figure>
<h2 id="多机登录">多机登录</h2>
<figure data-type="image" tabindex="6"><img src="https://yueqingsheng.github.io/post-images/1592715706014.png" alt="" loading="lazy"></figure>
<h2 id="用户在线状态显示">用户在线状态显示</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1592715930630.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592716061460.png" alt="" loading="lazy"><br>
<img src="https://yueqingsheng.github.io/post-images/1592716185953.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>