<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yueqingsheng.github.io</id>
    <title>哇哦</title>
    <updated>2020-05-05T01:36:08.918Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yueqingsheng.github.io"/>
    <link rel="self" href="https://yueqingsheng.github.io/atom.xml"/>
    <subtitle>Don&apos;t Learn to Code — Learn to Automate</subtitle>
    <logo>https://yueqingsheng.github.io/images/avatar.png</logo>
    <icon>https://yueqingsheng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 哇哦</rights>
    <entry>
        <title type="html"><![CDATA[nestjs 后端代码自动生成（数据表，curd接口，文档）]]></title>
        <id>https://yueqingsheng.github.io/post/nestjs-hou-duan-dai-ma-zi-dong-sheng-cheng-shu-ju-biao-curd-jie-kou-wen-dang/</id>
        <link href="https://yueqingsheng.github.io/post/nestjs-hou-duan-dai-ma-zi-dong-sheng-cheng-shu-ju-biao-curd-jie-kou-wen-dang/">
        </link>
        <updated>2020-04-29T19:43:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>最近给公司写接口的过程中，发现每有一种新的数据形式，出现就需要重新写一个数据表，并提供相关的数据接口。这个过程中有很多的代码复用。<br>
一开始我写了一组使用范类的常用controller和service，并让新写的controller和service继承他们，效果还可以，但是还是要自己写entity以及配置数据库一些重复的操作。所以我想能否也省去写这些部分的时间。</p>
<h2 id="实现结果">实现结果</h2>
<p>只通过一个json文件（即数据格式），生成一系列接口以及文档。</p>
<pre><code>test.json
{&quot;name&quot;: &quot;hi&quot;, &quot;age&quot;: 1} 
</code></pre>
<h3 id="生成效果下面都是通过一个json生成的内容">生成效果（下面都是通过一个json生成的内容）</h3>
<h3 id="生成的文档目录更新了appmodule">生成的文档目录(更新了app.module)</h3>
<figure data-type="image" tabindex="1"><img src="https://yueqingsheng.github.io/post-images/1588622779097.jpg" alt="" loading="lazy"></figure>
<h3 id="接口">接口</h3>
<figure data-type="image" tabindex="2"><img src="https://yueqingsheng.github.io/post-images/1588622024790.png" alt="" loading="lazy"></figure>
<h3 id="接口内包括筛选查找分页缓存等一系列选项">接口内包括筛选，查找，分页，缓存等一系列选项。</h3>
<figure data-type="image" tabindex="3"><img src="https://yueqingsheng.github.io/post-images/1588622446855.png" alt="" loading="lazy"></figure>
<h3 id="数据格式文档">数据格式文档</h3>
<figure data-type="image" tabindex="4"><img src="https://yueqingsheng.github.io/post-images/1588622674686.png" alt="" loading="lazy"></figure>
<h3 id="数据表">数据表</h3>
<figure data-type="image" tabindex="5"><img src="https://yueqingsheng.github.io/post-images/1588623030960.png" alt="" loading="lazy"></figure>
<h2 id="实现思路">实现思路</h2>
<ol>
<li>nesjs有类似component的概念，component之间可以通过插入继承来实现复用。我这里使用了继承，因为想复用的部分都是可以共用的增查删改操作。</li>
<li>在网上搜索资料的时候发现，有人也有同样的思路，并写了一个包<a href="https://github.com/nestjsx/crud">nestjsx/crud</a>。star数有点少, 不过很好用，暂时只支持typeorm。既然有了轮子就不用自己造了。这个包含了swagger的配置，所以会自动生成文档。</li>
<li>基于这个包扩展开来，我要做的只是把json转成entity.ts文件，生成module,controller, service(继承crud)以及配置好数据库就行了。实现很简单我用了jupter notebook 然后转成了python。<a href="https://github.com/YueqingSheng/nestjs_a_json_to_all">源码地址</a> 实现过程在ipynb里，py是转换好的文件。</li>
</ol>
<h2 id="运行">运行</h2>
<p>ipython beg.py test(实例/数据表名) test.json(数据内容)</p>
<h2 id="对nestjsxcrud的改进部分">对nestjsx/crud的改进部分</h2>
<ol>
<li>增加了json转entity</li>
<li>补充了swagger分区（ApiTags）和显示entity内部属性（ApiModelProperty）</li>
<li>生成module,controller,service,并注入entiity repository</li>
<li>更新app.module</li>
</ol>
<h2 id="之后的扩展方向">之后的扩展方向</h2>
<ol>
<li>丰富json数据类型支持，目前只支持string, int, bool</li>
<li>添加mongodb支持</li>
<li>提供更多entity column选项</li>
<li>添加接口权限控制</li>
<li>根据list of json 批量生成接口</li>
<li>生成一个接口，供前端使用，前端可以根据数据需求创造接口。</li>
<li>js重新打包成cli发布到npm</li>
</ol>
<h2 id="已知bug">已知bug</h2>
<p>json 中不能用id属性，因为id是由primaryGenerateColumn默认生成的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[青春有你2 评论分析拓展]]></title>
        <id>https://yueqingsheng.github.io/post/qing-chun-you-ni-2-ping-lun-fen-xi/</id>
        <link href="https://yueqingsheng.github.io/post/qing-chun-you-ni-2-ping-lun-fen-xi/">
        </link>
        <updated>2020-04-20T06:05:39.000Z</updated>
        <content type="html"><![CDATA[<p>2020/4/30 更新</p>
<h2 id="1-多线程数据爬取">1. 多线程数据爬取</h2>
<h3 id="获取视频列表">获取视频列表</h3>
<p>获取视频列表的url为https://www.iqiyi.com/v_19ryi480ks.html。 即任意一期右侧的正片这一栏。<img src="https://yueqingsheng.github.io/post-images/1588097362211.png" alt="" loading="lazy"><br>
找到 li标签下 class为play-list-item的data-td属性<br>
<img src="https://yueqingsheng.github.io/post-images/1588098764168.png" alt="" loading="lazy"><br>
<strong>需要注意爬取后的列表第一个为预告，可以去掉，这里只爬取所有正片</strong></p>
<h3 id="获取评论列表">获取评论列表</h3>
<p><a href="https://sns-comment.iqiyi.com/v3/comment/get_comments.action?agent_type=118&amp;agent_version=9.11.5&amp;authcookie=null&amp;business_type=17&amp;content_id=15533381100&amp;hot_size=0&amp;last_id=15533381100&amp;page=4&amp;page_size=40&amp;types=time">接口</a></p>
<blockquote>
<p>url参数：<br>
content_id: 视频id 通过上方的的视频列表中获取<br>
last_id: 上个最后的视频id，每次获取完成后，使用最后一个id，作为下次获取的last_id<br>
page: 翻页的页数<br>
page_size: 每页评论的个数<br>
upremaining: 1最后一页， 0 后面还有内容</p>
</blockquote>
<h4 id="如何获取全部评论">如何获取全部评论</h4>
<p>两个思路</p>
<ol>
<li>检查lastid 是否重复了，说明获取到最后一个</li>
<li>其实返回的data里有一个参数，&quot;upremaining&quot;:0。检查这个为1就可以了。</li>
</ol>
<p><strong>大部分同学都使用last_id翻页，其实参数里自带page,使用page=1，2，3，4也可以实现翻页</strong><br>
<strong>page_size可以设大一点，减少请求次数。最大为40</strong><br>
<strong>因为评论数量过多，使用多进程爬取。每一个进程爬取一个视频下的评论,总共花了1分3秒。不用多线程的话，估计要20多分钟。</strong><br>
截至2020日4月29日总共爬取了254287条数据。</p>
<h2 id="2-数据清洗">2. 数据清洗</h2>
<p>发现很多评论里出现多次刷同一个选手名的现象。所以做一下选手名去重，这样能在预测选手成绩时能保证合理性，防止多计算出现次数。<br>
如: 虞书欣虞书欣虞书欣虞书欣虞书欣冲呀！！！<br>
清洗后为 虞书欣冲呀！！！</p>
<h2 id="3-分词">3. 分词</h2>
<p><strong>数据请求后, 评论列表不再改变可以转化为tuple使用, tuple的access速度会比list快</strong><br>
使用tuple分词用了 9分3秒，会比list快十几秒。</p>
<h2 id="4-选手词频统计">4. 选手词频统计</h2>
<p>经过26万条评论统计，按前20选手姓名出现频率排序<br>
<img src="https://yueqingsheng.github.io/post-images/1588269289897.png" alt="" loading="lazy"><br>
人名去重后，词频少了很多。<br>
<img src="https://yueqingsheng.github.io/post-images/1588641843216.jpg" alt="" loading="lazy"><br>
根据25号官方排名，前9名内除第9不一样，其他基本吻合。</p>
<h2 id="5-词云">5. 词云</h2>
<p>按照词频显示词云<br>
<img src="https://yueqingsheng.github.io/post-images/1588269308723.png" alt="" loading="lazy"><br>
之前用形状和上色绘制了下词云，但是感觉效果没有原生的好。(这个是基于1000条数据生成的)<br>
<img src="https://yueqingsheng.github.io/post-images/1588211480849.png" alt="" loading="lazy"></p>
<h2 id="6-节目评价">6. 节目评价</h2>
<p><img src="https://yueqingsheng.github.io/post-images/1588210836624.png" alt="" loading="lazy"><br>
总体还是正向和中性评价占了绝大多数，95%。<br>
随机打印一点 评价<br>
正向：<br>
['因为看了书欣的电视剧才来看这个的，喜欢她的性格', '我也喜欢左卓', '好喜欢刘雨昕！', '我真的太爱刘雨昕了', '好看好看', '看了这期，真的很心疼喻言', '安崎反差萌真的绝了，好看的颜值和有趣的灵魂她都拥有。', '我也喜欢虞书欣', '虞书欣加油', '冲着虞书欣搞笑视频来的，后面发现太太太多想pick的了。这种模式是看的第一个，努力又融洽的氛围真好。']<br>
中性：<br>
['乃万！', '乃万', '我要去看男团了拜拜，记得给我点赞', '大家要帮忙投票了吗我这儿还有13票', '大家有要帮忙投票的吗我还有14', '虞书欣', '乃万简直是可盐可甜可rap 可vocal， 随时写词的到处撩妹的博爱艺术家 。', '谢可寅小姐姐要加油喽。', '刘雨昕', '林凡']<br>
负面;<br>
['刘雨昕你咋不是个男的啊太帅了', '看得累死了磨磨叽叽', '我爱死所有训练生了', '傅如乔 爱死你了', '我就是看美女跳舞的，谁是谁，这个真不关心，长的都挺好看的，挺养眼', ''安琪的肚子真的不好看 感觉肚子肉好多 总喜欢露着腰,'入股不亏', '赵小棠什么鬼哦！', '真失望  为什么不是刘雨欣！  突然不想看了', '不要脸', '小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！真的很棒！']</p>
<p><strong>模型把很多人名识别成了中性词，对英文的词性识别可能还不是很好。</strong><br>
<strong>有一些负面评价识别还行，但是也有不准的时候。比如“爱死了”， &quot;小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！&quot;可能把呜呜呜识别成负面了。</strong></p>
<h2 id="总结">总结</h2>
<p>跟原项目主要区别：多进程爬虫，多视频爬取，选手名去重，list改用tuple<br>
经过爬取所有评论和同一句子人名去重后，发现数据可视化后还是变化挺大的。有很多人一个评论发很多重复的一个人名。</p>
<h3 id="可拓展方面">可拓展方面</h3>
<p>评论生成，用文本生成模型生成一些青春有你相关的评论。<br>
其实表情也是很好的反映观众心情的label, 也可以做这方面情感分析，finetuning 一下。根据评论生成表情，也会很有意思。<br>
评论中还包括了大量的图片和动图，抓取下来，也可以做一些相应的拓展。<br>
评论的用户信息分析，如地区</p>
<p>生成一个动态直方图，用户根据日期看不同日期的统计变化。<a href="https://www.bilibili.com/video/BV1za4y1x768?spm_id_from=333.905.b_72656c61746564.2">参考视频，随便一个视频几万的播放量，我酸了</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue]]></title>
        <id>https://yueqingsheng.github.io/post/vue/</id>
        <link href="https://yueqingsheng.github.io/post/vue/">
        </link>
        <updated>2020-04-19T18:58:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用">使用</h2>
<h3 id="cdn">CDN</h3>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="数据绑定">数据绑定</h2>
<h3 id="括号绑定">括号绑定</h3>
<pre><code>{{message}} //括号中可使用表达式 如 {{message+ message}}
</code></pre>
<h3 id="指令式绑定">指令式绑定</h3>
<pre><code>&lt;div v-bind:id=&quot;message&quot;&gt;&lt;/div&gt;
</code></pre>
<h4 id="简写形式">简写形式</h4>
<pre><code>&lt;div :id=&quot;message&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这里我们遇到了一点新东西。你看到的 v-bind attribute 被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title attribute 和 Vue 实例的 message 属性保持一致”。</p>
<h3 id="响应式">响应式</h3>
<p>可以这样理解：当一个状态改变之后，与这个状态相关的事务也立即随之改变，从前端来看就是数据状态改变后相关 DOM 也随之改变。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。</p>
<h3 id="v-if-v-else-v-show-v-for">v-if v-else v-show v-for</h3>
<pre><code class="language-html">  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      {{message}}{{message+ message}}
      &lt;div :id=&quot;message&quot;&gt;&lt;/div&gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;item in list&quot;&gt;
          &lt;span v-if=&quot;!item.del&quot;&gt;{{item.title}}&lt;/span&gt;
          &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{item.title}}&lt;/span&gt;
          &lt;button v-show=&quot;!item.del&quot;&gt;删除&lt;/button&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          message: &quot;Hello World&quot;,
          list: [
            {
              title: &quot;课程1&quot;,
              del: false,
            },
            {
              title: &quot;课程2&quot;,
              del: true,
            },
          ],
        },
      });
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<h2 id="组件">组件</h2>
<pre><code class="language-html">     Vue.component(&quot;todo-item&quot;,{
        props:{
          title: String,
          del: {
            type: Boolean,
            default: false,
          },
        },
        template: `
         &lt;li &gt;
          &lt;span v-if=&quot;!del&quot;&gt;{{title}}&lt;/span&gt;
          &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{title}}&lt;/span&gt;
          &lt;button v-show=&quot;!del&quot;&gt;删除&lt;/button&gt;
        &lt;/li&gt;
        `,
          data: function(){
            return {}
          },
          methods: {

          },
      })

      Vue.component(&quot;todo-list&quot;, {
          template: `
           &lt;ul&gt;
            &lt;todo-item v-for=&quot;item in list&quot; :title=&quot;item.title&quot; :del=&quot;!item.del&quot;&gt;&lt;/todo-item&gt;
          &lt;/ul&gt;
        `,
          data: function () {
            return {
              list: [
                {
                  title: &quot;课程1&quot;,
                  del: false,
                },
                {
                  title: &quot;课程2&quot;,
                  del: true,
                },
            ]}
          }
        })
</code></pre>
<p>组件中data 不能使用同一个data,因为pass by reference ，在一个地方改变，其他地方也会改变。data要求唯一化。</p>
<pre><code class="language-html">
</code></pre>
<pre><code class="language-html">
</code></pre>
<pre><code class="language-html">
</code></pre>
<pre><code class="language-html">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次神经网络实践]]></title>
        <id>https://yueqingsheng.github.io/post/di-yi-ci-shen-jing-wang-luo-shi-jian/</id>
        <link href="https://yueqingsheng.github.io/post/di-yi-ci-shen-jing-wang-luo-shi-jian/">
        </link>
        <updated>2020-04-17T17:44:55.000Z</updated>
        <content type="html"><![CDATA[<p>简单总结下教训：<br>
<img src="https://yueqingsheng.github.io/post-images/1587407335871.jpg" alt="" loading="lazy"></p>
<h2 id="输入输出">输入，输出</h2>
<p>输入就是 a和 b, 输出是c。</p>
<h3 id="first-attempt">First attempt</h3>
<p>一开始想把天数，1到28天作为输入，28天的感染人数作为输出。去找 天数和 感染的函数关系。错误的原因，28天只是任意的28天时间段，去强行找 1-28 和感染的关系是不成立的。也没有关系。</p>
<h3 id="second-attempt">Second attempt</h3>
<p>用RNN实现，方向是对的。能力不够复现RNN或LSTM(吐槽下，老师说如果要写的话，要从0复现一个，地狱级难度任务)</p>
<h3 id="总结">总结</h3>
<p>其实确认输入输出，最重要的就是确立，想找的是什么与什么直接的关系。相互影响的那两个量。题目写的已经很清楚了，用c_t 和 t_pd 预测 c_inf</p>
<h2 id="其中忽视的问题">其中忽视的问题</h2>
<p>只看到了cost变大，没有去考虑原因。原因是因为梯度爆炸。梯度爆炸的原因是，输入之间差值太大，呈现exponetial爆炸增长。</p>
<h2 id="最重要学到的点什么时候要做归一化即normalizition">！！！！ 最重要学到的点，什么时候要做归一化，即Normalizition</h2>
<p>归一化，在处理奇异值时候特别重要，如果数据存在极大或极小值，会严重影响weight 的收敛。归一化即，把输入和输出限制在同意范围内，如[0,1],映射到同一维度内。<br>
<a href="https://blog.csdn.net/zenghaitao0128/article/details/78361038">参考:机器学习——标准化/归一化的目的和作用</a></p>
<p>Anyway, 有空的话，可以用LSTM复现个玩玩。获取一个多维度输入，输出将来的感染人数。直到感染变化为0为止。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://yueqingsheng.github.io/post/python/</id>
        <link href="https://yueqingsheng.github.io/post/python/">
        </link>
        <updated>2020-04-15T11:48:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="print">Print</h2>
<p>print 会自动换行，print(end=&quot;&quot;)会取消换行，end为结束后缀</p>
<h2 id="遍历文件">遍历文件</h2>
<h3 id="oswalk">os.walk()</h3>
<p>Python method walk() generates the file names in a directory tree by walking the tree either top-down or bottom-up.</p>
<pre><code class="language-python">  for root,dirs,files in os.walk(path):
        for fname in files:
            if filename in fname:
                result.append([id,fname])
</code></pre>
<h2 id="string-check-contains">string check contains</h2>
<pre>
str = "Messi is the best soccer player"
>>> "soccer" in str
True
>>> "football" in str
False
</pre>
<h2 id="三引号">三引号</h2>
<p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（<strong>所见即所得</strong>）格式的。</p>
<pre><code class="language-python">print('''I'm going to the movies''')

html = '''
&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;
Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;
&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;
&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back
ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;
&lt;/BODY&gt;&lt;/HTML&gt;
'''
print(html)
</code></pre>
<h2 id="元组和列表">元组和列表</h2>
<h3 id="元组是不可变的-而列表是可变的">元组是不可变的， 而列表是可变的。</h3>
<p>我们可以修改列表的值，但是不能修改元组的值。<br>
由于列表是可变的，我们不能将列表用作字典中的key。 但可以使用元组作为字典key。</p>
<h3 id="同构与异构">同构与异构</h3>
<p>习惯上元组多用于用于存储异构元素，异构元素即不同数据类型的元素，比如(ip,port)。 另一方面，列表用于存储异构元素，这些元素属于相同类型的元素，比如[int1,in2,in3]。</p>
<h2 id="json">JSON</h2>
<h3 id="python-listdict-to-json-string">Python list(dict) to json string</h3>
<p>json.dumps 用于将 Python 对象编码成 JSON 字符串。</p>
<pre><code class="language-python">import json
data = [ { 'b' : 2, 'd' : 4, 'a' : 1, 'c' : 3, 'e' : 5 } ]
json = json.dumps(data)
print(json)
</code></pre>
<p>[{&quot;b&quot;: 2, &quot;d&quot;: 4, &quot;a&quot;: 1, &quot;c&quot;: 3, &quot;e&quot;: 5}]</p>
<h3 id="json-string-to-python-listdict_">json string to python list(dict)_</h3>
<p>json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。</p>
<pre><code class="language-python">import json
jsonData = '{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}'
text = json.loads(jsonData)  #将string转换为dict
print(text)
</code></pre>
<h2 id="打包并压缩">打包并压缩</h2>
<p>把当前目录下所有文件打包压缩成a.tar.zip</p>
<pre><code class="language-python">tar -zcvf a.tar.zip ./
</code></pre>
<p>解压<br>
-C 指定目录</p>
<pre><code class="language-python">tar -zxvf a.tar.zip -C ../
</code></pre>
<h2 id="爬虫">爬虫</h2>
<h3 id="request模块">request模块：</h3>
<blockquote>
<p>requests是python实现的简单易用的HTTP库，官网地址：http://cn.python-requests.org/zh_CN/latest/<br>
requests.get(url)可以发送一个http get请求，返回服务器响应内容。</p>
</blockquote>
<h3 id="beautifulsoup库">BeautifulSoup库：</h3>
<blockquote>
<p>BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。网址：https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/<br>
BeautifulSoup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml。<br>
BeautifulSoup(markup, &quot;html.parser&quot;)或者BeautifulSoup(markup, &quot;lxml&quot;)，推荐使用lxml作为解析器,因为效率更高。</p>
</blockquote>
<h3 id="通过tag标签逐层查找">通过tag标签逐层查找:</h3>
<p>soup.select(&quot;body a&quot;)</p>
<h3 id="获取属性">获取属性</h3>
<p>tag.get('href')<br>
或者<br>
tag['href']<br>
如果不确定某个属性是否存在时,用 tag.get('attr') 方法去获取它,跟获取Python字典的key一样<br>
tag['class']<br>
<em><strong>KeyError: 'class'</strong></em><br>
print(tag.get('class'))<br>
<em><strong>None</strong></em></p>
<pre><code class="language-python">        link = star['link']
         headers = { 
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'
    }

        #！！！请在以下完成对每个选手图片的爬取，将所有图片url存储在一个列表pic_urls中！！！    
        pic_urls = []
        response = requests.get(link,headers=headers)

        #将一段文档传入BeautifulSoup的构造方法,就能得到一个文档的对象, 可以传入一段字符串
        soup = BeautifulSoup(response.text,'lxml')
            
        pic_list_url = soup.select(&quot;.summary-pic a&quot;)[0]['href']
        tags1 = soup.select('div .shixian_zhaobiao')
        tag1 = tags1[0]
        tag2 = tag1.find(name = 'dl')
        tags2 = tag2.find_all(name = 'a')
</code></pre>
<h3 id="jsonp-to-json">jsonp to json</h3>
<pre><code>response_json = response[ response.index(&quot;(&quot;) + 1 : response.rindex(&quot;) }
catch&quot;)]
</code></pre>
<p>或者get请求的时候，去掉callback=,则会返回json</p>
<h3 id="动态请求">动态请求</h3>
<p>如果数据是动态加载，可以在浏览器network里查看请求的api</p>
<h2 id="写入文件">写入文件</h2>
<blockquote>
<p>With the &quot;With&quot; statement, you get better syntax and exceptions handling.<br>
&quot;The with statement simplifies exception handling by encapsulating common<br>
preparation and cleanup tasks.&quot;<br>
In addition, it will automatically close the file. The with statement provides<br>
a way for ensuring that a clean-up is always used.</p>
</blockquote>
<pre><code class="language-python">with open('output.txt', 'w') as file:  # Use file to refer to the file object

    file.write('Hi there!')
</code></pre>
<p>with 省去写exception handler和close file</p>
<h2 id="pandas">pandas</h2>
<h3 id="dataframe">dataframe</h3>
<h3 id="cut">cut</h3>
<pre><code class="language-python">将age按0-5，5-20...bins 分成 既几部分，label为[婴儿，青年...]
ages = np.array([1,5,10,40,36,12,58,62,77,89,100,18,20,25,30,32]) #年龄数据
pd.cut(ages, [0,5,20,30,50,100], labels=[u&quot;婴儿&quot;,u&quot;青年&quot;,u&quot;中年&quot;,u&quot;壮年&quot;,u&quot;老年&quot;])
</code></pre>
<p><a href="https://www.cnblogs.com/sench/p/10128216.html">参考</a></p>
<h3 id="value_counts">value_counts</h3>
<p>df.value_counts()  以Series形式返回指定列的不同取值的频率,默认按频率从高到低排序</p>
<h3 id="groupby">groupby</h3>
<pre><code class="language-python">df['name'].groupby(df['zone'])
s = grouped.count()
zone
中国上海      5
中国北京      9
df = pd.DataFrame({'Animal': ['Falcon', 'Falcon',
                              'Parrot', 'Parrot'],
                   'Max Speed': [380., 370., 24., 26.]})
df
   Animal  Max Speed
0  Falcon      380.0
1  Falcon      370.0
2  Parrot       24.0
3  Parrot       26.0
df.groupby(['Animal']).mean()
        Max Speed
Animal
Falcon      375.0
Parrot       25.0
</code></pre>
<h2 id="matplot">matplot</h2>
<h2 id="size">size</h2>
<p>plt.figure(figsize=(12, 12))</p>
<h2 id="matplotlib-inline">%matplotlib inline</h2>
<p>%matplotlib inline 可以在Ipython编译器里直接使用，功能是可以内嵌绘图，并且可以省略掉plt.show()这一步</p>
<h2 id="pie">pie</h2>
<p>参数：</p>
<blockquote>
<p>x       :(每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化；<br>
labels  :(每一块)饼图外侧显示的说明文字；<br>
explode :(每一块)离开中心距离；<br>
startangle :起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起；<br>
shadow  :在饼图下面画一个阴影。默认值：False，即不画阴影；</p>
</blockquote>
<pre><code class="language-python">## draw pie
labels = [&quot;45-50kg&quot;,'&lt;45kg','50-55kg','55kg']
plt.pie(weightsfreq.values, explode=(0.1,0.1,0.1,0.1),labels=labels, shadow=True,autopct='%.2f%%',startangle=90)
plt.axis('equal')
plt.legend(loc=&quot;upper right&quot;,fontsize=10,bbox_to_anchor=(1.1,1.05),borderaxespad=0.3)
plt.title('''《青春有你2》选手体重分布''',fontsize = 10)
plt.savefig('/home/aistudio/work/result/bar_result03.jpg')
</code></pre>
<p><a href="https://www.cnblogs.com/biyoulin/p/9565350.html">参考</a></p>
<h3 id="正圆">正圆</h3>
<p>plt.axis('equal')</p>
<h2 id="string-format">string format</h2>
<h3 id="python-36">python &gt;3.6</h3>
<blockquote>
<p>&gt;&gt;&gt; name = 'hoxis'<br>
&gt;&gt;&gt; age = 18<br>
&gt;&gt;&gt; f&quot;hi, {name}, are you {age}&quot;<br>
'hi, hoxis, are you 18'</p>
</blockquote>
<h3 id="百分号">百分号</h3>
<p>%%表示百分号</p>
<blockquote>
<p>&gt;&gt;&gt; print('数据的比例是:%.2f%%' %(scale * 100))<br>
数据的比例是:10.00%<br>
&gt;&gt;&gt; print('数据的比例是:%d%%' %(scale * 100))<br>
数据的比例是:10%</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/39128162">参考</a></p>
<h2 id="词云">词云</h2>
<pre><code class="language-python"> 根据词频绘制词云图
    参数 word_f:统计出的词频结果
    # 生成对象
    mask = np.array(Image.open(&quot;alice_mask.png&quot;))
    wc = WordCloud(mask=mask, font_path='SimHei.ttf', mode='RGBA', background_color=None)
    wc.fit_words(word_f)
    
    
    # 显示词云
    plt.imshow(wc, interpolation='bilinear')
    plt.axis(&quot;off&quot;)
    plt.show()
    
    # 保存到文件
    wc.to_file('wordcloud.png')
</code></pre>
<h2 id="matlibplot-加载中文字体">matlibplot 加载中文字体</h2>
<pre><code class="language-python">	#下载中文字体
	wget https://mydueros.cdn.bcebos.com/font/simhei.ttf 
	#在操作系统中创建字体目录fonts（可能已经有
	mkdir .fonts
	# 复制字体文件到该路径
	cp simhei.ttf .fonts/
	#复制字体到当前使用的conda环境中的matplotlib下的指定路径
	cp simhei.ttf /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/matplotlib/mpl-data/fonts/ttf/
	# Linux系统默认字体文件路径
	ls /usr/share/fonts/
	# 查看系统可用的ttf格式中文字体
	fc-list :lang=zh | grep &quot;.ttf&quot;
	 # 设置显示中文
    matplotlib.rcParams['font.san-serif'] = ['SimHei']
    # 解决负号'-'显示为方块的问题
    matplotlib.rcParams['axes.unicode_minus'] = False
</code></pre>
<p>如果没成功，尝试</p>
<pre><code class="language-python">from matplotlib.font_manager import _rebuild
_rebuild() #reload一下
</code></pre>
<h2 id="jieba-分词">jieba 分词</h2>
<pre><code class="language-python">   jieba.load_userdict('name.txt') #name.txt 为用户自定义分词
   seg = jieba.lcut(text,cut_all=False)
</code></pre>
<h2 id="停用词">停用词</h2>
<pre><code class="language-python">stopwords = [line.strip() for line in open(file_path, encoding=&quot;UTF-8&quot;).readlines()]
for word in sentence:
        if word not in stopwords:
            if len(word) &gt; 1:
                counts[word] = counts.get(word, 0) + 1
</code></pre>
<p>字典 .get(key,value) value为如果不存在返回的值，counts.get(word, 0)： word不存在于counts中则返回 0<br>
<a href="https://github.com/goto456/stopwords">中文常用停用词词表</a></p>
<h2 id="多进程">多进程</h2>
<p>多进程共同的全局变量，需要使用特殊方式声明：</p>
<pre><code class="language-python">from multiprocessing import Process, Value, Array, Manager

def f(n, a):
    n.value = 3.1415927
    for i in range(len(a)):
        a[i] = -a[i]

if __name__ == '__main__':
    num = Value('d', 0.0)
    arr = Array('i', range(10))
    lis =  Manager().list()
    p = Process(target=f, args=(num, arr))
    p.start()
    p.join()

    print(num.value)
    print(arr[:])
</code></pre>
<p>多进程list 使用前需转换回普通list， list(lis)<br>
.join() 可以等待进程执行结束后再输出</p>
<h3 id="多进程的一个大坑broken-pipe">多进程的一个大坑：broken pipe</h3>
<p>解决方案不要在主线程外使用shared object,这样主线程使用的时候修改，会影响子线程的这个object<br>
解决方案：移除主线程的修改，或者把修改放到子线程跑完之后<br>
<a href="https://stackoverflow.com/questions/45506115/why-does-broken-pipe-error-occur-only-while-accessing-a-shared-list-in-a-speci">解释</a></p>
<h3 id="join">.join()</h3>
<p>主线程等待子线程跑完。python默认是先执行完主线程</p>
<pre><code class="language-python">    process= []
    for c_id in content_ids:
        # 每个进程爬取一个视频下的评论
        p = Process(target=getMovieinfo,args=(c_id,))
        process.append(p)
        p.start()
    
    #等待所有线程任务结束。
    for p in process:
        p.join()
    print(&quot;总共获取了&quot;,len(comments),'条评论')
</code></pre>
<p>这样主线程就会阻塞了<br>
<a href="https://blog.csdn.net/zhangphil/article/details/88577091">参考</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 18]]></title>
        <id>https://yueqingsheng.github.io/post/day-18/</id>
        <link href="https://yueqingsheng.github.io/post/day-18/">
        </link>
        <updated>2020-04-09T00:51:57.000Z</updated>
        <content type="html"><![CDATA[<p>[x] lecture 28<br>
[x] lecture 29<br>
[ ] lecture 30 TODO vector embeddings<br>
[x] lecture 31<br>
cs489 蛮有意思的，neuro science 从头贯穿到尾，讲neural network 的起源，和各种机制设置的原因。整个学期其实就一个Model, 就是人脑神经。从脑科学的角度改进network和思考大脑是如何解决某项任务的，如视觉系统。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 17]]></title>
        <id>https://yueqingsheng.github.io/post/day-17/</id>
        <link href="https://yueqingsheng.github.io/post/day-17/">
        </link>
        <updated>2020-04-07T05:31:09.000Z</updated>
        <content type="html"><![CDATA[<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2780348"><label class="task-list-item-label" for="task-item-2780348"> code: chat</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9668707">  vue<br>
<label class="task-list-item-label" for="task-item-9668707">  vue
看了 react angular文档，太复杂了。转vue了。</label></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 16]]></title>
        <id>https://yueqingsheng.github.io/post/day-16/</id>
        <link href="https://yueqingsheng.github.io/post/day-16/">
        </link>
        <updated>2020-04-06T05:25:02.000Z</updated>
        <content type="html"><![CDATA[<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4412241"><label class="task-list-item-label" for="task-item-4412241"> code: chat</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6170805"><label class="task-list-item-label" for="task-item-6170805"> 课程价格</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-88505"><label class="task-list-item-label" for="task-item-88505"> 评价</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-24567"><label class="task-list-item-label" for="task-item-24567"> 评分</label></li>
</ul>
<p>今天 windows, mysql 直接抽了，不知道为啥，完全不听typeorm的改动，我服了。本来半天能写完的代码，硬是debug一天。结果发现是数据库的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 15]]></title>
        <id>https://yueqingsheng.github.io/post/day-15/</id>
        <link href="https://yueqingsheng.github.io/post/day-15/">
        </link>
        <updated>2020-04-03T17:28:18.000Z</updated>
        <content type="html"><![CDATA[<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5241617"><label class="task-list-item-label" for="task-item-5241617"> code: chat</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7473961"><label class="task-list-item-label" for="task-item-7473961"> code: morning</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5789870"><label class="task-list-item-label" for="task-item-5789870"> 订单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-838978"><label class="task-list-item-label" for="task-item-838978"> 课程价格</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6626523"><label class="task-list-item-label" for="task-item-6626523"> 评价</label></li>
</ul>
<p>订单表设计：<br>
类型： 课程， (谈一谈)talk, 要传<br>
图片<br>
课程标题： 订单的话用课程号区分吧，定为timestamp ok, tradeno<br>
class: 关系<br>
counselor: 关系</p>
<p>标题 body, 图片服务器根据type和body查找订单，存储Image和关系</p>
<p>订单评价：<br>
评价： comment 包含 counselor, course 里有评价, counselor里 eager， 流程就按post里走<br>
评分： 每次评价都创建一个即使为空，按 （原来的+new）/总数<br>
课程价格： price class ， 包含 几天</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nestjs的坑]]></title>
        <id>https://yueqingsheng.github.io/post/nestjs-de-keng/</id>
        <link href="https://yueqingsheng.github.io/post/nestjs-de-keng/">
        </link>
        <updated>2020-04-03T07:43:24.000Z</updated>
        <summary type="html"><![CDATA[<p>不定期更新</p>
]]></summary>
        <content type="html"><![CDATA[<p>不定期更新</p>
<!-- more -->
<p>变量命名时尽量不要用type, class 这些名称，以免用的时候，报一些奇怪的错误。编译器不知道是，自定义的名，还是语法里的意思。comment 也是关键字，需自己导包，我也是服了。</p>
<p>eager 谨慎使用，特别是relation有相互包含的时候。必须只能加在一边，防止重复包含，导致stack overflow。eager 只会在find里生效</p>
<p>find 有很多选项足够用了可以代替 queryBuilder</p>
<h2 id="onetomany-save">OneToMany Save</h2>
<p>例子： 商品储存多个价格， data 是发送的商品数据，其中包含了price</p>
<pre><code class="language-typescript">    data.price = await this.priceRepository.save(price);
    data = await this.repository.create(data);
    return await this.repository.save(data);
</code></pre>
<p>注意 data.price 这一步是必须的，是为了更新刚储存完的id号，typeorm 用id 来建立关系</p>
]]></content>
    </entry>
</feed>