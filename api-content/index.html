{"posts":[{"title":"nestjs 统一返回格式","content":"统一返回格式 ｛data：object，message：请求成功，code：200｝ 成功的格式 { &quot;statusCode&quot;: 200, &quot;data&quot;: { &quot;username&quot;: &quot;string&quot;, &quot;access_token&quot;: &quot;XXX&quot; }, &quot;code&quot;: 0, &quot;message&quot;: &quot;请求成功&quot; } 失败的格式 { &quot;statusCode&quot;: 401, &quot;data&quot;: { &quot;error&quot;: &quot;Client Error&quot; }, &quot;message&quot;: &quot;请求失败&quot;, &quot;code&quot;: 1, &quot;url&quot;: &quot;/api/auth/profile&quot; } 暂定code代表成功，1代表失败，成功data里是返回内容，失败data里是错误信息。 拦截全部的错误请求 src/core/filters/all-exception.filter’; import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch() export class AllExceptionFilter&lt;T&gt; implements ExceptionFilter { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse&lt;Response&gt;(); const request = ctx.getRequest&lt;Request&gt;(); const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; const message = exception.message.message ? exception.message.message : `${status &gt;= 500 ? 'Service Error' : 'Client Error'}`; const errorResponse = { statusCode: status, data: { error: message }, message: '请求失败', code: 1, // 自定义code }; // 设置返回的状态码、请求头、发送错误信息 response.status(status); response.header('Content-Type', 'application/json; charset=utf-8'); response.send(errorResponse); } } 拦截成功的返回数据 src/core/interceptors/response.interceptor’; import { CallHandler, ExecutionContext, Injectable, NestInterceptor, } from '@nestjs/common'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { Response } from 'express'; @Injectable() export class ResponseInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const response = context.switchToHttp().getResponse&lt;Response&gt;(); console.log(response.statusCode); return next.handle().pipe( map(data =&gt; { return { data, code: 0, message: '请求成功', statusCode: response.statusCode, }; }), ); } } 全局注册 main.ts ... import { TransformInterceptor } from './core/interceptor/transform.interceptor'; async function bootstrap() { ... // 全局注册拦截器 app.useGlobalFilters(new AllExceptionFilter()); app.useGlobalInterceptors(new ResponseInterceptor()); ... } bootstrap(); ","link":"https://yueqingsheng.github.io/post/nestjs-tong-yi-fan-hui-ge-shi/"},{"title":"随想","content":"会记录一些突然想到的想法到这里 开会 会议中有太多的干扰项，具体实现的方案应该放在会议前去做。多人的交流和干扰，反而会使想出一个好的解决方案的效率降低。 项目宏伟的缺陷 一些宏伟项目想法在提出来的时候，可能会很好。但是应该在每部分的实现逻辑（细节）尽可能完善后（想出来，或者demo实现一下），再招聘程序员去做。 bug解决方案 当卡在某个bug自己短时间内无法解决时，或找不到原因，最有效率的方式是去搜索这个问题，查看别人是怎么解决的。 时间规划 可以给设个计划设个下限和上限，以避免规划没达到的心里落差。 ","link":"https://yueqingsheng.github.io/post/sui-xiang/"},{"title":"系统设计 3 sharding&hash","content":"Scale QPS Single point failure(一台服务器挂) sharding 数据拆分 解决 single point failure 分摊流量 replica 数据复制 数据恢复 分摊流量 数据库拆分 竖向拆分 缺点： 当表单特别大，column无法拆分时无法用 横向拆分 新数据放新机器，老数据放老机器的问题是什么？ 根据数据的新旧程度来拆分的话，新数据的访问次数比旧数据的访问次数是要明显多的，会导致数据访问不均匀的问题。 这种方法并不会导致存储不均匀，最多只有最新的一台机器的数据相对少一些，其他的机器都还是均匀的。也不会导致不知道数据去哪台机器取，比如根据 id 来拆分，0~99在1号机器，1-199 在2号机器的话，根据 id 可以算出对应的机器是哪个 75%的数据迁移 一致性哈希算法 匀走相邻两台机器的一部分数据 缺陷： 改进： 红黑树（balanced tree） 数据复制 Replica Replica vs Backup SQL NoSQL 实战1：User Table Sharding 怎么取数据就怎么拆数据库 按照 username找用户 查username-&gt;id表 实战2：Friendship Table Sharding 双向好友关系，必须存两条关系 实战4： News Feed/Timeline Sharding owner id/userid 实战5： LintCode Submission (user/problem/status) ","link":"https://yueqingsheng.github.io/post/xi-tong-she-ji-3-databaseandhash/"},{"title":"jupyter","content":"自动输出多行 from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = &quot;all&quot; 安装包 can not find module import sys !{sys.executable} -m pip install pypinyin ","link":"https://yueqingsheng.github.io/post/jupyter/"},{"title":"系统设计 Week 2 Database&Cache(数据库和缓存)","content":"用户系统 Scenario(QPS)&amp;Service QPS = DAU*用户平均每天请求次数/每天多少秒（86400） QPS与数据存储 Cache（读多写少） File system 可以作为网络请求和计算结果的cache 跟hashmap区别，cache有淘汰机制（LRU，LSU） ttl: time to live Set User cache delete, database set.有可能第二个 多线程下，可能造成数据不一致。 当执行完cache delete, 另外线程get user 获取了旧数据（cache）, 再执行database set (新数据-&gt;数据不一致 加锁（不同机器，系统) 常用方法 database.set, cache.delete 同时用 set set, 多进程会有修改数据库情况，然后缓存set旧的data 第一种情况因为读多改少，出现概率低。cache hit 概率大，通常&gt;98% 如何解决一致性 问题 ttl(time to live) 允许短时间的不一致 读少写多 （多用数据库，分摊请求） Cache 架构 登录系统 UUID:通常用UUID来作为Session Key(Session Token)，UUID(Universal Unique ID): UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为1632=2128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。所以通俗的称之为宇宙爆炸都不会出现重复的ID字段。 Cookie里内容越少越好 只允许一台机器登录 存储device token, 监测到不同device, 把其他设备账户logout 好友关系 方案1: 优点：只存储1条数据，节省一半空间。（当你要存 1 和 2 是好友的时候，你可能存为 &lt;1,2&gt; 也可能存为 &lt;2,1&gt;。我们只存成 &lt;1,2&gt; 的形式，原因有两个，第一是方便查询，否则你查询的时候得分别差 &lt;1,2&gt; 是否存在和 &lt;2,1&gt; 是否存在。第二个是节省一半的存储空间。） 缺点： 查询时 or 操作慢一些 方案2: 优点： 查询语句简单，查询速度快。空间换取时间 Transaction: 事务。代表一些列操作要打包在一起，同时成果或者同时失败。比如我转你 10 块钱，你的余额要 +10，我的余额要 -10。这是两条数据库操作，必须同时成功或者同时失败。不能只有一条操作成功。这种打包，就叫做 Transaction。 NoSQL(Cassandra) Row key: 存储到哪台机器的索引，nosql 用于分布式 Column key: 支持范围查询 和 复合值查询 NoSQL VS SQL 选择原则： transaction 不能选NoSQL(通常在一台机器完成) 擅长部分 一个网站会使用多种数据库 NoSql 存单向好友关系 NoSql 存储User 根据 emial/phone/username查询 共同好友 A userid B userid =&gt; A和B交集 六度关系 ","link":"https://yueqingsheng.github.io/post/xi-tong-she-ji-week-2-databaseandcacheshu-ju-ku-he-huan-cun/"},{"title":"python cheatsheet","content":"Comprehensive Python Cheatsheet Download text file, Buy PDF, Fork me on GitHub or Check out FAQ. Contents 1. Collections: List, Dictionary, Set, Tuple, Range, Enumerate, Iterator, Generator. 2. Types: Type, String, Regular_Exp, Format, Numbers, Combinatorics, Datetime. 3. Syntax: Args, Inline, Closure, Decorator, Class, Duck_Type, Enum, Exception. 4. System: Exit, Print, Input, Command_Line_Arguments, Open, Path, OS_Commands. 5. Data: JSON, Pickle, CSV, SQLite, Bytes, Struct, Array, Memory_View, Deque. 6. Advanced: Threading, Operator, Introspection, Metaprograming, Eval, Coroutines. 7. Libraries: Progress_Bar, Plot, Table, Curses, Logging, Scraping, Web, Profile, NumPy, Image, Audio, Pygame. Main if __name__ == '__main__': # Runs main() if file wasn't imported. main() List &lt;list&gt; = &lt;list&gt;[from_inclusive : to_exclusive : ±step_size] &lt;list&gt;.append(&lt;el&gt;) # Or: &lt;list&gt; += [&lt;el&gt;] &lt;list&gt;.extend(&lt;collection&gt;) # Or: &lt;list&gt; += &lt;collection&gt; &lt;list&gt;.sort() &lt;list&gt;.reverse() &lt;list&gt; = sorted(&lt;collection&gt;) &lt;iter&gt; = reversed(&lt;list&gt;) sum_of_elements = sum(&lt;collection&gt;) elementwise_sum = [sum(pair) for pair in zip(list_a, list_b)] sorted_by_second = sorted(&lt;collection&gt;, key=lambda el: el[1]) sorted_by_both = sorted(&lt;collection&gt;, key=lambda el: (el[1], el[0])) flatter_list = list(itertools.chain.from_iterable(&lt;list&gt;)) product_of_elems = functools.reduce(lambda out, el: out * el, &lt;collection&gt;) list_of_chars = list(&lt;str&gt;) Module operator provides functions itemgetter() and mul() that offer the same functionality as lambda expressions above. &lt;int&gt; = &lt;list&gt;.count(&lt;el&gt;) # Returns number of occurrences. Also works on strings. index = &lt;list&gt;.index(&lt;el&gt;) # Returns index of first occurrence or raises ValueError. &lt;list&gt;.insert(index, &lt;el&gt;) # Inserts item at index and moves the rest to the right. &lt;el&gt; = &lt;list&gt;.pop([index]) # Removes and returns item at index or from the end. &lt;list&gt;.remove(&lt;el&gt;) # Removes first occurrence of item or raises ValueError. &lt;list&gt;.clear() # Removes all items. Also works on dictionary and set. Dictionary &lt;view&gt; = &lt;dict&gt;.keys() # Coll. of keys that reflects changes. &lt;view&gt; = &lt;dict&gt;.values() # Coll. of values that reflects changes. &lt;view&gt; = &lt;dict&gt;.items() # Coll. of key-value tuples that reflects chgs. value = &lt;dict&gt;.get(key, default=None) # Returns default if key is missing. value = &lt;dict&gt;.setdefault(key, default=None) # Returns and writes default if key is missing. &lt;dict&gt; = collections.defaultdict(&lt;type&gt;) # Creates a dict with default value of type. &lt;dict&gt; = collections.defaultdict(lambda: 1) # Creates a dict with default value 1. &lt;dict&gt; = dict(&lt;collection&gt;) # Creates a dict from coll. of key-value pairs. &lt;dict&gt; = dict(zip(keys, values)) # Creates a dict from two collections. &lt;dict&gt; = dict.fromkeys(keys [, value]) # Creates a dict from collection of keys. &lt;dict&gt;.update(&lt;dict&gt;) # Adds items. Replaces ones with matching keys. value = &lt;dict&gt;.pop(key) # Removes item or raises KeyError. {k for k, v in &lt;dict&gt;.items() if v == value} # Returns set of keys that point to the value. {k: v for k, v in &lt;dict&gt;.items() if k in keys} # Returns a dictionary, filtered by keys. Counter &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; colors = ['blue', 'blue', 'blue', 'red', 'red'] &gt;&gt;&gt; counter = Counter(colors) &gt;&gt;&gt; counter['yellow'] += 1 Counter({'blue': 3, 'red': 2, 'yellow': 1}) &gt;&gt;&gt; counter.most_common()[0] ('blue', 3) Set &lt;set&gt; = set() &lt;set&gt;.add(&lt;el&gt;) # Or: &lt;set&gt; |= {&lt;el&gt;} &lt;set&gt;.update(&lt;collection&gt;) # Or: &lt;set&gt; |= &lt;set&gt; &lt;set&gt; = &lt;set&gt;.union(&lt;coll.&gt;) # Or: &lt;set&gt; | &lt;set&gt; &lt;set&gt; = &lt;set&gt;.intersection(&lt;coll.&gt;) # Or: &lt;set&gt; &amp; &lt;set&gt; &lt;set&gt; = &lt;set&gt;.difference(&lt;coll.&gt;) # Or: &lt;set&gt; - &lt;set&gt; &lt;set&gt; = &lt;set&gt;.symmetric_difference(&lt;coll.&gt;) # Or: &lt;set&gt; ^ &lt;set&gt; &lt;bool&gt; = &lt;set&gt;.issubset(&lt;coll.&gt;) # Or: &lt;set&gt; &lt;= &lt;set&gt; &lt;bool&gt; = &lt;set&gt;.issuperset(&lt;coll.&gt;) # Or: &lt;set&gt; &gt;= &lt;set&gt; &lt;el&gt; = &lt;set&gt;.pop() # Raises KeyError if empty. &lt;set&gt;.remove(&lt;el&gt;) # Raises KeyError if missing. &lt;set&gt;.discard(&lt;el&gt;) # Doesn't raise an error. Frozen Set Is immutable and hashable. That means it can be used as a key in a dictionary or as an element in a set. &lt;frozenset&gt; = frozenset(&lt;collection&gt;) Tuple Tuple is an immutable and hashable list. &lt;tuple&gt; = () &lt;tuple&gt; = (&lt;el&gt;, ) &lt;tuple&gt; = (&lt;el_1&gt;, &lt;el_2&gt; [, ...]) Named Tuple Tuple's subclass with named elements. &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Point = namedtuple('Point', 'x y') &gt;&gt;&gt; p = Point(1, y=2) Point(x=1, y=2) &gt;&gt;&gt; p[0] 1 &gt;&gt;&gt; p.x 1 &gt;&gt;&gt; getattr(p, 'y') 2 &gt;&gt;&gt; p._fields # Or: Point._fields ('x', 'y') Range &lt;range&gt; = range(to_exclusive) &lt;range&gt; = range(from_inclusive, to_exclusive) &lt;range&gt; = range(from_inclusive, to_exclusive, ±step_size) from_inclusive = &lt;range&gt;.start to_exclusive = &lt;range&gt;.stop Enumerate for i, el in enumerate(&lt;collection&gt; [, i_start]): ... Iterator &lt;iter&gt; = iter(&lt;collection&gt;) # `iter(&lt;iter&gt;)` returns unmodified iterator. &lt;iter&gt; = iter(&lt;function&gt;, to_exclusive) # A sequence of return values until 'to_exclusive'. &lt;el&gt; = next(&lt;iter&gt; [, default]) # Raises StopIteration or returns 'default' on end. &lt;list&gt; = list(&lt;iter&gt;) # Returns a list of iterator's remaining elements. Itertools from itertools import count, repeat, cycle, chain, islice &lt;iter&gt; = count(start=0, step=1) # Returns updated value endlessly. Accepts floats. &lt;iter&gt; = repeat(&lt;el&gt; [, times]) # Returns element endlessly or 'times' times. &lt;iter&gt; = cycle(&lt;collection&gt;) # Repeats the sequence endlessly. &lt;iter&gt; = chain(&lt;coll_1&gt;, &lt;coll_2&gt; [, ...]) # Empties collections in order. &lt;iter&gt; = chain.from_iterable(&lt;collection&gt;) # Empties collections inside a collection in order. &lt;iter&gt; = islice(&lt;collection&gt;, to_exclusive) &lt;iter&gt; = islice(&lt;collection&gt;, from_inclusive, to_exclusive [, +step_size]) Generator Any function that contains a yield statement returns a generator. Generators and iterators are interchangeable. def count(start, step): while True: yield start start += step &gt;&gt;&gt; counter = count(10, 2) &gt;&gt;&gt; next(counter), next(counter), next(counter) (10, 12, 14) Type Everything is an object. Every object has a type. Type and class are synonymous. &lt;type&gt; = type(&lt;el&gt;) # Or: &lt;el&gt;.__class__ &lt;bool&gt; = isinstance(&lt;el&gt;, &lt;type&gt;) # Or: issubclass(type(&lt;el&gt;), &lt;type&gt;) &gt;&gt;&gt; type('a'), 'a'.__class__, str (&lt;class 'str'&gt;, &lt;class 'str'&gt;, &lt;class 'str'&gt;) Some types do not have built-in names, so they must be imported: from types import FunctionType, MethodType, LambdaType, GeneratorType Abstract Base Classes Each abstract base class specifies a set of virtual subclasses. These classes are then recognized by isinstance() and issubclass() as subclasses of the ABC, although they are really not. &gt;&gt;&gt; from collections.abc import Sequence, Collection, Iterable &gt;&gt;&gt; isinstance([1, 2, 3], Iterable) True +------------------+------------+------------+------------+ | | Sequence | Collection | Iterable | +------------------+------------+------------+------------+ | list, range, str | yes | yes | yes | | dict, set | | yes | yes | | iter | | | yes | +------------------+------------+------------+------------+ &gt;&gt;&gt; from numbers import Integral, Rational, Real, Complex, Number &gt;&gt;&gt; isinstance(123, Number) True +--------------------+----------+----------+----------+----------+----------+ | | Integral | Rational | Real | Complex | Number | +--------------------+----------+----------+----------+----------+----------+ | int | yes | yes | yes | yes | yes | | fractions.Fraction | | yes | yes | yes | yes | | float | | | yes | yes | yes | | complex | | | | yes | yes | | decimal.Decimal | | | | | yes | +--------------------+----------+----------+----------+----------+----------+ String &lt;str&gt; = &lt;str&gt;.strip() # Strips all whitespace characters from both ends. &lt;str&gt; = &lt;str&gt;.strip('&lt;chars&gt;') # Strips all passed characters from both ends. &lt;list&gt; = &lt;str&gt;.split() # Splits on one or more whitespace characters. &lt;list&gt; = &lt;str&gt;.split(sep=None, maxsplit=-1) # Splits on 'sep' str at most 'maxsplit' times. &lt;list&gt; = &lt;str&gt;.splitlines(keepends=False) # Splits on \\n,\\r,\\r\\n. Keeps them if 'keepends'. &lt;str&gt; = &lt;str&gt;.join(&lt;coll_of_strings&gt;) # Joins elements using string as separator. &lt;bool&gt; = &lt;sub_str&gt; in &lt;str&gt; # Checks if string contains a substring. &lt;bool&gt; = &lt;str&gt;.startswith(&lt;sub_str&gt;) # Pass tuple of strings for multiple options. &lt;bool&gt; = &lt;str&gt;.endswith(&lt;sub_str&gt;) # Pass tuple of strings for multiple options. &lt;int&gt; = &lt;str&gt;.find(&lt;sub_str&gt;) # Returns start index of first match or -1. &lt;int&gt; = &lt;str&gt;.index(&lt;sub_str&gt;) # Same but raises ValueError if missing. &lt;str&gt; = &lt;str&gt;.replace(old, new [, count]) # Replaces 'old' with 'new' at most 'count' times. &lt;str&gt; = &lt;str&gt;.translate(&lt;table&gt;) # Use `str.maketrans(&lt;dict&gt;)` to generate table. &lt;str&gt; = chr(&lt;int&gt;) # Converts int to Unicode char. &lt;int&gt; = ord(&lt;str&gt;) # Converts Unicode char to int. Also: 'lstrip()', 'rstrip()'. Also: 'lower()', 'upper()', 'capitalize()' and 'title()'. Property Methods +---------------+----------+----------+----------+----------+----------+ | | [ !#$%…] | [a-zA-Z] | [¼½¾] | [²³¹] | [0-9] | +---------------+----------+----------+----------+----------+----------+ | isprintable() | yes | yes | yes | yes | yes | | isalnum() | | yes | yes | yes | yes | | isnumeric() | | | yes | yes | yes | | isdigit() | | | | yes | yes | | isdecimal() | | | | | yes | +---------------+----------+----------+----------+----------+----------+ Also: 'isspace()' checks for '[ \\t\\n\\r\\f\\v…]'. Regex import re &lt;str&gt; = re.sub(&lt;regex&gt;, new, text, count=0) # Substitutes all occurrences with 'new'. &lt;list&gt; = re.findall(&lt;regex&gt;, text) # Returns all occurrences as strings. &lt;list&gt; = re.split(&lt;regex&gt;, text, maxsplit=0) # Use brackets in regex to include the matches. &lt;Match&gt; = re.search(&lt;regex&gt;, text) # Searches for first occurrence of the pattern. &lt;Match&gt; = re.match(&lt;regex&gt;, text) # Searches only at the beginning of the text. &lt;iter&gt; = re.finditer(&lt;regex&gt;, text) # Returns all occurrences as match objects. Search() and match() return None if they can't find a match. Argument 'flags=re.IGNORECASE' can be used with all functions. Argument 'flags=re.MULTILINE' makes '^' and '$' match the start/end of each line. Argument 'flags=re.DOTALL' makes dot also accept the '\\n'. Use r'\\1' or '\\\\1' for backreference. Add '?' after an operator to make it non-greedy. Match Object &lt;str&gt; = &lt;Match&gt;.group() # Returns the whole match. Also group(0). &lt;str&gt; = &lt;Match&gt;.group(1) # Returns part in the first bracket. &lt;tuple&gt; = &lt;Match&gt;.groups() # Returns all bracketed parts. &lt;int&gt; = &lt;Match&gt;.start() # Returns start index of the match. &lt;int&gt; = &lt;Match&gt;.end() # Returns exclusive end index of the match. Special Sequences By default digits, alphanumerics and whitespaces from all alphabets are matched, unless 'flags=re.ASCII' argument is used. Use a capital letter for negation. '\\d' == '[0-9]' # Matches any digit. '\\w' == '[a-zA-Z0-9_]' # Matches any alphanumeric. '\\s' == '[ \\t\\n\\r\\f\\v]' # Matches any whitespace. Format &lt;str&gt; = f'{&lt;el_1&gt;}, {&lt;el_2&gt;}' &lt;str&gt; = '{}, {}'.format(&lt;el_1&gt;, &lt;el_2&gt;) Attributes &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Person = namedtuple('Person', 'name height') &gt;&gt;&gt; person = Person('Jean-Luc', 187) &gt;&gt;&gt; f'{person.height}' '187' &gt;&gt;&gt; '{p.height}'.format(p=person) '187' General Options {&lt;el&gt;:&lt;10} # '&lt;el&gt; ' {&lt;el&gt;:^10} # ' &lt;el&gt; ' {&lt;el&gt;:&gt;10} # ' &lt;el&gt;' {&lt;el&gt;:.&lt;10} # '&lt;el&gt;......' {&lt;el&gt;:&lt;0} # '&lt;el&gt;' Strings '!r' calls object's repr() method, instead of str(), to get a string. {'abcde'!r:10} # &quot;'abcde' &quot; {'abcde':10.3} # 'abc ' {'abcde':.3} # 'abc' Numbers { 123456:10,} # ' 123,456' { 123456:10_} # ' 123_456' { 123456:+10} # ' +123456' {-123456:=10} # '- 123456' { 123456: } # ' 123456' {-123456: } # '-123456' Floats {1.23456:10.3} # ' 1.23' {1.23456:10.3f} # ' 1.235' {1.23456:10.3e} # ' 1.235e+00' {1.23456:10.3%} # ' 123.456%' Comparison of presentation types: +---------------+-----------------+-----------------+-----------------+-----------------+ | | {&lt;float&gt;} | {&lt;float&gt;:f} | {&lt;float&gt;:e} | {&lt;float&gt;:%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | '5.6789e-05' | '0.000057' | '5.678900e-05' | '0.005679%' | | 0.00056789 | '0.00056789' | '0.000568' | '5.678900e-04' | '0.056789%' | | 0.0056789 | '0.0056789' | '0.005679' | '5.678900e-03' | '0.567890%' | | 0.056789 | '0.056789' | '0.056789' | '5.678900e-02' | '5.678900%' | | 0.56789 | '0.56789' | '0.567890' | '5.678900e-01' | '56.789000%' | | 5.6789 | '5.6789' | '5.678900' | '5.678900e+00' | '567.890000%' | | 56.789 | '56.789' | '56.789000' | '5.678900e+01' | '5678.900000%' | | 567.89 | '567.89' | '567.890000' | '5.678900e+02' | '56789.000000%' | +---------------+-----------------+-----------------+-----------------+-----------------+ +---------------+-----------------+-----------------+-----------------+-----------------+ | | {&lt;float&gt;:.2} | {&lt;float&gt;:.2f} | {&lt;float&gt;:.2e} | {&lt;float&gt;:.2%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | '5.7e-05' | '0.00' | '5.68e-05' | '0.01%' | | 0.00056789 | '0.00057' | '0.00' | '5.68e-04' | '0.06%' | | 0.0056789 | '0.0057' | '0.01' | '5.68e-03' | '0.57%' | | 0.056789 | '0.057' | '0.06' | '5.68e-02' | '5.68%' | | 0.56789 | '0.57' | '0.57' | '5.68e-01' | '56.79%' | | 5.6789 | '5.7' | '5.68' | '5.68e+00' | '567.89%' | | 56.789 | '5.7e+01' | '56.79' | '5.68e+01' | '5678.90%' | | 567.89 | '5.7e+02' | '567.89' | '5.68e+02' | '56789.00%' | +---------------+-----------------+-----------------+-----------------+-----------------+ Ints {90:c} # 'Z' {90:b} # '1011010' {90:X} # '5A' Numbers Types &lt;int&gt; = int(&lt;float/str/bool&gt;) # Or: math.floor(&lt;float&gt;) &lt;float&gt; = float(&lt;int/str/bool&gt;) # Or: &lt;real&gt;e±&lt;int&gt; &lt;complex&gt; = complex(real=0, imag=0) # Or: &lt;real&gt; ± &lt;real&gt;j &lt;Fraction&gt; = fractions.Fraction(0, 1) # Or: Fraction(numerator=0, denominator=1) &lt;Decimal&gt; = decimal.Decimal(&lt;str/int&gt;) # Or: Decimal((sign, digits, exponent)) 'int(&lt;str&gt;)' and 'float(&lt;str&gt;)' raise ValueError on malformed strings. Decimal numbers can be represented exactly, unlike floats where '1.1 + 2.2 != 3.3'. Precision of decimal operations is set with: 'decimal.getcontext().prec = &lt;int&gt;'. Basic Functions &lt;num&gt; = pow(&lt;num&gt;, &lt;num&gt;) # Or: &lt;num&gt; ** &lt;num&gt; &lt;num&gt; = abs(&lt;num&gt;) # &lt;float&gt; = abs(&lt;complex&gt;) &lt;num&gt; = round(&lt;num&gt; [, ±ndigits]) # `round(126, -1) == 130` Math from math import e, pi, inf, nan, isinf, isnan from math import cos, acos, sin, asin, tan, atan, degrees, radians from math import log, log10, log2 Statistics from statistics import mean, median, variance, stdev, pvariance, pstdev Random from random import random, randint, choice, shuffle &lt;float&gt; = random() &lt;int&gt; = randint(from_inclusive, to_inclusive) &lt;el&gt; = choice(&lt;list&gt;) shuffle(&lt;list&gt;) Bin, Hex &lt;int&gt; = 0b&lt;bin&gt; # Or: 0x&lt;hex&gt; &lt;int&gt; = int('±&lt;bin&gt;', 2) # Or: int('±&lt;hex&gt;', 16) &lt;int&gt; = int('±0b&lt;bin&gt;', 0) # Or: int('±0x&lt;hex&gt;', 0) '[-]0b&lt;bin&gt;' = bin(&lt;int&gt;) # Or: hex(&lt;int&gt;) Bitwise Operators &lt;int&gt; = &lt;int&gt; &amp; &lt;int&gt; # And &lt;int&gt; = &lt;int&gt; | &lt;int&gt; # Or &lt;int&gt; = &lt;int&gt; ^ &lt;int&gt; # Xor (0 if both bits equal) &lt;int&gt; = &lt;int&gt; &lt;&lt; n_bits # Shift left (&gt;&gt; for right) &lt;int&gt; = ~&lt;int&gt; # Not (also: -&lt;int&gt; - 1) Combinatorics Every function returns an iterator. If you want to print the iterator, you need to pass it to the list() function first! from itertools import product, combinations, combinations_with_replacement, permutations &gt;&gt;&gt; product([0, 1], repeat=3) [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)] &gt;&gt;&gt; product('ab', '12') [('a', '1'), ('a', '2'), ('b', '1'), ('b', '2')] &gt;&gt;&gt; combinations('abc', 2) [('a', 'b'), ('a', 'c'), ('b', 'c')] &gt;&gt;&gt; combinations_with_replacement('abc', 2) [('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')] &gt;&gt;&gt; permutations('abc', 2) [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')] Datetime Module 'datetime' provides 'date' &lt;D&gt;, 'time' &lt;T&gt;, 'datetime' &lt;DT&gt; and 'timedelta' &lt;TD&gt; classes. All are immutable and hashable. Time and datetime objects can be 'aware' &lt;a&gt;, meaning they have defined timezone, or 'naive' &lt;n&gt;, meaning they don't. If object is naive, it is presumed to be in the system's timezone. from datetime import date, time, datetime, timedelta from dateutil.tz import UTC, tzlocal, gettz, resolve_imaginary Constructors &lt;D&gt; = date(year, month, day) &lt;T&gt; = time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0) &lt;DT&gt; = datetime(year, month, day, hour=0, minute=0, second=0, ...) &lt;TD&gt; = timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) Use '&lt;D/DT&gt;.weekday()' to get the day of the week (Mon == 0). 'fold=1' means the second pass in case of time jumping back for one hour. '&lt;DTa&gt; = resolve_imaginary(&lt;DTa&gt;)' fixes DTs that fall into the missing hour. Now &lt;D/DTn&gt; = D/DT.today() # Current local date or naive datetime. &lt;DTn&gt; = DT.utcnow() # Naive datetime from current UTC time. &lt;DTa&gt; = DT.now(&lt;tzinfo&gt;) # Aware datetime from current tz time. To extract time use '&lt;DTn&gt;.time()', '&lt;DTa&gt;.time()' or '&lt;DTa&gt;.timetz()'. Timezone &lt;tzinfo&gt; = UTC # UTC timezone. London without DST. &lt;tzinfo&gt; = tzlocal() # Local timezone. Also gettz(). &lt;tzinfo&gt; = gettz('&lt;Continent&gt;/&lt;City&gt;') # 'Continent/City_Name' timezone or None. &lt;DTa&gt; = &lt;DT&gt;.astimezone(&lt;tzinfo&gt;) # Datetime, converted to passed timezone. &lt;Ta/DTa&gt; = &lt;T/DT&gt;.replace(tzinfo=&lt;tzinfo&gt;) # Unconverted object with new timezone. Encode &lt;D/T/DT&gt; = D/T/DT.fromisoformat('&lt;iso&gt;') # Object from ISO string. Raises ValueError. &lt;DT&gt; = DT.strptime(&lt;str&gt;, '&lt;format&gt;') # Datetime from str, according to format. &lt;D/DTn&gt; = D/DT.fromordinal(&lt;int&gt;) # D/DTn from days since Christ, at midnight. &lt;DTn&gt; = DT.fromtimestamp(&lt;real&gt;) # Local time DTn from seconds since Epoch. &lt;DTa&gt; = DT.fromtimestamp(&lt;real&gt;, &lt;tz.&gt;) # Aware datetime from seconds since Epoch. ISO strings come in following forms: 'YYYY-MM-DD', 'HH:MM:SS.ffffff[±&lt;offset&gt;]', or both separated by an arbitrary character. Offset is formatted as: 'HH:MM'. Epoch on Unix systems is: '1970-01-01 00:00 UTC', '1970-01-01 01:00 CET', ... Decode &lt;str&gt; = &lt;D/T/DT&gt;.isoformat(sep='T') # Also timespec='auto/hours/minutes/seconds'. &lt;str&gt; = &lt;D/T/DT&gt;.strftime('&lt;format&gt;') # Custom string representation. &lt;int&gt; = &lt;D/DT&gt;.toordinal() # Days since Christ, ignoring time and tz. &lt;float&gt; = &lt;DTn&gt;.timestamp() # Seconds since Epoch, from DTn in local tz. &lt;float&gt; = &lt;DTa&gt;.timestamp() # Seconds since Epoch, from DTa. Format &gt;&gt;&gt; from datetime import datetime &gt;&gt;&gt; dt = datetime.strptime('2015-05-14 23:39:00.00 +0200', '%Y-%m-%d %H:%M:%S.%f %z') &gt;&gt;&gt; dt.strftime(&quot;%A, %dth of %B '%y, %I:%M%p %Z&quot;) &quot;Thursday, 14th of May '15, 11:39PM UTC+02:00&quot; When parsing, '%z' also accepts '±HH:MM'. For abbreviated weekday and month use '%a' and '%b'. Arithmetics &lt;D/DT&gt; = &lt;D/DT&gt; ± &lt;TD&gt; # Returned datetime can fall into missing hour. &lt;TD&gt; = &lt;D/DTn&gt; - &lt;D/DTn&gt; # Returns the difference, ignoring time jumps. &lt;TD&gt; = &lt;DTa&gt; - &lt;DTa&gt; # Ignores time jumps if they share tzinfo object. &lt;TD&gt; = &lt;DT_UTC&gt; - &lt;DT_UTC&gt; # Convert DTs to UTC to get the actual delta. Arguments Inside Function Call &lt;function&gt;(&lt;positional_args&gt;) # f(0, 0) &lt;function&gt;(&lt;keyword_args&gt;) # f(x=0, y=0) &lt;function&gt;(&lt;positional_args&gt;, &lt;keyword_args&gt;) # f(0, y=0) Inside Function Definition def f(&lt;nondefault_args&gt;): # def f(x, y): def f(&lt;default_args&gt;): # def f(x=0, y=0): def f(&lt;nondefault_args&gt;, &lt;default_args&gt;): # def f(x, y=0): Splat Operator Inside Function Call Splat expands a collection into positional arguments, while splatty-splat expands a dictionary into keyword arguments. args = (1, 2) kwargs = {'x': 3, 'y': 4, 'z': 5} func(*args, **kwargs) Is the same as: func(1, 2, x=3, y=4, z=5) Inside Function Definition Splat combines zero or more positional arguments into a tuple, while splatty-splat combines zero or more keyword arguments into a dictionary. def add(*a): return sum(a) &gt;&gt;&gt; add(1, 2, 3) 6 Legal argument combinations: def f(x, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*, x, y, z): # f(x=1, y=2, z=3) def f(x, *, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, y, *, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) def f(*args): # f(1, 2, 3) def f(x, *args): # f(1, 2, 3) def f(*args, z): # f(1, 2, z=3) def f(x, *args, z): # f(1, 2, z=3) def f(**kwargs): # f(x=1, y=2, z=3) def f(x, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(*, x, **kwargs): # f(x=1, y=2, z=3) def f(*args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(x, *args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*args, y, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, *args, z, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) Other Uses &lt;list&gt; = [*&lt;collection&gt; [, ...]] &lt;set&gt; = {*&lt;collection&gt; [, ...]} &lt;tuple&gt; = (*&lt;collection&gt;, [...]) &lt;dict&gt; = {**&lt;dict&gt; [, ...]} head, *body, tail = &lt;collection&gt; Inline Lambda &lt;function&gt; = lambda: &lt;return_value&gt; &lt;function&gt; = lambda &lt;argument_1&gt;, &lt;argument_2&gt;: &lt;return_value&gt; Comprehension &lt;list&gt; = [i+1 for i in range(10)] # [1, 2, ..., 10] &lt;set&gt; = {i for i in range(10) if i &gt; 5} # {6, 7, 8, 9} &lt;iter&gt; = (i+5 for i in range(10)) # (5, 6, ..., 14) &lt;dict&gt; = {i: i*2 for i in range(10)} # {0: 0, 1: 2, ..., 9: 18} out = [i+j for i in range(10) for j in range(10)] Is the same as: out = [] for i in range(10): for j in range(10): out.append(i+j) Map, Filter, Reduce from functools import reduce &lt;iter&gt; = map(lambda x: x + 1, range(10)) # (1, 2, ..., 10) &lt;iter&gt; = filter(lambda x: x &gt; 5, range(10)) # (6, 7, 8, 9) &lt;obj&gt; = reduce(lambda out, x: out + x, range(10)) # 45 Any, All &lt;bool&gt; = any(&lt;collection&gt;) # False if empty. &lt;bool&gt; = all(el[1] for el in &lt;collection&gt;) # True if empty. If - Else &lt;obj&gt; = &lt;expression_if_true&gt; if &lt;condition&gt; else &lt;expression_if_false&gt; &gt;&gt;&gt; [a if a else 'zero' for a in (0, 1, 2, 3)] ['zero', 1, 2, 3] Namedtuple, Enum, Dataclass from collections import namedtuple Point = namedtuple('Point', 'x y') point = Point(0, 0) from enum import Enum Direction = Enum('Direction', 'n e s w') direction = Direction.n from dataclasses import make_dataclass Creature = make_dataclass('Creature', ['location', 'direction']) creature = Creature(Point(0, 0), Direction.n) Closure We have a closure in Python when: A nested function references a value of its enclosing function and then the enclosing function returns the nested function. def get_multiplier(a): def out(b): return a * b return out &gt;&gt;&gt; multiply_by_3 = get_multiplier(3) &gt;&gt;&gt; multiply_by_3(10) 30 If multiple nested functions within enclosing function reference the same value, that value gets shared. To dynamically access function's first free variable use '&lt;function&gt;.__closure__[0].cell_contents'. Partial from functools import partial &lt;function&gt; = partial(&lt;function&gt; [, &lt;arg_1&gt;, &lt;arg_2&gt;, ...]) &gt;&gt;&gt; import operator as op &gt;&gt;&gt; multiply_by_3 = partial(op.mul, 3) &gt;&gt;&gt; multiply_by_3(10) 30 Partial is also useful in cases when function needs to be passed as an argument, because it enables us to set its arguments beforehand. A few examples being: 'defaultdict(&lt;function&gt;)', 'iter(&lt;function&gt;, to_exclusive)' and dataclass's 'field(default_factory=&lt;function&gt;)'. Non-Local If variable is being assigned to anywhere in the scope, it is regarded as a local variable, unless it is declared as a 'global' or a 'nonlocal'. def get_counter(): i = 0 def out(): nonlocal i i += 1 return i return out &gt;&gt;&gt; counter = get_counter() &gt;&gt;&gt; counter(), counter(), counter() (1, 2, 3) Decorator A decorator takes a function, adds some functionality and returns it. @decorator_name def function_that_gets_passed_to_decorator(): ... Debugger Example Decorator that prints function's name every time it gets called. from functools import wraps def debug(func): @wraps(func) def out(*args, **kwargs): print(func.__name__) return func(*args, **kwargs) return out @debug def add(x, y): return x + y Wraps is a helper decorator that copies the metadata of the passed function (func) to the function it is wrapping (out). Without it 'add.__name__' would return 'out'. LRU Cache Decorator that caches function's return values. All function's arguments must be hashable. from functools import lru_cache @lru_cache(maxsize=None) def fib(n): return n if n &lt; 2 else fib(n-2) + fib(n-1) CPython interpreter limits recursion depth to 1000 by default. To increase it use 'sys.setrecursionlimit(&lt;depth&gt;)'. Parametrized Decorator A decorator that accepts arguments and returns a normal decorator that accepts a function. from functools import wraps def debug(print_result=False): def decorator(func): @wraps(func) def out(*args, **kwargs): result = func(*args, **kwargs) print(func.__name__, result if print_result else '') return result return out return decorator @debug(print_result=True) def add(x, y): return x + y Class class &lt;name&gt;: def __init__(self, a): self.a = a def __repr__(self): class_name = self.__class__.__name__ return f'{class_name}({self.a!r})' def __str__(self): return str(self.a) @classmethod def get_class_name(cls): return cls.__name__ Return value of repr() should be unambiguous and of str() readable. If only repr() is defined, it will also be used for str(). Str() use cases: print(&lt;el&gt;) print(f'{&lt;el&gt;}') raise Exception(&lt;el&gt;) loguru.logger.debug(&lt;el&gt;) csv.writer(&lt;file&gt;).writerow([&lt;el&gt;]) Repr() use cases: print([&lt;el&gt;]) print(f'{&lt;el&gt;!r}') &gt;&gt;&gt; &lt;el&gt; loguru.logger.exception() Z = dataclasses.make_dataclass('Z', ['a']); print(Z(&lt;el&gt;)) Constructor Overloading class &lt;name&gt;: def __init__(self, a=None): self.a = a Inheritance class Person: def __init__(self, name, age): self.name = name self.age = age class Employee(Person): def __init__(self, name, age, staff_num): super().__init__(name, age) self.staff_num = staff_num Multiple Inheritance class A: pass class B: pass class C(A, B): pass MRO determines the order in which parent classes are traversed when searching for a method: &gt;&gt;&gt; C.mro() [&lt;class 'C'&gt;, &lt;class 'A'&gt;, &lt;class 'B'&gt;, &lt;class 'object'&gt;] Property Pythonic way of implementing getters and setters. class MyClass: @property def a(self): return self._a @a.setter def a(self, value): self._a = value &gt;&gt;&gt; el = MyClass() &gt;&gt;&gt; el.a = 123 &gt;&gt;&gt; el.a 123 Dataclass Decorator that automatically generates init(), repr() and eq() special methods. from dataclasses import dataclass, field @dataclass(order=False, frozen=False) class &lt;class_name&gt;: &lt;attr_name_1&gt;: &lt;type&gt; &lt;attr_name_2&gt;: &lt;type&gt; = &lt;default_value&gt; &lt;attr_name_3&gt;: list/dict/set = field(default_factory=list/dict/set) Objects can be made sortable with 'order=True' and/or immutable and hashable with 'frozen=True'. Function field() is needed because '&lt;attr_name&gt;: list = []' would make a list that is shared among all instances. Default_factory can be any callable. Inline: from dataclasses import make_dataclass &lt;class&gt; = make_dataclass('&lt;class_name&gt;', &lt;coll_of_attribute_names&gt;) &lt;class&gt; = make_dataclass('&lt;class_name&gt;', &lt;coll_of_tuples&gt;) &lt;tuple&gt; = ('&lt;attr_name&gt;', &lt;type&gt; [, &lt;default_value&gt;]) Slots Mechanism that restricts objects to attributes listed in 'slots' and significantly reduces their memory footprint. class MyClassWithSlots: __slots__ = ['a'] def __init__(self): self.a = 1 Copy from copy import copy, deepcopy &lt;object&gt; = copy(&lt;object&gt;) &lt;object&gt; = deepcopy(&lt;object&gt;) Duck Types A duck type is an implicit type that prescribes a set of special methods. Any object that has those methods defined is considered a member of that duck type. Comparable If eq() method is not overridden, it returns 'id(self) == id(other)', which is the same as 'self is other'. That means all objects compare not equal by default. Only the left side object has eq() method called, unless it returns NotImplemented, in which case the right object is consulted. class MyComparable: def __init__(self, a): self.a = a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented Hashable Hashable object needs both hash() and eq() methods and its hash value should never change. Hashable objects that compare equal must have the same hash value, meaning default hash() that returns 'id(self)' will not do. That is why Python automatically makes classes unhashable if you only implement eq(). class MyHashable: def __init__(self, a): self._a = a @property def a(self): return self._a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented def __hash__(self): return hash(self.a) Sortable With total_ordering decorator, you only need to provide eq() and one of lt(), gt(), le() or ge() special methods. from functools import total_ordering @total_ordering class MySortable: def __init__(self, a): self.a = a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented def __lt__(self, other): if isinstance(other, type(self)): return self.a &lt; other.a return NotImplemented Iterator Any object that has methods next() and iter() is an iterator. Next() should return next item or raise StopIteration. Iter() should return 'self'. class Counter: def __init__(self): self.i = 0 def __next__(self): self.i += 1 return self.i def __iter__(self): return self &gt;&gt;&gt; counter = Counter() &gt;&gt;&gt; next(counter), next(counter), next(counter) (1, 2, 3) Python has many different iterator objects: Iterators returned by the iter() function, such as list_iterator and set_iterator. Objects returned by the itertools module, such as count, repeat and cycle. Generators returned by the generator functions and generator expressions. File objects returned by the open() function, etc. Callable All functions and classes have a call() method, hence are callable. When this cheatsheet uses '&lt;function&gt;' as an argument, it actually means '&lt;callable&gt;'. class Counter: def __init__(self): self.i = 0 def __call__(self): self.i += 1 return self.i &gt;&gt;&gt; counter = Counter() &gt;&gt;&gt; counter(), counter(), counter() (1, 2, 3) Context Manager Enter() should lock the resources and optionally return an object. Exit() should release the resources. Any exception that happens inside the with block is passed to the exit() method. If it wishes to suppress the exception it must return a true value. class MyOpen: def __init__(self, filename): self.filename = filename def __enter__(self): self.file = open(self.filename) return self.file def __exit__(self, exc_type, exception, traceback): self.file.close() &gt;&gt;&gt; with open('test.txt', 'w') as file: ... file.write('Hello World!') &gt;&gt;&gt; with MyOpen('test.txt') as file: ... print(file.read()) Hello World! Iterable Duck Types Iterable Only required method is iter(). It should return an iterator of object's items. Contains() automatically works on any object that has iter() defined. class MyIterable: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a &gt;&gt;&gt; obj = MyIterable([1, 2, 3]) &gt;&gt;&gt; [el for el in obj] [1, 2, 3] &gt;&gt;&gt; 1 in obj True Collection Only required methods are iter() and len(). This cheatsheet actually means '&lt;iterable&gt;' when it uses '&lt;collection&gt;'. I chose not to use the name 'iterable' because it sounds scarier and more vague than 'collection'. class MyCollection: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a def __len__(self): return len(self.a) Sequence Only required methods are len() and getitem(). Getitem() should return an item at index or raise IndexError. Iter() and contains() automatically work on any object that has getitem() defined. Reversed() automatically works on any object that has getitem() and len() defined. class MySequence: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a def __len__(self): return len(self.a) def __getitem__(self, i): return self.a[i] def __reversed__(self): return reversed(self.a) ABC Sequence It's a richer interface than the basic sequence. Extending it generates iter(), contains(), reversed(), index() and count(). Unlike 'abc.Iterable' and 'abc.Collection', it is not a duck type. That is why 'issubclass(MySequence, abc.Sequence)' would return False even if MySequence had all the methods defined. from collections import abc class MyAbcSequence(abc.Sequence): def __init__(self, a): self.a = a def __len__(self): return len(self.a) def __getitem__(self, i): return self.a[i] Table of required and automatically available special methods: +------------+------------+------------+------------+--------------+ | | Iterable | Collection | Sequence | abc.Sequence | +------------+------------+------------+------------+--------------+ | iter() | REQ | REQ | Yes | Yes | | contains() | Yes | Yes | Yes | Yes | | len() | | REQ | REQ | REQ | | getitem() | | | REQ | REQ | | reversed() | | | Yes | Yes | | index() | | | | Yes | | count() | | | | Yes | +------------+------------+------------+------------+--------------+ Other ABCs that generate missing methods are: MutableSequence, Set, MutableSet, Mapping and MutableMapping. Names of their required methods are stored in '&lt;abc&gt;.__abstractmethods__'. Enum from enum import Enum, auto class &lt;enum_name&gt;(Enum): &lt;member_name_1&gt; = &lt;value_1&gt; &lt;member_name_2&gt; = &lt;value_2_a&gt;, &lt;value_2_b&gt; &lt;member_name_3&gt; = auto() If there are no numeric values before auto(), it returns 1. Otherwise it returns an increment of the last numeric value. &lt;member&gt; = &lt;enum&gt;.&lt;member_name&gt; # Returns a member. &lt;member&gt; = &lt;enum&gt;['&lt;member_name&gt;'] # Returns a member or raises KeyError. &lt;member&gt; = &lt;enum&gt;(&lt;value&gt;) # Returns a member or raises ValueError. &lt;str&gt; = &lt;member&gt;.name # Returns member's name. &lt;obj&gt; = &lt;member&gt;.value # Returns member's value. list_of_members = list(&lt;enum&gt;) member_names = [a.name for a in &lt;enum&gt;] member_values = [a.value for a in &lt;enum&gt;] random_member = random.choice(list(&lt;enum&gt;)) def get_next_member(member): members = list(member.__class__) index = (members.index(member) + 1) % len(members) return members[index] Inline Cutlery = Enum('Cutlery', 'fork knife spoon') Cutlery = Enum('Cutlery', ['fork', 'knife', 'spoon']) Cutlery = Enum('Cutlery', {'fork': 1, 'knife': 2, 'spoon': 3}) User-defined functions cannot be values, so they must be wrapped: from functools import partial LogicOp = Enum('LogicOp', {'AND': partial(lambda l, r: l and r), 'OR' : partial(lambda l, r: l or r)}) Another solution in this particular case is to use built-in functions and_() and or_() from the module operator. Exceptions Basic Example try: &lt;code&gt; except &lt;exception&gt;: &lt;code&gt; Complex Example try: &lt;code_1&gt; except &lt;exception_a&gt;: &lt;code_2_a&gt; except &lt;exception_b&gt;: &lt;code_2_b&gt; else: &lt;code_2_c&gt; finally: &lt;code_3&gt; Catching Exceptions except &lt;exception&gt;: except &lt;exception&gt; as &lt;name&gt;: except (&lt;exception&gt;, ...): except (&lt;exception&gt;, ...) as &lt;name&gt;: Also catches subclasses of the exception. Use 'traceback.print_exc()' to print the error message to stderr. Raising Exceptions raise &lt;exception&gt; raise &lt;exception&gt;() raise &lt;exception&gt;(&lt;el&gt; [, ...]) Re-raising caught exception: except &lt;exception&gt; as &lt;name&gt;: ... raise Exception Object arguments = &lt;name&gt;.args exc_type = &lt;name&gt;.__class__ filename = &lt;name&gt;.__traceback__.tb_frame.f_code.co_filename func_name = &lt;name&gt;.__traceback__.tb_frame.f_code.co_name line = linecache.getline(filename, &lt;name&gt;.__traceback__.tb_lineno) error_msg = traceback.format_exception(exc_type, &lt;name&gt;, &lt;name&gt;.__traceback__) Built-in Exceptions BaseException +-- SystemExit # Raised by the sys.exit() function. +-- KeyboardInterrupt # Raised when the user hits the interrupt key (ctrl-c). +-- Exception # User-defined exceptions should be derived from this class. +-- ArithmeticError # Base class for arithmetic errors. | +-- ZeroDivisionError # Raised when dividing by zero. +-- AttributeError # Raised when an attribute is missing. +-- EOFError # Raised by input() when it hits end-of-file condition. +-- LookupError # Raised when a look-up on a collection fails. | +-- IndexError # Raised when a sequence index is out of range. | +-- KeyError # Raised when a dictionary key or set element is not found. +-- NameError # Raised when a variable name is not found. +-- OSError # Failures such as “file not found” or “disk full”. | +-- FileNotFoundError # When a file or directory is requested but doesn't exist. +-- RuntimeError # Raised by errors that don't fall into other categories. | +-- RecursionError # Raised when the maximum recursion depth is exceeded. +-- StopIteration # Raised by next() when run on an empty iterator. +-- TypeError # Raised when an argument is of wrong type. +-- ValueError # When an argument is of right type but inappropriate value. +-- UnicodeError # Raised when encoding/decoding strings to/from bytes fails. Collections and their exceptions: +-----------+------------+------------+------------+ | | list | dict | set | +-----------+------------+------------+------------+ | getitem() | IndexError | KeyError | | | pop() | IndexError | KeyError | KeyError | | remove() | ValueError | | KeyError | | index() | ValueError | | | +-----------+------------+------------+------------+ Useful built-in exceptions: raise TypeError('Argument is of wrong type!') raise ValueError('Argument is of right type but inappropriate value!') raise RuntimeError('None of above!') User-defined Exceptions class MyError(Exception): pass class MyInputError(MyError): pass Exit Exits the interpreter by raising SystemExit exception. import sys sys.exit() # Exits with exit code 0 (success). sys.exit(&lt;el&gt;) # Prints to stderr and exits with 1. sys.exit(&lt;int&gt;) # Exits with passed exit code. Print print(&lt;el_1&gt;, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Use 'file=sys.stderr' for messages about errors. Use 'flush=True' to forcibly flush the stream. Pretty Print from pprint import pprint pprint(&lt;collection&gt;, width=80, depth=None, compact=False, sort_dicts=True) Levels deeper than 'depth' get replaced by '...'. Input Reads a line from user input or pipe if present. &lt;str&gt; = input(prompt=None) Trailing newline gets stripped. Prompt string is printed to the standard output before reading input. Raises EOFError when user hits EOF (ctrl-d/z) or input stream gets exhausted. Command Line Arguments import sys script_name = sys.argv[0] arguments = sys.argv[1:] Argument Parser from argparse import ArgumentParser, FileType p = ArgumentParser(description=&lt;str&gt;) p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', action='store_true') # Flag p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', type=&lt;type&gt;) # Option p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs=1) # First argument p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='+') # Remaining arguments p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='*') # Optional arguments args = p.parse_args() # Exits on error. value = args.&lt;name&gt; Use 'help=&lt;str&gt;' to set argument description. Use 'default=&lt;el&gt;' to set the default value. Use 'type=FileType(&lt;mode&gt;)' for files. Open Opens the file and returns a corresponding file object. &lt;file&gt; = open('&lt;path&gt;', mode='r', encoding=None, newline=None) 'encoding=None' means that the default encoding is used, which is platform dependent. Best practice is to use 'encoding=&quot;utf-8&quot;' whenever possible. 'newline=None' means all different end of line combinations are converted to '\\n' on read, while on write all '\\n' characters are converted to system's default line separator. 'newline=&quot;&quot;' means no conversions take place, but input is still broken into chunks by readline() and readlines() on either '\\n', '\\r' or '\\r\\n'. Modes 'r' - Read (default). 'w' - Write (truncate). 'x' - Write or fail if the file already exists. 'a' - Append. 'w+' - Read and write (truncate). 'r+' - Read and write from the start. 'a+' - Read and write from the end. 't' - Text mode (default). 'b' - Binary mode. Exceptions 'FileNotFoundError' can be raised when reading with 'r' or 'r+'. 'FileExistsError' can be raised when writing with 'x'. 'IsADirectoryError' and 'PermissionError' can be raised by any. 'OSError' is the parent class of all listed exceptions. File Object &lt;file&gt;.seek(0) # Moves to the start of the file. &lt;file&gt;.seek(offset) # Moves 'offset' chars/bytes from the start. &lt;file&gt;.seek(0, 2) # Moves to the end of the file. &lt;bin_file&gt;.seek(±offset, &lt;anchor&gt;) # Anchor: 0 start, 1 current position, 2 end. &lt;str/bytes&gt; = &lt;file&gt;.read(size=-1) # Reads 'size' chars/bytes or until EOF. &lt;str/bytes&gt; = &lt;file&gt;.readline() # Returns a line or empty string/bytes on EOF. &lt;list&gt; = &lt;file&gt;.readlines() # Returns a list of remaining lines. &lt;str/bytes&gt; = next(&lt;file&gt;) # Returns a line using buffer. Do not mix. &lt;file&gt;.write(&lt;str/bytes&gt;) # Writes a string or bytes object. &lt;file&gt;.writelines(&lt;collection&gt;) # Writes a coll. of strings or bytes objects. &lt;file&gt;.flush() # Flushes write buffer. Methods do not add or strip trailing newlines, even writelines(). Read Text from File def read_file(filename): with open(filename, encoding='utf-8') as file: return file.readlines() Write Text to File def write_to_file(filename, text): with open(filename, 'w', encoding='utf-8') as file: file.write(text) Path from os import getcwd, path, listdir from glob import glob &lt;str&gt; = getcwd() # Returns the current working directory. &lt;str&gt; = path.join(&lt;path&gt;, ...) # Joins two or more pathname components. &lt;str&gt; = path.abspath(&lt;path&gt;) # Returns absolute path. &lt;str&gt; = path.basename(&lt;path&gt;) # Returns final component of the path. &lt;str&gt; = path.dirname(&lt;path&gt;) # Returns path without the final component. &lt;tup.&gt; = path.splitext(&lt;path&gt;) # Splits on last period of the final component. &lt;list&gt; = listdir(path='.') # Returns filenames located at path. &lt;list&gt; = glob('&lt;pattern&gt;') # Returns paths matching the wildcard pattern. &lt;bool&gt; = path.exists(&lt;path&gt;) # Or: &lt;Path&gt;.exists() &lt;bool&gt; = path.isfile(&lt;path&gt;) # Or: &lt;DirEntry/Path&gt;.is_file() &lt;bool&gt; = path.isdir(&lt;path&gt;) # Or: &lt;DirEntry/Path&gt;.is_dir() DirEntry Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type information. from os import scandir &lt;iter&gt; = scandir(path='.') # Returns DirEntry objects located at path. &lt;str&gt; = &lt;DirEntry&gt;.path # Returns path as a string. &lt;str&gt; = &lt;DirEntry&gt;.name # Returns final component as a string. &lt;file&gt; = open(&lt;DirEntry&gt;) # Opens the file and returns file object. Path Object from pathlib import Path &lt;Path&gt; = Path(&lt;path&gt; [, ...]) # Accepts strings, Paths and DirEntry objects. &lt;Path&gt; = &lt;path&gt; / &lt;path&gt; [/ ...] # One of the paths must be a Path object. &lt;Path&gt; = Path() # Returns relative cwd. Also Path('.'). &lt;Path&gt; = Path.cwd() # Returns absolute cwd. Also Path().resolve(). &lt;Path&gt; = &lt;Path&gt;.resolve() # Returns absolute Path without symlinks. &lt;Path&gt; = &lt;Path&gt;.parent # Returns Path without final component. &lt;str&gt; = &lt;Path&gt;.name # Returns final component as a string. &lt;str&gt; = &lt;Path&gt;.stem # Returns final component without extension. &lt;str&gt; = &lt;Path&gt;.suffix # Returns final component's extension. &lt;tup.&gt; = &lt;Path&gt;.parts # Returns all components as strings. &lt;iter&gt; = &lt;Path&gt;.iterdir() # Returns dir contents as Path objects. &lt;iter&gt; = &lt;Path&gt;.glob('&lt;pattern&gt;') # Returns Paths matching the wildcard pattern. &lt;str&gt; = str(&lt;Path&gt;) # Returns path as a string. &lt;file&gt; = open(&lt;Path&gt;) # Opens the file and returns file object. OS Commands Files and Directories Paths can be either strings, Paths or DirEntry objects. Functions report OS related errors by raising either OSError or one of its subclasses. import os, shutil os.chdir(&lt;path&gt;) # Changes the current working directory. os.mkdir(&lt;path&gt;, mode=0o777) # Creates a directory. Mode is in octal. shutil.copy(from, to) # Copies the file. 'to' can exist or be a dir. shutil.copytree(from, to) # Copies the directory. 'to' must not exist. os.rename(from, to) # Renames/moves the file or directory. os.replace(from, to) # Same, but overwrites 'to' if it exists. os.remove(&lt;path&gt;) # Deletes the file. os.rmdir(&lt;path&gt;) # Deletes the empty directory. shutil.rmtree(&lt;path&gt;) # Deletes the directory. Shell Commands import os &lt;str&gt; = os.popen('&lt;shell_command&gt;').read() Sends '1 + 1' to the basic calculator and captures its output: &gt;&gt;&gt; from subprocess import run &gt;&gt;&gt; run('bc', input='1 + 1\\n', capture_output=True, encoding='utf-8') CompletedProcess(args='bc', returncode=0, stdout='2\\n', stderr='') Sends test.in to the basic calculator running in standard mode and saves its output to test.out: &gt;&gt;&gt; from shlex import split &gt;&gt;&gt; os.popen('echo 1 + 1 &gt; test.in') &gt;&gt;&gt; run(split('bc -s'), stdin=open('test.in'), stdout=open('test.out', 'w')) CompletedProcess(args=['bc', '-s'], returncode=0) &gt;&gt;&gt; open('test.out').read() '2\\n' JSON Text file format for storing collections of strings and numbers. import json &lt;str&gt; = json.dumps(&lt;object&gt;, ensure_ascii=True, indent=None) &lt;object&gt; = json.loads(&lt;str&gt;) Read Object from JSON File def read_json_file(filename): with open(filename, encoding='utf-8') as file: return json.load(file) Write Object to JSON File def write_to_json_file(filename, an_object): with open(filename, 'w', encoding='utf-8') as file: json.dump(an_object, file, ensure_ascii=False, indent=2) Pickle Binary file format for storing objects. import pickle &lt;bytes&gt; = pickle.dumps(&lt;object&gt;) &lt;object&gt; = pickle.loads(&lt;bytes&gt;) Read Object from File def read_pickle_file(filename): with open(filename, 'rb') as file: return pickle.load(file) Write Object to File def write_to_pickle_file(filename, an_object): with open(filename, 'wb') as file: pickle.dump(an_object, file) CSV Text file format for storing spreadsheets. import csv Read &lt;reader&gt; = csv.reader(&lt;file&gt;) # Also: `dialect='excel', delimiter=','`. &lt;list&gt; = next(&lt;reader&gt;) # Returns next row as a list of strings. &lt;list&gt; = list(&lt;reader&gt;) # Returns list of remaining rows. File must be opened with 'newline=&quot;&quot;' argument, or newlines embedded inside quoted fields will not be interpreted correctly! Write &lt;writer&gt; = csv.writer(&lt;file&gt;) # Also: `dialect='excel', delimiter=','`. &lt;writer&gt;.writerow(&lt;collection&gt;) # Encodes objects using `str(&lt;el&gt;)`. &lt;writer&gt;.writerows(&lt;coll_of_coll&gt;) # Appends multiple rows. File must be opened with 'newline=&quot;&quot;' argument, or '\\r' will be added in front of every '\\n' on platforms that use '\\r\\n' line endings! Parameters 'dialect' - Master parameter that sets the default values. 'delimiter' - A one-character string used to separate fields. 'quotechar' - Character for quoting fields that contain special characters. 'doublequote' - Whether quotechars inside fields get doubled or escaped. 'skipinitialspace' - Whether whitespace after delimiter gets stripped. 'lineterminator' - Specifies how writer terminates rows. 'quoting' - Controls the amount of quoting: 0 - as necessary, 1 - all. 'escapechar' - Character for escaping 'quotechar' if 'doublequote' is False. Dialects +------------------+--------------+--------------+--------------+ | | excel | excel-tab | unix | +------------------+--------------+--------------+--------------+ | delimiter | ',' | '\\t' | ',' | | quotechar | '&quot;' | '&quot;' | '&quot;' | | doublequote | True | True | True | | skipinitialspace | False | False | False | | lineterminator | '\\r\\n' | '\\r\\n' | '\\n' | | quoting | 0 | 0 | 1 | | escapechar | None | None | None | +------------------+--------------+--------------+--------------+ Read Rows from CSV File def read_csv_file(filename): with open(filename, encoding='utf-8', newline='') as file: return list(csv.reader(file)) Write Rows to CSV File def write_to_csv_file(filename, rows): with open(filename, 'w', encoding='utf-8', newline='') as file: writer = csv.writer(file) writer.writerows(rows) SQLite Server-less database engine that stores each database into a separate file. Connect Opens a connection to the database file. Creates a new file if path doesn't exist. import sqlite3 &lt;con&gt; = sqlite3.connect('&lt;path&gt;') # Also ':memory:'. &lt;con&gt;.close() Read Returned values can be of type str, int, float, bytes or None. &lt;cursor&gt; = &lt;con&gt;.execute('&lt;query&gt;') # Can raise a subclass of sqlite3.Error. &lt;tuple&gt; = &lt;cursor&gt;.fetchone() # Returns next row. Also next(&lt;cursor&gt;). &lt;list&gt; = &lt;cursor&gt;.fetchall() # Returns remaining rows. Also list(&lt;cursor&gt;). Write &lt;con&gt;.execute('&lt;query&gt;') &lt;con&gt;.commit() Or: with &lt;con&gt;: &lt;con&gt;.execute('&lt;query&gt;') Placeholders Passed values can be of type str, int, float, bytes, None, bool, datetime.date or datetime.datetme. Bools will be stored and returned as ints and dates as ISO formatted strings. &lt;con&gt;.execute('&lt;query&gt;', &lt;list/tuple&gt;) # Replaces '?'s in query with values. &lt;con&gt;.execute('&lt;query&gt;', &lt;dict/namedtuple&gt;) # Replaces ':&lt;key&gt;'s with values. &lt;con&gt;.executemany('&lt;query&gt;', &lt;coll_of_above&gt;) # Runs execute() many times. Example In this example values are not actually saved because 'con.commit()' is omitted! &gt;&gt;&gt; con = sqlite3.connect('test.db') &gt;&gt;&gt; con.execute('create table person (person_id integer primary key, name, height)') &gt;&gt;&gt; con.execute('insert into person values (null, ?, ?)', ('Jean-Luc', 187)).lastrowid 1 &gt;&gt;&gt; con.execute('select * from person').fetchall() [(1, 'Jean-Luc', 187)] MySQL Has a very similar interface, with differences listed below. # $ pip3 install mysql-connector from mysql import connector &lt;con&gt; = connector.connect(host=&lt;str&gt;, …) # `user=&lt;str&gt;, password=&lt;str&gt;, database=&lt;str&gt;`. &lt;cursor&gt; = &lt;con&gt;.cursor() # Only cursor has execute method. &lt;cursor&gt;.execute('&lt;query&gt;') # Can raise a subclass of connector.Error. &lt;cursor&gt;.execute('&lt;query&gt;', &lt;list/tuple&gt;) # Replaces '%s's in query with values. &lt;cursor&gt;.execute('&lt;query&gt;', &lt;dict/namedtuple&gt;) # Replaces '%(&lt;key&gt;)s's with values. Bytes Bytes object is an immutable sequence of single bytes. Mutable version is called bytearray. &lt;bytes&gt; = b'&lt;str&gt;' # Only accepts ASCII characters and \\x00 - \\xff. &lt;int&gt; = &lt;bytes&gt;[&lt;index&gt;] # Returns int in range from 0 to 255. &lt;bytes&gt; = &lt;bytes&gt;[&lt;slice&gt;] # Returns bytes even if it has only one element. &lt;bytes&gt; = &lt;bytes&gt;.join(&lt;coll_of_bytes&gt;) # Joins elements using bytes object as separator. Encode &lt;bytes&gt; = bytes(&lt;coll_of_ints&gt;) # Ints must be in range from 0 to 255. &lt;bytes&gt; = bytes(&lt;str&gt;, 'utf-8') # Or: &lt;str&gt;.encode('utf-8') &lt;bytes&gt; = &lt;int&gt;.to_bytes(n_bytes, …) # `byteorder='big/little', signed=False`. &lt;bytes&gt; = bytes.fromhex('&lt;hex&gt;') # Hex numbers can be separated by spaces. Decode &lt;list&gt; = list(&lt;bytes&gt;) # Returns ints in range from 0 to 255. &lt;str&gt; = str(&lt;bytes&gt;, 'utf-8') # Or: &lt;bytes&gt;.decode('utf-8') &lt;int&gt; = int.from_bytes(&lt;bytes&gt;, …) # `byteorder='big/little', signed=False`. '&lt;hex&gt;' = &lt;bytes&gt;.hex() # Returns a string of hexadecimal numbers. Read Bytes from File def read_bytes(filename): with open(filename, 'rb') as file: return file.read() Write Bytes to File def write_bytes(filename, bytes_obj): with open(filename, 'wb') as file: file.write(bytes_obj) Struct Module that performs conversions between a sequence of numbers and a bytes object. Machine’s native type sizes and byte order are used by default. from struct import pack, unpack, iter_unpack &lt;bytes&gt; = pack('&lt;format&gt;', &lt;num_1&gt; [, &lt;num_2&gt;, ...]) &lt;tuple&gt; = unpack('&lt;format&gt;', &lt;bytes&gt;) &lt;tuples&gt; = iter_unpack('&lt;format&gt;', &lt;bytes&gt;) Example &gt;&gt;&gt; pack('&gt;hhl', 1, 2, 3) b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03' &gt;&gt;&gt; unpack('&gt;hhl', b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03') (1, 2, 3) Format For standard type sizes start format string with: '=' - native byte order '&lt;' - little-endian '&gt;' - big-endian (also '!') Integer types. Use a capital letter for unsigned type. Standard sizes are in brackets: 'x' - pad byte 'b' - char (1) 'h' - short (2) 'i' - int (4) 'l' - long (4) 'q' - long long (8) Floating point types: 'f' - float (4) 'd' - double (8) Array List that can only hold numbers of a predefined type. Available types and their sizes in bytes are listed above. from array import array &lt;array&gt; = array('&lt;typecode&gt;', &lt;collection&gt;) # Array from collection of numbers. &lt;array&gt; = array('&lt;typecode&gt;', &lt;bytes&gt;) # Array from bytes object. &lt;array&gt; = array('&lt;typecode&gt;', &lt;array&gt;) # Treats array as a sequence of numbers. &lt;bytes&gt; = bytes(&lt;array&gt;) # Or: &lt;array&gt;.tobytes() Memory View A sequence object that points to the memory of another object. Each element can reference a single or multiple consecutive bytes, depending on format. Order and number of elements can be changed with slicing. &lt;mview&gt; = memoryview(&lt;bytes/bytearray/array&gt;) # Immutable if bytes, else mutable. &lt;real&gt; = &lt;mview&gt;[&lt;index&gt;] # Returns an int or a float. &lt;mview&gt; = &lt;mview&gt;[&lt;slice&gt;] # Mview with rearranged elements. &lt;mview&gt; = &lt;mview&gt;.cast('&lt;typecode&gt;') # Casts memoryview to the new format. &lt;mview&gt;.release() # Releases the object's memory buffer. Decode &lt;bin_file&gt;.write(&lt;mview&gt;) # Writes mview to the binary file. &lt;bytes&gt; = bytes(&lt;mview&gt;) # Creates a new bytes object. &lt;bytes&gt; = &lt;bytes&gt;.join(&lt;coll_of_mviews&gt;) # Joins mviews using bytes object as sep. &lt;array&gt; = array('&lt;typecode&gt;', &lt;mview&gt;) # Treats mview as a sequence of numbers. &lt;list&gt; = list(&lt;mview&gt;) # Returns list of ints or floats. &lt;str&gt; = str(&lt;mview&gt;, 'utf-8') # Treats mview as a bytes object. &lt;int&gt; = int.from_bytes(&lt;mview&gt;, …) # `byteorder='big/little', signed=False`. '&lt;hex&gt;' = &lt;mview&gt;.hex() # Treats mview as a bytes object. Deque A thread-safe list with efficient appends and pops from either side. Pronounced &quot;deck&quot;. from collections import deque &lt;deque&gt; = deque(&lt;collection&gt;, maxlen=None) &lt;deque&gt;.appendleft(&lt;el&gt;) # Opposite element is dropped if full. &lt;deque&gt;.extendleft(&lt;collection&gt;) # Collection gets reversed. &lt;el&gt; = &lt;deque&gt;.popleft() # Raises IndexError if empty. &lt;deque&gt;.rotate(n=1) # Rotates elements to the right. Threading CPython interpreter can only run a single thread at a time. That is why using multiple threads won't result in a faster execution, unless at least one of the threads contains an I/O operation. from threading import Thread, RLock, Semaphore, Event, Barrier Thread &lt;Thread&gt; = Thread(target=&lt;function&gt;) # Use `args=&lt;collection&gt;` to set arguments. &lt;Thread&gt;.start() # Starts the thread. &lt;bool&gt; = &lt;Thread&gt;.is_alive() # Checks if thread has finished executing. &lt;Thread&gt;.join() # Waits for thread to finish. Use 'kwargs=&lt;dict&gt;' to pass keyword arguments to the function. Use 'daemon=True', or the program will not be able to exit while the thread is alive. Lock &lt;lock&gt; = RLock() &lt;lock&gt;.acquire() # Waits for lock to be available. &lt;lock&gt;.release() # Makes the lock available again. Or: lock = RLock() with lock: ... Semaphore, Event, Barrier &lt;Semaphore&gt; = Semaphore(value=1) # Lock that can be acquired 'value' times. &lt;Event&gt; = Event() # Method wait() blocks until set() is called. &lt;Barrier&gt; = Barrier(n_times) # Method wait() blocks until it's called 'n_times'. Thread Pool Executor from concurrent.futures import ThreadPoolExecutor with ThreadPoolExecutor(max_workers=None) as executor: # Does not exit until done. &lt;iter&gt; = executor.map(lambda x: x + 1, range(3)) # (1, 2, 3) &lt;iter&gt; = executor.map(lambda x, y: x + y, 'abc', '123') # ('a1', 'b2', 'c3') &lt;Future&gt; = executor.submit(&lt;function&gt; [, &lt;arg_1&gt;, ...]) # Also visible outside block. Future: &lt;bool&gt; = &lt;Future&gt;.done() # Checks if thread has finished executing. &lt;obj&gt; = &lt;Future&gt;.result() # Waits for thread to finish and returns result. Queue A thread-safe FIFO queue. For LIFO queue use LifoQueue. from queue import Queue &lt;Queue&gt; = Queue(maxsize=0) &lt;Queue&gt;.put(&lt;el&gt;) # Blocks until queue stops being full. &lt;Queue&gt;.put_nowait(&lt;el&gt;) # Raises queue.Full exception if full. &lt;el&gt; = &lt;Queue&gt;.get() # Blocks until queue stops being empty. &lt;el&gt; = &lt;Queue&gt;.get_nowait() # Raises queue.Empty exception if empty. Operator Module of functions that provide the functionality of operators. from operator import add, sub, mul, truediv, floordiv, mod, pow, neg, abs from operator import eq, ne, lt, le, gt, ge from operator import and_, or_, not_ from operator import itemgetter, attrgetter, methodcaller import operator as op elementwise_sum = map(op.add, list_a, list_b) sorted_by_second = sorted(&lt;collection&gt;, key=op.itemgetter(1)) sorted_by_both = sorted(&lt;collection&gt;, key=op.itemgetter(1, 0)) product_of_elems = functools.reduce(op.mul, &lt;collection&gt;) LogicOp = enum.Enum('LogicOp', {'AND': op.and_, 'OR' : op.or_}) last_el = op.methodcaller('pop')(&lt;list&gt;) Introspection Inspecting code at runtime. Variables &lt;list&gt; = dir() # Names of local variables (incl. functions). &lt;dict&gt; = vars() # Dict of local variables. Also locals(). &lt;dict&gt; = globals() # Dict of global variables. Attributes &lt;list&gt; = dir(&lt;object&gt;) # Names of object's attributes (incl. methods). &lt;dict&gt; = vars(&lt;object&gt;) # Dict of object's fields. Also &lt;obj&gt;.__dict__. &lt;bool&gt; = hasattr(&lt;object&gt;, '&lt;attr_name&gt;') # Checks if getattr() raises an error. value = getattr(&lt;object&gt;, '&lt;attr_name&gt;') # Raises AttributeError if attribute is missing. setattr(&lt;object&gt;, '&lt;attr_name&gt;', value) # Only works on objects with __dict__ attribute. delattr(&lt;object&gt;, '&lt;attr_name&gt;') # Equivalent to `del &lt;object&gt;.&lt;attr_name&gt;`. Parameters from inspect import signature &lt;sig&gt; = signature(&lt;function&gt;) no_of_params = len(&lt;sig&gt;.parameters) param_names = list(&lt;sig&gt;.parameters.keys()) param_kinds = [a.kind for a in &lt;sig&gt;.parameters.values()] Metaprograming Code that generates code. Type Type is the root class. If only passed an object it returns its type (class). Otherwise it creates a new class. &lt;class&gt; = type('&lt;class_name&gt;', &lt;parents_tuple&gt;, &lt;attributes_dict&gt;) &gt;&gt;&gt; Z = type('Z', (), {'a': 'abcde', 'b': 12345}) &gt;&gt;&gt; z = Z() Meta Class A class that creates classes. def my_meta_class(name, parents, attrs): attrs['a'] = 'abcde' return type(name, parents, attrs) Or: class MyMetaClass(type): def __new__(cls, name, parents, attrs): attrs['a'] = 'abcde' return type.__new__(cls, name, parents, attrs) New() is a class method that gets called before init(). If it returns an instance of its class, then that instance gets passed to init() as a 'self' argument. It receives the same arguments as init(), except for the first one that specifies the desired type of the returned instance (MyMetaClass in our case). Like in our case, new() can also be called directly, usually from a new() method of a child class (def __new__(cls): return super().__new__(cls)). The only difference between the examples above is that my_meta_class() returns a class of type type, while MyMetaClass() returns a class of type MyMetaClass. Metaclass Attribute Right before a class is created it checks if it has the 'metaclass' attribute defined. If not, it recursively checks if any of his parents has it defined and eventually comes to type(). class MyClass(metaclass=MyMetaClass): b = 12345 &gt;&gt;&gt; MyClass.a, MyClass.b ('abcde', 12345) Type Diagram type(MyClass) == MyMetaClass # MyClass is an instance of MyMetaClass. type(MyMetaClass) == type # MyMetaClass is an instance of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass --&gt; MyMetaClass | | | v | | object -----&gt; type &lt;+ | | | ^ +--+ | | str ----------+ | +-------------+-------------+ Inheritance Diagram MyClass.__base__ == object # MyClass is a subclass of object. MyMetaClass.__base__ == type # MyMetaClass is a subclass of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass | MyMetaClass | | v | v | | object &lt;----- type | | ^ | | | str | | +-------------+-------------+ Eval &gt;&gt;&gt; from ast import literal_eval &gt;&gt;&gt; literal_eval('1 + 2') 3 &gt;&gt;&gt; literal_eval('[1, 2, 3]') [1, 2, 3] &gt;&gt;&gt; literal_eval('abs(1)') ValueError: malformed node or string Coroutines Coroutines have a lot in common with threads, but unlike threads, they only give up control when they call another coroutine and they don’t use as much memory. Coroutine definition starts with 'async' and its call with 'await'. 'asyncio.run(&lt;coroutine&gt;)' is the main entry point for asynchronous programs. Functions wait(), gather() and as_completed() can be used when multiple coroutines need to be started at the same time. Asyncio module also provides its own Queue, Event, Lock and Semaphore classes. Runs a terminal game where you control an asterisk that must avoid numbers: import asyncio, collections, curses, enum, random P = collections.namedtuple('P', 'x y') # Position D = enum.Enum('D', 'n e s w') # Direction def main(screen): curses.curs_set(0) # Makes cursor invisible. screen.nodelay(True) # Makes getch() non-blocking. asyncio.run(main_coroutine(screen)) # Starts running asyncio code. async def main_coroutine(screen): state = {'*': P(0, 0), **{id_: P(30, 10) for id_ in range(10)}} moves = asyncio.Queue() coros = (*(random_controller(id_, moves) for id_ in range(10)), human_controller(screen, moves), model(moves, state, *screen.getmaxyx()), view(state, screen)) await asyncio.wait(coros, return_when=asyncio.FIRST_COMPLETED) async def random_controller(id_, moves): while True: moves.put_nowait((id_, random.choice(list(D)))) await asyncio.sleep(random.random() / 2) async def human_controller(screen, moves): while True: ch = screen.getch() key_mappings = {259: D.n, 261: D.e, 258: D.s, 260: D.w} if ch in key_mappings: moves.put_nowait(('*', key_mappings[ch])) await asyncio.sleep(0.01) async def model(moves, state, height, width): while state['*'] not in {p for id_, p in state.items() if id_ != '*'}: id_, d = await moves.get() p = state[id_] deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)} new_p = P(*[sum(a) for a in zip(p, deltas[d])]) if 0 &lt;= new_p.x &lt; width-1 and 0 &lt;= new_p.y &lt; height: state[id_] = new_p async def view(state, screen): while True: screen.clear() for id_, p in state.items(): screen.addstr(p.y, p.x, str(id_)) await asyncio.sleep(0.01) curses.wrapper(main) Libraries Progress Bar # $ pip3 install tqdm from tqdm import tqdm from time import sleep for el in tqdm([1, 2, 3]): sleep(0.2) Plot # $ pip3 install matplotlib from matplotlib import pyplot pyplot.plot(&lt;y_data&gt; [, label=&lt;str&gt;]) pyplot.plot(&lt;x_data&gt;, &lt;y_data&gt;) pyplot.legend() # Adds a legend. pyplot.savefig('&lt;path&gt;') # Saves the figure. pyplot.show() # Displays the figure. pyplot.clf() # Clears the figure. Table Prints a CSV file as an ASCII table: # $ pip3 install tabulate import csv, tabulate with open('test.csv', encoding='utf-8', newline='') as file: rows = csv.reader(file) header = [a.title() for a in next(rows)] table = tabulate.tabulate(rows, header) print(table) Curses Clears the terminal, prints a message and waits for the ESC key press: from curses import wrapper, curs_set, ascii from curses import KEY_UP, KEY_RIGHT, KEY_DOWN, KEY_LEFT def main(): wrapper(draw) def draw(screen): curs_set(0) # Makes cursor invisible. screen.nodelay(True) # Makes getch() non-blocking. screen.clear() screen.addstr(0, 0, 'Press ESC to quit.') # Coordinates are y, x. while screen.getch() != ascii.ESC: pass def get_border(screen): from collections import namedtuple P = namedtuple('P', 'x y') height, width = screen.getmaxyx() return P(width-1, height-1) if __name__ == '__main__': main() Logging # $ pip3 install loguru from loguru import logger logger.add('debug_{time}.log', colorize=True) # Connects a log file. logger.add('error_{time}.log', level='ERROR') # Another file for errors or higher. logger.&lt;level&gt;('A logging message.') Levels: 'debug', 'info', 'success', 'warning', 'error', 'critical'. Exceptions Exception description, stack trace and values of variables are appended automatically. try: ... except &lt;exception&gt;: logger.exception('An error happened.') Rotation Argument that sets a condition when a new log file is created. rotation=&lt;int&gt;|&lt;datetime.timedelta&gt;|&lt;datetime.time&gt;|&lt;str&gt; '&lt;int&gt;' - Max file size in bytes. '&lt;timedelta&gt;' - Max age of a file. '&lt;time&gt;' - Time of day. '&lt;str&gt;' - Any of above as a string: '100 MB', '1 month', 'monday at 12:00', ... Retention Sets a condition which old log files get deleted. retention=&lt;int&gt;|&lt;datetime.timedelta&gt;|&lt;str&gt; '&lt;int&gt;' - Max number of files. '&lt;timedelta&gt;' - Max age of a file. '&lt;str&gt;' - Max age as a string: '1 week, 3 days', '2 months', ... Scraping Scrapes Python's URL, version number and logo from Wikipedia page: # $ pip3 install requests beautifulsoup4 import requests, sys from bs4 import BeautifulSoup URL = 'https://en.wikipedia.org/wiki/Python_(programming_language)' try: html = requests.get(URL).text doc = BeautifulSoup(html, 'html.parser') table = doc.find('table', class_='infobox vevent') rows = table.find_all('tr') link = rows[11].find('a')['href'] ver = rows[6].find('div').text.split()[0] url_i = rows[0].find('img')['src'] image = requests.get(f'https:{url_i}').content with open('test.png', 'wb') as file: file.write(image) print(link, ver) except requests.exceptions.ConnectionError: print(&quot;You've got problems with connection.&quot;, file=sys.stderr) Web # $ pip3 install bottle from bottle import run, route, static_file, template, post, request, response import json Run run(host='localhost', port=8080) # Runs locally. run(host='0.0.0.0', port=80) # Runs globally. Static Request @route('/img/&lt;image&gt;') def send_image(image): return static_file(image, 'img_dir/', mimetype='image/png') Dynamic Request @route('/&lt;sport&gt;') def send_page(sport): return template('&lt;h1&gt;{{title}}&lt;/h1&gt;', title=sport) REST Request @post('/odds/&lt;sport&gt;') def odds_handler(sport): team = request.forms.get('team') home_odds, away_odds = 2.44, 3.29 response.headers['Content-Type'] = 'application/json' response.headers['Cache-Control'] = 'no-cache' return json.dumps([team, home_odds, away_odds]) Test: # $ pip3 install requests &gt;&gt;&gt; import requests &gt;&gt;&gt; url = 'http://localhost:8080/odds/football' &gt;&gt;&gt; data = {'team': 'arsenal f.c.'} &gt;&gt;&gt; response = requests.post(url, data=data) &gt;&gt;&gt; response.json() ['arsenal f.c.', 2.44, 3.29] Profiling Stopwatch from time import time start_time = time() # Seconds since the Epoch. ... duration = time() - start_time High performance: from time import perf_counter start_time = perf_counter() # Seconds since restart. ... duration = perf_counter() - start_time Timing a Snippet &gt;&gt;&gt; from timeit import timeit &gt;&gt;&gt; timeit('&quot;-&quot;.join(str(a) for a in range(100))', ... number=10000, globals=globals(), setup='pass') 0.34986 Profiling by Line # $ pip3 install line_profiler memory_profiler @profile def main(): a = [*range(10000)] b = {*range(10000)} main() $ kernprof -lv test.py Line # Hits Time Per Hit % Time Line Contents ======================================================= 1 @profile 2 def main(): 3 1 1128.0 1128.0 27.4 a = [*range(10000)] 4 1 2994.0 2994.0 72.6 b = {*range(10000)} $ python3 -m memory_profiler test.py Line # Mem usage Increment Line Contents ======================================================= 1 35.387 MiB 35.387 MiB @profile 2 def main(): 3 35.734 MiB 0.348 MiB a = [*range(10000)] 4 36.160 MiB 0.426 MiB b = {*range(10000)} Call Graph Generates a PNG image of a call graph with highlighted bottlenecks: # $ pip3 install pycallgraph from pycallgraph import output, PyCallGraph from datetime import datetime time_str = datetime.now().strftime('%Y%m%d%H%M%S') filename = f'profile-{time_str}.png' drawer = output.GraphvizOutput(output_file=filename) with PyCallGraph(drawer): &lt;code_to_be_profiled&gt; NumPy Array manipulation mini-language. It can run up to one hundred times faster than the equivalent Python code. # $ pip3 install numpy import numpy as np &lt;array&gt; = np.array(&lt;list&gt;) &lt;array&gt; = np.arange(from_inclusive, to_exclusive, ±step_size) &lt;array&gt; = np.ones(&lt;shape&gt;) &lt;array&gt; = np.random.randint(from_inclusive, to_exclusive, &lt;shape&gt;) &lt;array&gt;.shape = &lt;shape&gt; &lt;view&gt; = &lt;array&gt;.reshape(&lt;shape&gt;) &lt;view&gt; = np.broadcast_to(&lt;array&gt;, &lt;shape&gt;) &lt;array&gt; = &lt;array&gt;.sum(axis) indexes = &lt;array&gt;.argmin(axis) Shape is a tuple of dimension sizes. Axis is the index of a dimension that gets collapsed. The leftmost dimension has index 0. Indexing &lt;el&gt; = &lt;2d_array&gt;[0, 0] # First element. &lt;1d_view&gt; = &lt;2d_array&gt;[0] # First row. &lt;1d_view&gt; = &lt;2d_array&gt;[:, 0] # First column. Also [..., 0]. &lt;3d_view&gt; = &lt;2d_array&gt;[None, :, :] # Expanded by dimension of size 1. &lt;1d_array&gt; = &lt;2d_array&gt;[&lt;1d_row_indexes&gt;, &lt;1d_column_indexes&gt;] &lt;2d_array&gt; = &lt;2d_array&gt;[&lt;2d_row_indexes&gt;, &lt;2d_column_indexes&gt;] &lt;2d_bools&gt; = &lt;2d_array&gt; &gt; 0 &lt;1d_array&gt; = &lt;2d_array&gt;[&lt;2d_bools&gt;] If row and column indexes differ in shape, they are combined with broadcasting. Broadcasting Broadcasting is a set of rules by which NumPy functions operate on arrays of different sizes and/or dimensions. left = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [ 0.1 , 0.6 , 0.8 ] # Shape: (3) 1. If array shapes differ in length, left-pad the shorter shape with ones: left = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [[0.1 , 0.6 , 0.8]] # Shape: (1, 3) &lt;- ! 2. If any dimensions differ in size, expand the ones that have size 1 by duplicating their elements: left = [[0.1, 0.1, 0.1], [0.6, 0.6, 0.6], [0.8, 0.8, 0.8]] # Shape: (3, 3) &lt;- ! right = [[0.1, 0.6, 0.8], [0.1, 0.6, 0.8], [0.1, 0.6, 0.8]] # Shape: (3, 3) &lt;- ! 3. If neither non-matching dimension has size 1, raise an error. Example For each point returns index of its nearest point ([0.1, 0.6, 0.8] =&gt; [1, 2, 1]): &gt;&gt;&gt; points = np.array([0.1, 0.6, 0.8]) [ 0.1, 0.6, 0.8] &gt;&gt;&gt; wrapped_points = points.reshape(3, 1) [[ 0.1], [ 0.6], [ 0.8]] &gt;&gt;&gt; distances = wrapped_points - points [[ 0. , -0.5, -0.7], [ 0.5, 0. , -0.2], [ 0.7, 0.2, 0. ]] &gt;&gt;&gt; distances = np.abs(distances) [[ 0. , 0.5, 0.7], [ 0.5, 0. , 0.2], [ 0.7, 0.2, 0. ]] &gt;&gt;&gt; i = np.arange(3) [0, 1, 2] &gt;&gt;&gt; distances[i, i] = np.inf [[ inf, 0.5, 0.7], [ 0.5, inf, 0.2], [ 0.7, 0.2, inf]] &gt;&gt;&gt; distances.argmin(1) [1, 2, 1] Image # $ pip3 install pillow from PIL import Image &lt;Image&gt; = Image.new('&lt;mode&gt;', (width, height)) &lt;Image&gt; = Image.open('&lt;path&gt;') &lt;Image&gt; = &lt;Image&gt;.convert('&lt;mode&gt;') &lt;Image&gt;.save('&lt;path&gt;') &lt;Image&gt;.show() &lt;tuple/int&gt; = &lt;Image&gt;.getpixel((x, y)) # Returns a pixel. &lt;Image&gt;.putpixel((x, y), &lt;tuple/int&gt;) # Writes a pixel to the image. &lt;ImagingCore&gt; = &lt;Image&gt;.getdata() # Returns a sequence of pixels. &lt;Image&gt;.putdata(&lt;list/ImagingCore&gt;) # Writes a sequence of pixels. &lt;Image&gt;.paste(&lt;Image&gt;, (x, y)) # Writes an image to the image. &lt;2d_array&gt; = np.array(&lt;Image&gt;) # Creates NumPy array from greyscale image. &lt;3d_array&gt; = np.array(&lt;Image&gt;) # Creates NumPy array from color image. &lt;Image&gt; = Image.fromarray(&lt;array&gt;) # Creates image from NumPy array of floats. Modes '1' - 1-bit pixels, black and white, stored with one pixel per byte. 'L' - 8-bit pixels, greyscale. 'RGB' - 3x8-bit pixels, true color. 'RGBA' - 4x8-bit pixels, true color with transparency mask. 'HSV' - 3x8-bit pixels, Hue, Saturation, Value color space. Examples Creates a PNG image of a rainbow gradient: WIDTH, HEIGHT = 100, 100 size = WIDTH * HEIGHT hues = [255 * i/size for i in range(size)] img = Image.new('HSV', (WIDTH, HEIGHT)) img.putdata([(int(h), 255, 255) for h in hues]) img.convert('RGB').save('test.png') Adds noise to a PNG image: from random import randint add_noise = lambda value: max(0, min(255, value + randint(-20, 20))) img = Image.open('test.png').convert('HSV') img.putdata([(add_noise(h), s, v) for h, s, v in img.getdata()]) img.convert('RGB').save('test.png') Drawing from PIL import ImageDraw &lt;ImageDraw&gt; = ImageDraw.Draw(&lt;Image&gt;) &lt;ImageDraw&gt;.point((x, y), fill=None) &lt;ImageDraw&gt;.line((x1, y1, x2, y2 [, ...]), fill=None, width=0, joint=None) &lt;ImageDraw&gt;.arc((x1, y1, x2, y2), from_deg, to_deg, fill=None, width=0) &lt;ImageDraw&gt;.rectangle((x1, y1, x2, y2), fill=None, outline=None, width=0) &lt;ImageDraw&gt;.polygon((x1, y1, x2, y2 [, ...]), fill=None, outline=None) &lt;ImageDraw&gt;.ellipse((x1, y1, x2, y2), fill=None, outline=None, width=0) Use 'fill=&lt;color&gt;' to set the primary color. Use 'outline=&lt;color&gt;' to set the secondary color. Color can be specified as a tuple, int, '#rrggbb' string or a color name. Animation Creates a GIF of a bouncing ball: # $ pip3 install pillow imageio from PIL import Image, ImageDraw import imageio WIDTH, R = 126, 10 frames = [] for velocity in range(15): y = sum(range(velocity+1)) frame = Image.new('L', (WIDTH, WIDTH)) draw = ImageDraw.Draw(frame) draw.ellipse((WIDTH/2-R, y, WIDTH/2+R, y+R*2), fill='white') frames.append(frame) frames += reversed(frames[1:-1]) imageio.mimsave('test.gif', frames, duration=0.03) Audio import wave &lt;Wave_read&gt; = wave.open('&lt;path&gt;', 'rb') # Opens the WAV file. framerate = &lt;Wave_read&gt;.getframerate() # Number of frames per second. nchannels = &lt;Wave_read&gt;.getnchannels() # Number of samples per frame. sampwidth = &lt;Wave_read&gt;.getsampwidth() # Sample size in bytes. nframes = &lt;Wave_read&gt;.getnframes() # Number of frames. &lt;params&gt; = &lt;Wave_read&gt;.getparams() # Immutable collection of above. &lt;bytes&gt; = &lt;Wave_read&gt;.readframes(nframes) # Returns next 'nframes' frames. &lt;Wave_write&gt; = wave.open('&lt;path&gt;', 'wb') # Truncates existing file. &lt;Wave_write&gt;.setframerate(&lt;int&gt;) # 44100 for CD, 48000 for video. &lt;Wave_write&gt;.setnchannels(&lt;int&gt;) # 1 for mono, 2 for stereo. &lt;Wave_write&gt;.setsampwidth(&lt;int&gt;) # 2 for CD quality sound. &lt;Wave_write&gt;.setparams(&lt;params&gt;) # Sets all parameters. &lt;Wave_write&gt;.writeframes(&lt;bytes&gt;) # Appends frames to the file. Bytes object contains a sequence of frames, each consisting of one or more samples. In a stereo signal, the first sample of a frame belongs to the left channel. Each sample consists of one or more bytes that, when converted to an integer, indicate the displacement of a speaker membrane at a given moment. If sample width is one, then the integer should be encoded unsigned. For all other sizes, the integer should be encoded signed with little-endian byte order. Sample Values +-----------+-------------+------+-------------+ | sampwidth | min | zero | max | +-----------+-------------+------+-------------+ | 1 | 0 | 128 | 255 | | 2 | -32768 | 0 | 32767 | | 3 | -8388608 | 0 | 8388607 | | 4 | -2147483648 | 0 | 2147483647 | +-----------+-------------+------+-------------+ Read Float Samples from WAV File def read_wav_file(filename): def get_int(a_bytes): an_int = int.from_bytes(a_bytes, 'little', signed=width!=1) return an_int - 128 * (width == 1) with wave.open(filename, 'rb') as file: width = file.getsampwidth() frames = file.readframes(file.getnframes()) byte_samples = (frames[i: i + width] for i in range(0, len(frames), width)) return [get_int(b) / pow(2, width * 8 - 1) for b in byte_samples] Write Float Samples to WAV File def write_to_wav_file(filename, float_samples, nchannels=1, sampwidth=2, framerate=44100): def get_bytes(a_float): a_float = max(-1, min(1 - 2e-16, a_float)) a_float += sampwidth == 1 a_float *= pow(2, sampwidth * 8 - 1) return int(a_float).to_bytes(sampwidth, 'little', signed=sampwidth!=1) with wave.open(filename, 'wb') as file: file.setnchannels(nchannels) file.setsampwidth(sampwidth) file.setframerate(framerate) file.writeframes(b''.join(get_bytes(f) for f in float_samples)) Examples Saves a sine wave to a mono WAV file: from math import pi, sin samples_f = (sin(i * 2 * pi * 440 / 44100) for i in range(100000)) write_to_wav_file('test.wav', samples_f) Adds noise to a mono WAV file: from random import random add_noise = lambda value: value + (random() - 0.5) * 0.03 samples_f = (add_noise(f) for f in read_wav_file('test.wav')) write_to_wav_file('test.wav', samples_f) Plays a WAV file: # $ pip3 install simpleaudio from simpleaudio import play_buffer with wave.open('test.wav', 'rb') as file: p = file.getparams() frames = file.readframes(p.nframes) play_buffer(frames, p.nchannels, p.sampwidth, p.framerate) Text to Speech # $ pip3 install pyttsx3 import pyttsx3 engine = pyttsx3.init() engine.say('Sally sells seashells by the seashore.') engine.runAndWait() Synthesizer Plays Popcorn by Gershon Kingsley: # $ pip3 install simpleaudio import simpleaudio, math, struct from itertools import chain, repeat F = 44100 P1 = '71♪,69,,71♪,66,,62♪,66,,59♪,,,' P2 = '71♪,73,,74♪,73,,74,,71,,73♪,71,,73,,69,,71♪,69,,71,,67,,71♪,,,' get_pause = lambda seconds: repeat(0, int(seconds * F)) sin_f = lambda i, hz: math.sin(i * 2 * math.pi * hz / F) get_wave = lambda hz, seconds: (sin_f(i, hz) for i in range(int(seconds * F))) get_hz = lambda key: 8.176 * 2 ** (int(key) / 12) parse_note = lambda note: (get_hz(note[:2]), 0.25 if '♪' in note else 0.125) get_samples = lambda note: get_wave(*parse_note(note)) if note else get_pause(0.125) samples_f = chain.from_iterable(get_samples(n) for n in f'{P1}{P1}{P2}'.split(',')) samples_b = b''.join(struct.pack('&lt;h', int(f * 30000)) for f in samples_f) simpleaudio.play_buffer(samples_b, 1, 2, F) Pygame Basic Example # $ pip3 install pygame import pygame as pg pg.init() screen = pg.display.set_mode((500, 500)) rect = pg.Rect(240, 240, 20, 20) while all(event.type != pg.QUIT for event in pg.event.get()): deltas = {pg.K_UP: (0, -3), pg.K_RIGHT: (3, 0), pg.K_DOWN: (0, 3), pg.K_LEFT: (-3, 0)} for delta in (deltas.get(i) for i, on in enumerate(pg.key.get_pressed()) if on): rect = rect.move(delta) if delta else rect screen.fill((0, 0, 0)) pg.draw.rect(screen, (255, 255, 255), rect) pg.display.flip() Rectangle Object for storing rectangular coordinates. &lt;Rect&gt; = pg.Rect(x, y, width, height) # X and y are coordinates of topleft corner. &lt;int&gt; = &lt;Rect&gt;.x/y/centerx/centery/… # Top, right, bottom, left. &lt;tup.&gt; = &lt;Rect&gt;.topleft/center/… # Topright, bottomright, bottomleft. &lt;Rect&gt; = &lt;Rect&gt;.move((x, y)) # Use move_ip() to move in place. &lt;bool&gt; = &lt;Rect&gt;.collidepoint((x, y)) # Tests if a point is inside a rectangle. &lt;bool&gt; = &lt;Rect&gt;.colliderect(&lt;Rect&gt;) # Tests if two rectangles overlap. &lt;int&gt; = &lt;Rect&gt;.collidelist(&lt;list_of_Rect&gt;) # Returns index of first colliding Rect or -1. &lt;list&gt; = &lt;Rect&gt;.collidelistall(&lt;list_of_Rect&gt;) # Returns indexes of all colliding Rects. Surface Object for representing images. &lt;Surf&gt; = pg.display.set_mode((width, height)) # Returns the display surface. &lt;Surf&gt; = pg.Surface((width, height)) # Creates a new surface. &lt;Surf&gt; = pg.image.load('&lt;path&gt;') # Loads the image. &lt;Surf&gt; = &lt;Surf&gt;.subsurface(&lt;Rect&gt;) # Returns a subsurface. &lt;Surf&gt;.fill(color) # Fills the whole surface. &lt;Surf&gt;.set_at((x, y), color) # Updates pixel. &lt;Surf&gt;.blit(&lt;Surface&gt;, (x, y)) # Draws passed surface to the surface. &lt;Surf&gt; = pg.transform.flip(&lt;Surf&gt;, xbool, ybool) &lt;Surf&gt; = pg.transform.rotate(&lt;Surf&gt;, degrees) &lt;Surf&gt; = pg.transform.scale(&lt;Surf&gt;, (width, height)) pg.draw.line(&lt;Surf&gt;, color, (x1, y1), (x2, y2), width) pg.draw.arc(&lt;Surf&gt;, color, &lt;Rect&gt;, from_radians, to_radians) pg.draw.rect(&lt;Surf&gt;, color, &lt;Rect&gt;) pg.draw.polygon(&lt;Surf&gt;, color, points) pg.draw.ellipse(&lt;Surf&gt;, color, &lt;Rect&gt;) Font &lt;Font&gt; = pg.font.SysFont('&lt;name&gt;', size, bold=False, italic=False) &lt;Font&gt; = pg.font.Font('&lt;path&gt;', size) &lt;Surf&gt; = &lt;Font&gt;.render(text, antialias, color, background=None) Sound &lt;Sound&gt; = pg.mixer.Sound('&lt;path&gt;') # Loads the WAV file. &lt;Sound&gt;.play() # Starts playing the sound. Basic Mario Brothers Example import collections, dataclasses, enum, io, pygame, urllib.request, itertools as it from random import randint P = collections.namedtuple('P', 'x y') # Position D = enum.Enum('D', 'n e s w') # Direction SIZE, MAX_SPEED = 50, P(5, 10) # Screen size, Speed limit def main(): def get_screen(): pygame.init() return pygame.display.set_mode(2 * [SIZE*16]) def get_images(): url = 'https://gto76.github.io/python-cheatsheet/web/mario_bros.png' img = pygame.image.load(io.BytesIO(urllib.request.urlopen(url).read())) return [img.subsurface(get_rect(x, 0)) for x in range(img.get_width() // 16)] def get_mario(): Mario = dataclasses.make_dataclass('Mario', 'rect spd facing_left frame_cycle'.split()) return Mario(get_rect(1, 1), P(0, 0), False, it.cycle(range(3))) def get_tiles(): positions = [p for p in it.product(range(SIZE), repeat=2) if {*p} &amp; {0, SIZE-1}] + \\ [(randint(1, SIZE-2), randint(2, SIZE-2)) for _ in range(SIZE**2 // 10)] return [get_rect(*p) for p in positions] def get_rect(x, y): return pygame.Rect(x*16, y*16, 16, 16) run(get_screen(), get_images(), get_mario(), get_tiles()) def run(screen, images, mario, tiles): clock = pygame.time.Clock() while all(event.type != pygame.QUIT for event in pygame.event.get()): keys = {pygame.K_UP: D.n, pygame.K_RIGHT: D.e, pygame.K_DOWN: D.s, pygame.K_LEFT: D.w} pressed = {keys.get(i) for i, on in enumerate(pygame.key.get_pressed()) if on} update_speed(mario, tiles, pressed) update_position(mario, tiles) draw(screen, images, mario, tiles, pressed) clock.tick(28) def update_speed(mario, tiles, pressed): x, y = mario.spd x += 2 * ((D.e in pressed) - (D.w in pressed)) x -= x // abs(x) if x else 0 y += 1 if D.s not in get_boundaries(mario.rect, tiles) else (-10 if D.n in pressed else 0) mario.spd = P(*[max(-limit, min(limit, s)) for limit, s in zip(MAX_SPEED, P(x, y))]) def update_position(mario, tiles): new_p = mario.rect.topleft larger_speed = max(abs(s) for s in mario.spd) for _ in range(larger_speed): mario.spd = stop_on_collision(mario.spd, get_boundaries(mario.rect, tiles)) new_p = P(*[a + s/larger_speed for a, s in zip(new_p, mario.spd)]) mario.rect.topleft = new_p def get_boundaries(rect, tiles): deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)} return {d for d, delta in deltas.items() if rect.move(delta).collidelist(tiles) != -1} def stop_on_collision(spd, bounds): return P(x=0 if (D.w in bounds and spd.x &lt; 0) or (D.e in bounds and spd.x &gt; 0) else spd.x, y=0 if (D.n in bounds and spd.y &lt; 0) or (D.s in bounds and spd.y &gt; 0) else spd.y) def draw(screen, images, mario, tiles, pressed): def get_frame_index(): if D.s not in get_boundaries(mario.rect, tiles): return 4 return next(mario.frame_cycle) if {D.w, D.e} &amp; pressed else 6 screen.fill((85, 168, 255)) mario.facing_left = (D.w in pressed) if {D.w, D.e} &amp; pressed else mario.facing_left screen.blit(images[get_frame_index() + mario.facing_left * 9], mario.rect) for rect in tiles: screen.blit(images[18 if {*rect.topleft} &amp; {0, (SIZE-1)*16} else 19], rect) pygame.display.flip() if __name__ == '__main__': main() Basic Script Template #!/usr/bin/env python3 # # Usage: .py # from collections import namedtuple from dataclasses import make_dataclass from enum import Enum from sys import argv import re def main(): pass ### ## UTIL # def read_file(filename): with open(filename, encoding='utf-8') as file: return file.readlines() if __name__ == '__main__': main() ","link":"https://yueqingsheng.github.io/post/python-cheatsheet/"},{"title":"周报 5月第2期","content":"本周有很多互联网趋势的总结报告和 AI相关的内容。 报告 行业内最有权威的两个行业趋势报告，在同一周发布 技术雷达，nestjs 上榜了，感觉这属于nodejs 后端比较适合规模化的一个框架了，有点像前端框架，每个模块可以复用，组合。这一期还包括了一些远程工作的内容。 technology radar typescript 的喜爱度超越了 python, 个人感觉虽然ts语法进步了，但是nodejs的包管理，像一个 shit hole。虽然原作者已经做出了 Denojs（使用 URL加载包，本地缓存）, 但还在 1.0阶段。不太喜欢 nodejs的动不动几万个依赖，简直是噩梦的存在。 Rust 受欢迎度排名第一，因为速度可以媲美 C++，而且保证了内存安全。 中文总结 英文源链接 AI 一些可以在线使用的 AI,文章摘要生成，AI 画画之类的 无聊的人类 OPENAI 发布了1750亿参数的神经网络，应用效果惊人。 GPT3 只要训练集大，效果吓死人，话说这玩意除了OPENAI,谁能训练。。。 Python github star很多的一份python快速查阅手册 github源地址 复制了一份放到博客上，增加了侧栏目录 Github 这周写了个生成用户假数据的脚本。用了 Github上的几个项目 中文人名生成，蛮有意思的一个人名生成器 Chinese-Names-Corpus 汉字转拼音,可以选多种格式，包括声调 python-pinyin 文章 一个理想主义者的破灭 罗永浩：薛定谔的理想主义 视频 尽管我们的手中空无一物 僕らの手には何もないけど 本周词汇 单词 个人理解 英文解释 解耦（decoupling） 我的理解就是尽可能把共用的部分提出来，把一个大的项目，拆成一堆小项目，使小项目的复用性变高。 If two classes make calls to methods of each other then they are tightly coupled, as changing one would mean having to change the other. Decoupling is the process of making something that was tightly coupled less so, or not at all. ... &quot;Decoupling&quot; is just another name for &quot;little/low coupling&quot;. 敏捷式开发 （Agile software development) 一边测试一边开发，测试/用户驱动 Agile software development comprises various approaches to software development under which requirements and solutions evolve through the collaborative effort of self-organizing and cross-functional teams and their customer/end user. Why decoupling? Ultimately decoupling promotes scalability, as you can scale the pieces of your infrastructure that your capacity planning identifies to be bottlenecks. What's more you can make those pieces redundant, increasing high availability at the same time. ","link":"https://yueqingsheng.github.io/post/zhou-bao-5-yue-di-2-qi/"},{"title":"后端基础","content":"SQL 语句 一般常使用大写 INSERT 插入 INSERT INTO `post`(数据表名,使用反引号或者不使用反引号也可以) （`title`, `content`）(表格内字段名) VALUES ('文章1'，'我是一个内容')， （标题和内容，分隔用逗号） ('文章2'，'我是一个内容')； （结尾用分号） SELECT 选择 SELECT * FROM `post` LIMIT 1 OFFSET 1; (选择所有数据，limit条数， offset 偏移量) SELECT `id`, `title` FROM `post` LIMIT 1 OFFSET 1 WHERE `id` = 1;(选择字段， where 查找条件) SELECT `id`, `title` FROM `post` LIMIT 1 OFFSET 1 ORDER BY `id` DESC;(排序) UPDATE 更新 DELETE 删除 INDEX 索引 定义 有序性的目录 为什么使用？ 加快表单的查询速度 加快 where=某个值 和范围查询 原理 B+树 索引类型 联合索引，按照两个字段建立索引 MEMCACHED 主键和外键 主键： 用于表示数据的唯一标示，不能为null。 如：id 外键： 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 如：post 里的userId 哈希函数 key-hash function-&gt; hash code 简单hash 不考虑冲突 Put Get hash 是不可逆的 MD5 string=&gt;string(32位16进制字符串) 相同hash有可能由不同字符串生成 靠key,hash 对 可以猜到密码。盐（通过添加其他字符，生成不同的hash） ","link":"https://yueqingsheng.github.io/post/hou-duan-ji-chu/"},{"title":"关于refresh token","content":"refresh token 如何增加后端安全性呢？ 根据refresh token 的实现，它只在每次登陆的时候才会返回。从请求频率的上减少了暴露的可能性（减少了登录接口请求次数）。一般refresh token的有效期很长。 那跟它相比的是什么呢，是只使用token登陆，考虑两种情况 有效期较长或永久有效的token(非常不安全)，没有登出或长时间不登出的话，其他用户可以在这个期间进行操作 请求多次有效期相对较短的token，这样增加了登陆的次数。对用户非常不方便。 所以refresh token 既减少了登录的次数，又实现了自动刷新token, 减少了用户的操作。主要安全性增强的方面就是在减少登录上。 ","link":"https://yueqingsheng.github.io/post/guan-yu-refresh-token/"},{"title":"周报 5月第1期","content":"每周会总结一些最近用到的工具或者看到的文章。 工具 比谷歌翻译更好用的 AI翻译，翻译的很自然。 DeepL 提供了基本上网上所有的社交媒体和信息来源的 RSS RSShub AI 可溯源的I搜索引擎，可以知道一些词的主要来源和引用Magi 跨端同步文件夹，我用它把mac和windows的Gridea博客文件同步起来。坚果云 python 一个很方便的给现成代码添加命令行的库Fire 详细讲了列表生成式的用法。Python 成为专业人士笔记–comprehension生成式 后端 推荐两个课程虽然都是付费的，但是自己听过还可以 从 0 开始学习开发后端，内容很全，一如皓哥平时的风格，视频简练，每个不超过 5 分钟。可以作为 js 开发入门，或者后端查阅使用。小白兔的开发之路 需要一定的算法和后端基础，可以作为进阶学习，主要讲了如何优化后端，如访问量巨大或高并发的情况。至于价格见仁见智，我觉得有点小贵了。优点是讲的比较系统。系统设计 文章 蛮有意思的一篇文章，一直对这类的文笔比较感兴趣。残局 WannaCry解决者的故事 22岁阻止席卷网络的病毒，却因开发恶意软件被捕，这是传奇黑客马库斯的故事 视频 赛博朋克山海经，惊了。Cyberpunk Shanhaijing 每周英文 每周读几篇英文文章，或者听电台节目（podcast) ,或者写点英文技术文章，或者转译一篇。 本周文章： 不要学编程，学会自动化。主要讲了生活中很多重复无聊的事都可以自动化起来，写代码只是其中实现的一个选择。Don't Learn to Code — Learn to Automate 词汇表：列出英文解释的原因，是我觉得有的时候英文解释比中文更好理解单词原本的意思。 单词 英文解释 中文含义 heady having a powerful effect, making you feel slightly drunk or excited 令人兴奋，有点冲动的 surreal strange; not seeming real; like a dream 超现实的,不真实的 intimaditing making you feel frightened or nervous 令人紧张的，吓人的 overwhelming difficult to fight against 难以抵挡的；无法抗拒的 folly 愚蠢的 rebuttal a statement that says that something is not true 反驳 zeitgeist the general set of ideas, beliefs, feelings, etc. that is typical of a particular period in history 时代思潮 overarching most important, because of including or affecting all other areas 首要的；包罗万象的，支配一切的 nuance a very slight difference in appearance, meaning, sound, etc. （外表、意义、声音等的）细微差别 hung up having a hang-up (= feeling of worry about yourself) 焦虑的，烦恼的 per se by or of itself 自身，本身 savvy practical knowledge and ability 常识；实际能力 copy editor A copy editor is a person whose job it is to check and correct articles in newspapers or magazines before they are printed. 文字编辑 wince 退缩 laboriously in a way that needs a lot of time and effort 费力地；艰难地；辛苦地 拓展: ruby 是一门编程语言 文章中提及的热火队的广告链接 ","link":"https://yueqingsheng.github.io/post/zhou-bao-5-yue-di-1-qi/"},{"title":"系统设计 Week 1 4S分析 ","content":"4s 4s是指 Scenario(场景) Service(服务) Storgae(储存) Scale(升级) Scenario(场景) DAU(https://yueqingsheng.github.io/post-images/1590461765777.png) MAU(\b月活跃用户 ) 估计 MAU约等于2*DAU Enumerate(列举)列出所有功能 Sort 筛选核心功能 Timeline(用户发布的内容) News Feed(用户关注的内容/信息流) 3.分析 QPS(Queries per second) QPS = DAU*用户平均每天请求次数/每天多少秒（86400） PEAK(峰值) 约等于= QPS *3 快速增长 Fast Growing 将来的增长 读频率 写频率 &lt;=1 每个用户 QPS Single point failure(一个坏了，快速切换到另一台服务器) 普通web server 只能达到 10QPS SQL Databsase 1k QPS (join index很慢) NoSQL 10k ~ 1m Service(服务) Service oriented(微服务化，大系统拆分小服务) Replay 每个需求添加一个服务 Merge 归并相同的服务 Storage 存储 每个Service 选择存储结构 Database File System Cache Schema 细化表结构 primary key 一般使用id作为primary key,因为username和email有可能被修改，导致连串修改。 News Feed pull model: merge k sorted arrays 缺点： 现算，每次发送请求 push model: fanout: In message-oriented middleware solutions, fan-out is a messaging pattern used to model an information exchange that implies the delivery (or spreading) of a message to one or multiple destinations possibly in parallel, and not halting the process that executes the messaging to wait for any response to that message.(在面向消息的中间件解决方案中，fan-out是一种用于建模的消息交换体式格局，它意味着向一个或多个目的地可能并行地传递(或传播)一个消息，而不是让执行消息的进程停止等待对该消息的任何响应。) Denormalized 叫去标准化。通俗的解释是，通过在不同的 Table 中存储同一份数据的（也就是说至少一份是冗余数据）的形式，来加速数据的查询。因为当数据只存储在一个固定的 Table A 的时候，其他 Table B访问时如果需要同时取得关联的 Table A 的数据，则需要进行 join 操作之类的，会比较慢。一个例子就是在，统计有多少人点赞了一个帖子，可以通过 select count() from like_table where post_id= 的方式来获取，但是也可以在 post table 中新增一个 like_count，每次点赞就 +1。这里 like_count 就是一个 denormalized field，因为是可以通过 select count() 在 like table 中获得的。 fanout 过程异步执行 async 缺点 粉丝过多，创建的记录会变多 push 对1对特别多的 现象速度很慢，每次加一个新的内容，通知所有关注的人。 Scale Pull 改进： Cache N cache请求（N是关注的好友数） Trade off: Cache 1000条，或200条 Push 改进： 在现有基础上做尽可能小的改动 Push+ Pull 普通用户 push 明星用户 pull 在获取更新之前，主动merge明星的更新 定义明星问题 掉粉前，明星不push,掉粉后状态改变，不pull。数据丢失 =》永久状态，只要达到过就固定状态 Done is than perfect 课后习题分析以及改进 我的数据结构设计： Tweet_extend 扩展tweet加上创建时间。 tweet 储存每个用户的tweet list follow_relation 储存了用户的关注关系表 答案中关系用了map&lt;int, set&gt; 用户id到这个用户关注的人的id的映射，这样设计1对多关系的映射少了在代码中loop判断用户。提升了查询速度。 Push model: 把每个人建立一个newsfeed map&lt;int, newsfeed&gt;, 每当新建一个新twitter，给所有关注的 newsfeed里添加一个。如果Push的时候是按照时间顺序，获取newsfeed的时候就不用sort，拿头10个就行了。 ","link":"https://yueqingsheng.github.io/post/xi-tong-she-ji-4s-fen-xi/"},{"title":"RSS订阅（Feedly + RSShub）","content":" RSS 是用于分发Web 站点上的内容的摘要的一种简单的XML 格式。它能够用于共享各种各样的信息。 每天被各个网站上和app的推荐算法烦到了，被动接受了很多无用信息，RSS 最吸引人之处，就在于它能让你看到「开放互联网未经过滤的样子」，给你一个「自己决定看什么」的机会。 一直有个想法搭个RSS信息聚合的网站，找了一圈发现有很多现成的工具了。完全可以使用这些工具解决。（不用写代码了，yeah!） Feedly 网站链接 找了几个，发现feedly是页面展示最好的一个，而且还有手机端app。 网页 app 唯一的缺点，对图片的预览不是很好。 看图片推荐切换到cards view, 设置成直接打开网站。 RSS源 RSSHUB已经包含了大多数获取的来源，如果还没有的话，推荐RSSHUB Radar这个插件，可以自动获取当前网站是否有rss link。 结合这两个基本上，每天所有的信息源都可以获取到了，比如接入常看的youtube频道，网易云歌单, b站up主，画师，微博，电台，直播。 添加源方法 在Feedly里直接复制RSSHUB里的链接就行了。 欢迎订阅我的博客。RSS链接: https://yueqingsheng.github.io/atom.xml RSS里看视频 我感觉可以把RSS理解成爬虫爬下来然后整理的一种数据格式，所以基本上，网上能浏览的网页，都可以做成RSS来看。也可以把它利用成获取各种通知和推送的工具，比如看直播课，大学信息，追剧更新。 Done! 在想RSS能否扩展成一个网站浏览所有信息呢？（使用视频播放，音频播放，以及直播流） 拓展： 推荐阅读 你的新闻 App 被推荐算法「毁」了，但 RSS 真的能拯救你吗 随着RSS进化，某一天这个技术本身也会拿来做推荐算法的优化。所以重点不是在于技术本身，而是个人是否有寻求有价值信息的能力。 ","link":"https://yueqingsheng.github.io/post/rss-ding-yue-feedly-rsshub/"},{"title":"用sao从0写一个脚手架（cli, scafolding, sao）","content":"看了一些文章，发现saojs 包括了一个简单的generator流程。但是网上详细介绍的文章太少了，作为一个js小白，把流程记录下。 Run/Test 第一步是先把脚手架跑起来，这里使用了ava测试。参考 AVA 安装 ：npm install ava -g 开始测试：ava snapshot testing 第一次测试ava会生成main.js.snap和main.js.md，然后自动比对之后生成的snapshot是否跟储存的一致。参考 snapshot更新：ava -u Sao generators test parameters 测试能跑起来了下面看一下，sao testing的参数 answers 的格式为 { useRouter: true } Ejs docs Inquiryjs docs ps: 放弃使用sao了,不是因为这个包不好。有两个原因，一个是对python比较熟练，系统级操作比较用户友好，jupter直接支持bash命令。第二是因为我需要很多对文件的操作，不单单是替换，用js的话需要用的第三方包太多了，学习成本有点高。 参考 如何开发一个可爱的CLI（一） ava test ","link":"https://yueqingsheng.github.io/post/yong-sao-cong-0-xie-yi-ge-jiao-shou-jia-cli-scafolding-sao/"},{"title":"nestjs 后端代码自动生成（数据表，curd接口，文档）","content":"起因 最近给公司写接口的过程中，发现每有一种新的数据形式，出现就需要重新写一个数据表，并提供相关的数据接口。这个过程中有很多的代码复用。 一开始我写了一组使用范类的常用controller和service，并让新写的controller和service继承他们，效果还可以，但是还是要自己写entity以及配置数据库一些重复的操作。所以我想能否也省去写这些部分的时间。 实现结果 只通过一个json文件（即数据格式），生成一系列接口以及文档。 test.json {&quot;name&quot;: &quot;hi&quot;, &quot;age&quot;: 1} 生成效果（下面都是通过一个json生成的内容） 生成的文档目录(更新了app.module) 接口 接口内包括筛选，查找，分页，缓存等一系列选项。 数据格式文档 数据表 实现思路 nesjs有类似component的概念，component之间可以通过插入继承来实现复用。我这里使用了继承，因为想复用的部分都是可以共用的增查删改操作。 在网上搜索资料的时候发现，有人也有同样的思路，并写了一个包nestjsx/crud。star数有点少, 不过很好用，暂时只支持typeorm。既然有了轮子就不用自己造了。这个包含了swagger的配置，所以会自动生成文档。 基于这个包扩展开来，我要做的只是把json转成entity.ts文件，生成module,controller, service(继承crud)以及配置好数据库就行了。实现很简单我用了jupter notebook 然后转成了python。源码地址 实现过程在ipynb里，py是转换好的文件。 运行 ipython beg.py test(实例/数据表名) test.json(数据内容) 对nestjsx/crud的改进部分 增加了json转entity 补充了swagger分区（ApiTags）和显示entity内部属性（ApiModelProperty） 生成module,controller,service,并注入entiity repository 更新app.module 之后的扩展方向 丰富json数据类型支持，目前只支持string, int, bool 添加mongodb支持 提供更多entity column选项 添加接口权限控制 根据list of json 批量生成接口 生成一个接口，供前端使用，前端可以根据数据需求创造接口。 js重新打包成cli发布到npm 0.0.1 添加relation {} 为 one to one or many to one (default one to one) [] 为 one to many or many to many (default one to many) 只生成entity 描述 descrption 根据 已知bug json 中不能用id属性，因为id是由primaryGenerateColumn默认生成的。 ","link":"https://yueqingsheng.github.io/post/nestjs-hou-duan-dai-ma-zi-dong-sheng-cheng-shu-ju-biao-curd-jie-kou-wen-dang/"},{"title":"青春有你2 评论分析拓展","content":"2020/4/30 更新 1. 多线程数据爬取 获取视频列表 获取视频列表的url为https://www.iqiyi.com/v_19ryi480ks.html。 即任意一期右侧的正片这一栏。 找到 li标签下 class为play-list-item的data-td属性 需要注意爬取后的列表第一个为预告，可以去掉，这里只爬取所有正片 获取评论列表 接口 url参数： content_id: 视频id 通过上方的的视频列表中获取 last_id: 上个最后的视频id，每次获取完成后，使用最后一个id，作为下次获取的last_id page: 翻页的页数 page_size: 每页评论的个数 upremaining: 1最后一页， 0 后面还有内容 如何获取全部评论 两个思路 检查lastid 是否重复了，说明获取到最后一个 其实返回的data里有一个参数，&quot;upremaining&quot;:0。检查这个为1就可以了。 大部分同学都使用last_id翻页，其实参数里自带page,使用page=1，2，3，4也可以实现翻页 page_size可以设大一点，减少请求次数。最大为40 因为评论数量过多，使用多进程爬取。每一个进程爬取一个视频下的评论,总共花了1分3秒。不用多线程的话，估计要20多分钟。 截至2020日4月29日总共爬取了254287条数据。 2. 数据清洗 发现很多评论里出现多次刷同一个选手名的现象。所以做一下选手名去重，这样能在预测选手成绩时能保证合理性，防止多计算出现次数。 如: 虞书欣虞书欣虞书欣虞书欣虞书欣冲呀！！！ 清洗后为 虞书欣冲呀！！！ 3. 分词 数据请求后, 评论列表不再改变可以转化为tuple使用, tuple的access速度会比list快 使用tuple分词用了 9分3秒，会比list快十几秒。 4. 选手词频统计 经过26万条评论统计，按前20选手姓名出现频率排序 人名去重后，词频少了很多。 根据25号官方排名，前9名内除第9不一样，其他基本吻合。 5. 词云 按照词频显示词云 之前用形状和上色绘制了下词云，但是感觉效果没有原生的好。(这个是基于1000条数据生成的) 6. 节目评价 总体还是正向和中性评价占了绝大多数，95%。 随机打印一点 评价 正向： ['因为看了书欣的电视剧才来看这个的，喜欢她的性格', '我也喜欢左卓', '好喜欢刘雨昕！', '我真的太爱刘雨昕了', '好看好看', '看了这期，真的很心疼喻言', '安崎反差萌真的绝了，好看的颜值和有趣的灵魂她都拥有。', '我也喜欢虞书欣', '虞书欣加油', '冲着虞书欣搞笑视频来的，后面发现太太太多想pick的了。这种模式是看的第一个，努力又融洽的氛围真好。'] 中性： ['乃万！', '乃万', '我要去看男团了拜拜，记得给我点赞', '大家要帮忙投票了吗我这儿还有13票', '大家有要帮忙投票的吗我还有14', '虞书欣', '乃万简直是可盐可甜可rap 可vocal， 随时写词的到处撩妹的博爱艺术家 。', '谢可寅小姐姐要加油喽。', '刘雨昕', '林凡'] 负面; ['刘雨昕你咋不是个男的啊太帅了', '看得累死了磨磨叽叽', '我爱死所有训练生了', '傅如乔 爱死你了', '我就是看美女跳舞的，谁是谁，这个真不关心，长的都挺好看的，挺养眼', ''安琪的肚子真的不好看 感觉肚子肉好多 总喜欢露着腰,'入股不亏', '赵小棠什么鬼哦！', '真失望 为什么不是刘雨欣！ 突然不想看了', '不要脸', '小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！真的很棒！'] 模型把很多人名识别成了中性词，对英文的词性识别可能还不是很好。 有一些负面评价识别还行，但是也有不准的时候。比如“爱死了”， &quot;小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！&quot;可能把呜呜呜识别成负面了。 总结 跟原项目主要区别：多进程爬虫，多视频爬取，选手名去重，list改用tuple 经过爬取所有评论和同一句子人名去重后，发现数据可视化后还是变化挺大的。有很多人一个评论发很多重复的一个人名。 可拓展方面 评论生成，用文本生成模型生成一些青春有你相关的评论。 其实表情也是很好的反映观众心情的label, 也可以做这方面情感分析，finetuning 一下。根据评论生成表情，也会很有意思。 评论中还包括了大量的图片和动图，抓取下来，也可以做一些相应的拓展。 评论的用户信息分析，如地区 生成一个动态直方图，用户根据日期看不同日期的统计变化。参考视频，随便一个视频几万的播放量，我酸了 ","link":"https://yueqingsheng.github.io/post/qing-chun-you-ni-2-ping-lun-fen-xi/"},{"title":"Vue","content":"使用 CDN &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 数据绑定 括号绑定 {{message}} //括号中可使用表达式 如 {{message+ message}} 指令式绑定 &lt;div v-bind:id=&quot;message&quot;&gt;&lt;/div&gt; 简写形式 &lt;div :id=&quot;message&quot;&gt;&lt;/div&gt; 这里我们遇到了一点新东西。你看到的 v-bind attribute 被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title attribute 和 Vue 实例的 message 属性保持一致”。 响应式 可以这样理解：当一个状态改变之后，与这个状态相关的事务也立即随之改变，从前端来看就是数据状态改变后相关 DOM 也随之改变。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。 v-if v-else v-show v-for &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{message}}{{message+ message}} &lt;div :id=&quot;message&quot;&gt;&lt;/div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt; &lt;span v-if=&quot;!item.del&quot;&gt;{{item.title}}&lt;/span&gt; &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{item.title}}&lt;/span&gt; &lt;button v-show=&quot;!item.del&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { message: &quot;Hello World&quot;, list: [ { title: &quot;课程1&quot;, del: false, }, { title: &quot;课程2&quot;, del: true, }, ], }, }); &lt;/script&gt; &lt;/body&gt; 组件 Vue.component(&quot;todo-item&quot;,{ props:{ title: String, del: { type: Boolean, default: false, }, }, template: ` &lt;li &gt; &lt;span v-if=&quot;!del&quot;&gt;{{title}}&lt;/span&gt; &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{title}}&lt;/span&gt; &lt;button v-show=&quot;!del&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; `, data: function(){ return {} }, methods: { }, }) Vue.component(&quot;todo-list&quot;, { template: ` &lt;ul&gt; &lt;todo-item v-for=&quot;item in list&quot; :title=&quot;item.title&quot; :del=&quot;!item.del&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; `, data: function () { return { list: [ { title: &quot;课程1&quot;, del: false, }, { title: &quot;课程2&quot;, del: true, }, ]} } }) 组件中data 不能使用同一个data,因为pass by reference ，在一个地方改变，其他地方也会改变。data要求唯一化。 ","link":"https://yueqingsheng.github.io/post/vue/"},{"title":"第一次神经网络实践","content":"简单总结下教训： 输入，输出 输入就是 a和 b, 输出是c。 First attempt 一开始想把天数，1到28天作为输入，28天的感染人数作为输出。去找 天数和 感染的函数关系。错误的原因，28天只是任意的28天时间段，去强行找 1-28 和感染的关系是不成立的。也没有关系。 Second attempt 用RNN实现，方向是对的。能力不够复现RNN或LSTM(吐槽下，老师说如果要写的话，要从0复现一个，地狱级难度任务) 总结 其实确认输入输出，最重要的就是确立，想找的是什么与什么直接的关系。相互影响的那两个量。题目写的已经很清楚了，用c_t 和 t_pd 预测 c_inf 其中忽视的问题 只看到了cost变大，没有去考虑原因。原因是因为梯度爆炸。梯度爆炸的原因是，输入之间差值太大，呈现exponetial爆炸增长。 ！！！！ 最重要学到的点，什么时候要做归一化，即Normalizition 归一化，在处理奇异值时候特别重要，如果数据存在极大或极小值，会严重影响weight 的收敛。归一化即，把输入和输出限制在同意范围内，如[0,1],映射到同一维度内。 参考:机器学习——标准化/归一化的目的和作用 Anyway, 有空的话，可以用LSTM复现个玩玩。获取一个多维度输入，输出将来的感染人数。直到感染变化为0为止。 ","link":"https://yueqingsheng.github.io/post/di-yi-ci-shen-jing-wang-luo-shi-jian/"},{"title":"Python","content":"Random int import random random.randint(1,3) k unique samples import random random.sample(tags_id, 3) Print print 会自动换行，print(end=&quot;&quot;)会取消换行，end为结束后缀 遍历文件 os.walk() Python method walk() generates the file names in a directory tree by walking the tree either top-down or bottom-up. for root,dirs,files in os.walk(path): for fname in files: if filename in fname: result.append([id,fname]) string check contains str = \"Messi is the best soccer player\" >>> \"soccer\" in str True >>> \"football\" in str False 三引号 三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。 print('''I'm going to the movies''') html = ''' &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt; Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt; &lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt; &lt;B&gt;%s&lt;/B&gt;&lt;P&gt; &lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt; &lt;/BODY&gt;&lt;/HTML&gt; ''' print(html) 元组和列表 元组是不可变的， 而列表是可变的。 我们可以修改列表的值，但是不能修改元组的值。 由于列表是可变的，我们不能将列表用作字典中的key。 但可以使用元组作为字典key。 同构与异构 习惯上元组多用于用于存储异构元素，异构元素即不同数据类型的元素，比如(ip,port)。 另一方面，列表用于存储异构元素，这些元素属于相同类型的元素，比如[int1,in2,in3]。 list reverse sublist a[start:stop:step] # start through not past stop, by step step为-1的时候是reverse order a[:-11:-1] # the last 10 items, reversed sort The sort() method doesn't return any value. Rather, it changes the original list. list.sort(key=..., reverse=...) If you want a function to return the sorted list rather than change the original list, use sorted(). sorted(list, key=..., reverse=...) paramter reverse - If True, the sorted list is reversed (or sorted in Descending order) key - function that serves as a key for the sort comparison JSON Python list(dict) to json string json.dumps 用于将 Python 对象编码成 JSON 字符串。 import json data = [ { 'b' : 2, 'd' : 4, 'a' : 1, 'c' : 3, 'e' : 5 } ] json = json.dumps(data) print(json) [{&quot;b&quot;: 2, &quot;d&quot;: 4, &quot;a&quot;: 1, &quot;c&quot;: 3, &quot;e&quot;: 5}] json string to python list(dict)_ json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。 import json jsonData = '{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}' text = json.loads(jsonData) #将string转换为dict print(text) 打包并压缩 把当前目录下所有文件打包压缩成a.tar.zip tar -zcvf a.tar.zip ./ 解压 -C 指定目录 tar -zxvf a.tar.zip -C ../ 爬虫 request模块： requests是python实现的简单易用的HTTP库，官网地址：http://cn.python-requests.org/zh_CN/latest/ requests.get(url)可以发送一个http get请求，返回服务器响应内容。 BeautifulSoup库： BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。网址：https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ BeautifulSoup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml。 BeautifulSoup(markup, &quot;html.parser&quot;)或者BeautifulSoup(markup, &quot;lxml&quot;)，推荐使用lxml作为解析器,因为效率更高。 通过tag标签逐层查找: soup.select(&quot;body a&quot;) 获取属性 tag.get('href') 或者 tag['href'] 如果不确定某个属性是否存在时,用 tag.get('attr') 方法去获取它,跟获取Python字典的key一样 tag['class'] KeyError: 'class' print(tag.get('class')) None link = star['link'] headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } #！！！请在以下完成对每个选手图片的爬取，将所有图片url存储在一个列表pic_urls中！！！ pic_urls = [] response = requests.get(link,headers=headers) #将一段文档传入BeautifulSoup的构造方法,就能得到一个文档的对象, 可以传入一段字符串 soup = BeautifulSoup(response.text,'lxml') pic_list_url = soup.select(&quot;.summary-pic a&quot;)[0]['href'] tags1 = soup.select('div .shixian_zhaobiao') tag1 = tags1[0] tag2 = tag1.find(name = 'dl') tags2 = tag2.find_all(name = 'a') jsonp to json response_json = response[ response.index(&quot;(&quot;) + 1 : response.rindex(&quot;) } catch&quot;)] 或者get请求的时候，去掉callback=,则会返回json 动态请求 如果数据是动态加载，可以在浏览器network里查看请求的api 写入文件 With the &quot;With&quot; statement, you get better syntax and exceptions handling. &quot;The with statement simplifies exception handling by encapsulating common preparation and cleanup tasks.&quot; In addition, it will automatically close the file. The with statement provides a way for ensuring that a clean-up is always used. with open('output.txt', 'w') as file: # Use file to refer to the file object file.write('Hi there!') with 省去写exception handler和close file pandas read csv df = pd.read_csv('tag.csv') dataframe cut 将age按0-5，5-20...bins 分成 既几部分，label为[婴儿，青年...] ages = np.array([1,5,10,40,36,12,58,62,77,89,100,18,20,25,30,32]) #年龄数据 pd.cut(ages, [0,5,20,30,50,100], labels=[u&quot;婴儿&quot;,u&quot;青年&quot;,u&quot;中年&quot;,u&quot;壮年&quot;,u&quot;老年&quot;]) 参考 value_counts df.value_counts() 以Series形式返回指定列的不同取值的频率,默认按频率从高到低排序 groupby df['name'].groupby(df['zone']) s = grouped.count() zone 中国上海 5 中国北京 9 df = pd.DataFrame({'Animal': ['Falcon', 'Falcon', 'Parrot', 'Parrot'], 'Max Speed': [380., 370., 24., 26.]}) df Animal Max Speed 0 Falcon 380.0 1 Falcon 370.0 2 Parrot 24.0 3 Parrot 26.0 df.groupby(['Animal']).mean() Max Speed Animal Falcon 375.0 Parrot 25.0 matplot size plt.figure(figsize=(12, 12)) %matplotlib inline %matplotlib inline 可以在Ipython编译器里直接使用，功能是可以内嵌绘图，并且可以省略掉plt.show()这一步 pie 参数： x :(每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化； labels :(每一块)饼图外侧显示的说明文字； explode :(每一块)离开中心距离； startangle :起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起； shadow :在饼图下面画一个阴影。默认值：False，即不画阴影； ## draw pie labels = [&quot;45-50kg&quot;,'&lt;45kg','50-55kg','55kg'] plt.pie(weightsfreq.values, explode=(0.1,0.1,0.1,0.1),labels=labels, shadow=True,autopct='%.2f%%',startangle=90) plt.axis('equal') plt.legend(loc=&quot;upper right&quot;,fontsize=10,bbox_to_anchor=(1.1,1.05),borderaxespad=0.3) plt.title('''《青春有你2》选手体重分布''',fontsize = 10) plt.savefig('/home/aistudio/work/result/bar_result03.jpg') 参考 正圆 plt.axis('equal') string format python &gt;3.6 &gt;&gt;&gt; name = 'hoxis' &gt;&gt;&gt; age = 18 &gt;&gt;&gt; f&quot;hi, {name}, are you {age}&quot; 'hi, hoxis, are you 18' 百分号 %%表示百分号 &gt;&gt;&gt; print('数据的比例是:%.2f%%' %(scale * 100)) 数据的比例是:10.00% &gt;&gt;&gt; print('数据的比例是:%d%%' %(scale * 100)) 数据的比例是:10% 参考 词云 根据词频绘制词云图 参数 word_f:统计出的词频结果 # 生成对象 mask = np.array(Image.open(&quot;alice_mask.png&quot;)) wc = WordCloud(mask=mask, font_path='SimHei.ttf', mode='RGBA', background_color=None) wc.fit_words(word_f) # 显示词云 plt.imshow(wc, interpolation='bilinear') plt.axis(&quot;off&quot;) plt.show() # 保存到文件 wc.to_file('wordcloud.png') matlibplot 加载中文字体 #下载中文字体 wget https://mydueros.cdn.bcebos.com/font/simhei.ttf #在操作系统中创建字体目录fonts（可能已经有 mkdir .fonts # 复制字体文件到该路径 cp simhei.ttf .fonts/ #复制字体到当前使用的conda环境中的matplotlib下的指定路径 cp simhei.ttf /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/matplotlib/mpl-data/fonts/ttf/ # Linux系统默认字体文件路径 ls /usr/share/fonts/ # 查看系统可用的ttf格式中文字体 fc-list :lang=zh | grep &quot;.ttf&quot; # 设置显示中文 matplotlib.rcParams['font.san-serif'] = ['SimHei'] # 解决负号'-'显示为方块的问题 matplotlib.rcParams['axes.unicode_minus'] = False 如果没成功，尝试 from matplotlib.font_manager import _rebuild _rebuild() #reload一下 jieba 分词 jieba.load_userdict('name.txt') #name.txt 为用户自定义分词 seg = jieba.lcut(text,cut_all=False) 停用词 stopwords = [line.strip() for line in open(file_path, encoding=&quot;UTF-8&quot;).readlines()] for word in sentence: if word not in stopwords: if len(word) &gt; 1: counts[word] = counts.get(word, 0) + 1 字典 .get(key,value) value为如果不存在返回的值，counts.get(word, 0)： word不存在于counts中则返回 0 中文常用停用词词表 多进程 多进程共同的全局变量，需要使用特殊方式声明： from multiprocessing import Process, Value, Array, Manager def f(n, a): n.value = 3.1415927 for i in range(len(a)): a[i] = -a[i] if __name__ == '__main__': num = Value('d', 0.0) arr = Array('i', range(10)) lis = Manager().list() p = Process(target=f, args=(num, arr)) p.start() p.join() print(num.value) print(arr[:]) 多进程list 使用前需转换回普通list， list(lis) .join() 可以等待进程执行结束后再输出 多进程的一个大坑：broken pipe 解决方案不要在主线程外使用shared object,这样主线程使用的时候修改，会影响子线程的这个object 解决方案：移除主线程的修改，或者把修改放到子线程跑完之后 解释 .join() 主线程等待子线程跑完。python默认是先执行完主线程 process= [] for c_id in content_ids: # 每个进程爬取一个视频下的评论 p = Process(target=getMovieinfo,args=(c_id,)) process.append(p) p.start() #等待所有线程任务结束。 for p in process: p.join() print(&quot;总共获取了&quot;,len(comments),'条评论') 这样主线程就会阻塞了 参考 ","link":"https://yueqingsheng.github.io/post/python/"},{"title":"Day 18","content":" lecture 28 lecture 29 lecture 30 TODO vector embeddings lecture 31 lecture 31 cs489 蛮有意思的，neuro science 从头贯穿到尾，讲neural network 的起源，和各种机制设置的原因。整个学期其实就一个Model, 就是人脑神经。从脑科学的角度改进network和思考大脑是如何解决某项任务的，如视觉系统。 ","link":"https://yueqingsheng.github.io/post/day-18/"},{"title":"Day 17","content":" code: chat vue vue 看了 react angular文档，太复杂了。转vue了。 ","link":"https://yueqingsheng.github.io/post/day-17/"},{"title":"Day 16","content":" code: chat 课程价格 评价 评分 今天 windows, mysql 直接抽了，不知道为啥，完全不听typeorm的改动，我服了。本来半天能写完的代码，硬是debug一天。结果发现是数据库的问题。 ","link":"https://yueqingsheng.github.io/post/day-16/"},{"title":"Day 15","content":" code: chat code: morning 订单 课程价格 评价 订单表设计： 类型： 课程， (谈一谈)talk, 要传 图片 课程标题： 订单的话用课程号区分吧，定为timestamp ok, tradeno class: 关系 counselor: 关系 标题 body, 图片服务器根据type和body查找订单，存储Image和关系 订单评价： 评价： comment 包含 counselor, course 里有评价, counselor里 eager， 流程就按post里走 评分： 每次评价都创建一个即使为空，按 （原来的+new）/总数 课程价格： price class ， 包含 几天 ","link":"https://yueqingsheng.github.io/post/day-15/"},{"title":"Day 14","content":" Angular 起步2 Angular 表单 Angular 路由 Angular 守卫 Angular 异步路由 code: chat code: morning 小细节：修改了首页图标跳转 ","link":"https://yueqingsheng.github.io/post/day-14/"},{"title":"Day 13","content":" Angular 起步1 code: chat code: morning ","link":"https://yueqingsheng.github.io/post/day-13/"},{"title":"Day 12","content":" Angular Components 略微修改了主题，简化了标题下的header，以及返回按钮（加粗），有空加个返回顶部 配置了vscode 实现了 terminal 和 editor 全部自动化 和代码高亮主题 code: chat code: morning ","link":"https://yueqingsheng.github.io/post/day-12/"},{"title":"Day 11","content":"充满希望的春天来了。😉 code: chat code: morning A5 done Angular start 白天把作业写完了，晚上写了会angular,配置了插件。prettier(格式化) 和 angular essential（待学习），配置了下主题。 抽空排一下温柔的歌单吧。 ","link":"https://yueqingsheng.github.io/post/day-11/"},{"title":"Angular","content":"为什么js推荐使用单引号 单引号和多引号区别，没啥区别，单引号编译速度更快，而且单引号内可以使用双引号，有时候内部是json 格式必须用双引号 中文解释 模块 创建模块post 放在 modules/post 下 ng generate module modules/post componet 是生成的html 和css,ts 文件 模块导入 需要导出的模块在module 的 exports中添加，exports: [PostComponent], 引用的模块导入：imports: [PostModule], 数据绑定 在component.ts 内声明 .html 使用{{值}} *ngFor *ngfor 会自动扩展成 &lt;ng-template ngfor&gt; *是一种语法糖，缩写形式 &lt;li *ngFor=&quot;let entity of entities&quot;&gt; &lt;h4&gt;{{ entity.title }}&lt;/h4&gt; &lt;/li&gt; *ngIf &lt;p *ngIf=&quot;entity.body&quot;&gt;{{ entity.body }}&lt;/p&gt; 属性绑定 &lt;a title=&quot;{{ entity.title }}&quot; &gt;{{ entity.title }}&lt;/a&gt; &lt;a [title]=&quot;entity.title&quot;&gt;{{ entity.title }}&lt;/a&gt; 第二种形式可以绑定标签不存在的属性值 如 text-content, Angular 官方文档在绑定属性几乎都是使用[]，而插值表达式{{}}更多是用于显示，两者最大的区别就是后者会将{{}}语句里执行完的值再转换string 类型。 事件绑定 &lt;button (click)=&quot;removeItem(i)&quot;&gt;Remove&lt;/button&gt; 参数直接填就行 双向绑定 Module import { FormsModule } from '@angular/forms'; // &lt;-- NgModel lives here app.module.ts (@NgModule imports) content_copy imports: [ BrowserModule, FormsModule ], &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt; [(ngModel)] 是 Angular 的双向数据绑定语法。 这里把 hero.name 属性绑定到了 HTML 的 textbox 元素上，以便数据流可以双向流动：从 hero.name 属性流动到 textbox，并且从 textbox 流回到 hero.name 。 父子组件 父传子 传递数据， 父组件ul, 数据为entities在父组件内， 必须在子部件属性内赋值， 子部件使用@Input,， //@Input 此命令用来修饰属性是用来接收父组件传递的值 参考 有兴趣了解下单向数据流 angular 更新view，是在model更新阶段进行，不是model生成view阶段。 &lt;ul&gt; &lt;app-post-item *ngFor = &quot;let entity of entities&quot; [entity] = entity&gt; &lt;/app-post-item&gt; &lt;/ul&gt; 子传父（function） This example features an &lt;input&gt; where a user can enter a value and click a &lt;button&gt; that raises an event. The EventEmitter then relays the data to the parent component. 子部件 @Output() newItemEvent = new EventEmitter&lt;string&gt;(); addNewItem(value: string) { this.newItemEvent.emit(value); } &lt;button (click)=&quot;addNewItem(newItem.value)&quot;&gt;Add to parent's list&lt;/button&gt; 父部件 &lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;&lt;/app-item-output&gt; The event binding, (newItemEvent)='addItem($event)', tells Angular to connect the event in the child, newItemEvent, to the method in the parent, addItem(), 路由 basics app-routing.module.ts const routes: Routes = [{ path: 'posts', component: PostComponent }]; router link &lt;a [routerLink]=&quot;['/posts', entity.id]&quot; [title]=&quot;entity.title&quot; [textContent]=&quot;entity.title&quot; &gt;&lt;/a&gt; import from app-routing module paramMap constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.route.paramMap.subscribe((params) =&gt; { const postId = +params.get('id'); console.log(postId); }); Model 标记可选属性使用问号 body? 服务 @Injectable({ providedIn: 'root' }) root表示在任何位置可以使用 注入 componet.ts constructor(private postService: PostService) { this.entities = posts; } 表单 看这个文章，更详细点 pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 演示： 这是一个pre标签 哈 哈 formBuilder registerForm = this.formBuilder.group({ username: ['', Validators.required], password: ['', [Validators.required, Validators.minLength(6)]], }); ","link":"https://yueqingsheng.github.io/post/angular/"},{"title":"nestjs的坑","content":"不定期更新 变量名 变量命名时尽量不要用type, class 这些名称，以免用的时候，报一些奇怪的错误。编译器不知道是，自定义的名，还是语法里的意思。comment 也是关键字，需自己导包，我也是服了。 eager eager 谨慎使用，特别是relation有相互包含的时候。必须只能加在一边，防止重复包含，导致stack overflow。 eager 只会在find里生效,querybuilder 必须join find find 有很多选项足够用了可以代替 queryBuilder OneToMany Save 例子： 商品储存多个价格， data 是发送的商品数据，其中包含了price data.price = await this.priceRepository.save(price); data = await this.repository.create(data); return await this.repository.save(data); 注意 data.price 这一步是必须的，是为了更新刚储存完的id号，typeorm 用id 来建立关系 环境变量 process.env. 在for root里不好使，即使在main.ts里提前执行了config()。 非 for root 使用 require('dotenv').config() rocess.env. for root 使用 aynscfor root 在服务器更新 .env 文件 ##数据库更新 typeorm 更新的很随缘，如果发现数据格式不符bug。可以把dist文件夹删了 重跑一遍。 如 enum更新，或Column type更新 typeorm 从 entity.js 读取column 信息。 Controller 切记不要写这种路径 Get(':id') Get('user') Swagger paramter 参数必须声明类型，swagger才能识别到 nestjsx/crud 版本最好4.6.0， 4.5同时get by id和relation会报sql syntax error typescript 类型错误或不匹配时候可以强行转成any You can always temporarily cast $ to any: delete ($ as any).summernote mysql: 3306 eradr 出现这个错误大概率是，.env或production.env 的问题，本地的话检查下port端口，设置为localhost Observable nestjs httpservice 默认返回Observable Observable异常处理 .pipe( catchError(err =&gt; { return of(err.message); }), ); Observable值异步处理 result.subscribe((value)=&gt; { console.log(value); }); ","link":"https://yueqingsheng.github.io/post/nestjs-de-keng/"},{"title":"Day 10","content":" lecture 27 lecture 28 lecture 29 lecture 30 code: chat code: morning A5 1done 2a 差解释 明天上午大概就能写完作业了，有空把population 图画一下，还挺有意思的。开始学angular ","link":"https://yueqingsheng.github.io/post/day-10/"},{"title":"Day 9","content":" lecture 24 lecture 25 lecture 26 lecture 27 lecture 28 lecture 29 code: chat code: morning 公司网站推广配置 睡眠1-11点，早上8点接了个电话又睡着了。看来调整生物钟不是一天的事情，早睡早起后依然很困。 最近不知道怎么了，每天把自己弄得很累。不知道什么时候开始，分给她的时间很少。可能是潜意识认为，不会再分开了，没有关心到她。挺自责的。感觉自己好像远远没开始那么努力了，虽然一直喜欢他，但是聊的越来越少。 其实这么多年都，没法放下。我也很想，这种状态下去，但有时候觉得只是表面的假象。这段恋爱都是自己骗自己，因为见不到面。每次分手和好原因大致相同，都还是回到原地。应该拿出一段时间，回国去陪她。做个计划吧。 今天听课放的视频，训练猴子操作手柄游戏，用电脑建立模型，然后让电脑模仿猴子操作游戏，还蛮有意思的（encode step, known X and A）。之后通过相关神经元的刺激，就可以得知猴子在想什么了(decode step)。(know A and output X, try to minimize least squre of DA-X, to get D, i.e weight of decoding) ","link":"https://yueqingsheng.github.io/post/day-9/"},{"title":"Pull request（第一次参与开源项目）","content":"学了CSS 和 html 基础，突然想起来前几天给主题作者提的意见，他刚好比较忙，那能不能我自己改下呢，嘿嘿。 fork 项目到自己git 下 git remote add upstream https://github.com/QibaiAluminum/EKT.git 添加源项目链接 push 改动 到github 提交 pull request ","link":"https://yueqingsheng.github.io/post/pull-requestdi-yi-ci-can-yu-kai-yuan-xiang-mu/"},{"title":"Day 8","content":"每天 TODO list 新增计划： code: chat code: morning 今天心情不好啊，效率有点低。 接下来几天要先写AI作业了，网站开发先放一下。 ","link":"https://yueqingsheng.github.io/post/day-8/"},{"title":"Day 7","content":" nestjs 配置好微信支付，这文档神坑，真的服了，使用插件 notadd-pay, 参考配置文章 nestjs 配置好微信支付，这文档神坑，真的服了，使用插件 notadd-pay, 参考[配置文章](https://blog.csdn.net/ZChangfeng/article/details/78899618) 设计了订单库 设置了付款及退款的返回 修复bugs ","link":"https://yueqingsheng.github.io/post/day-7/"},{"title":"javascript cheatsheet","content":"DOM（文档对象模型） 文档树： each label is a node in the tree getElementById document.getElementById('page-title') getElementsByTagName document.getElementsByTagName('li') querySelectorAll querySelectorAll('.class a') 返回所有 querySelector 返回找到的第一个 访问属性 e.nodeName 标签名 e.innerText 内部文字 e.paretnNode 父节点 e.nextElementSibling 下一个兄弟元素 previousElementSibling e.childNodes 子节点 e.childElementCount 返回子节点数量 e.firstELementChild 第一个子节点 e.lastELementChild 最后一个子节点 修改 用=赋值 创建新的节点 步骤： var newMember = document.creatElement('li') var text = document.createTextNode('你好啊'); newMember.appendChild(text) document.querySelector('#list').appendChild(newMember) 添加到最后 insertBefore 插入到特定位置 countrylist.insertBefore(newMember, countrylist.firstChild) 修改CSS document.getElementById(id).style.property=新样式 事件 onclick=JavaScript <!DOCTYPE html> 点击文本! 绑定函数 &lt;p&gt;点击按钮执行 &lt;em&gt;displayDate()&lt;/em&gt; 函数.&lt;/p&gt; &lt;button onclick=&quot;displayDate()&quot;&gt;点这里&lt;/button&gt; &lt;script&gt; function displayDate(){ document.getElementById(&quot;demo&quot;).innerHTML=Date(); } &lt;/script&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; onload onunload onload 和 onunload 事件会在用户进入或离开页面时被触发 onmouseover 和 onmouseout 事件 onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 JavaScript HTML DOM EventListener document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate); ","link":"https://yueqingsheng.github.io/post/javascript-cheatsheet/"},{"title":"docker 自动化脚本配置","content":" clone https://github.com/YueqingSheng/auto-deploy.git 在主目录下编写脚本 在 routes/index.js 下添加接口 参考Route这里 push 服务器 脚本添加权限 forever restart ./bin/www TODO: 自动化 4-6步 By webhook spawn exec方法 在 node.js child_process模块中的应用及区别 解决 Error: maxBuffer exceeded docker logs－查看docker容器日志 ","link":"https://yueqingsheng.github.io/post/docker-zi-dong-hua-jiao-ben-pei-zhi/"},{"title":"Day 6","content":"PR 通过了 哈哈，接下来有时间的话可以简单魔改下主题 start angular AI 作业 ","link":"https://yueqingsheng.github.io/post/day-6/"},{"title":"Day 5","content":" js 基础 魔改下主题，添加封面图 start angular 很难坚持下去啊，第5天了，各种事会干扰一下，效率明显没有前几天高了。考虑下早睡早起？ 可能会提高些效率。 ","link":"https://yueqingsheng.github.io/post/day-5/"},{"title":"Day 4","content":" nestjs 配置微信支付 css课程 part2 浮动 css课程 part3 盒子 css课程 part4 定位 对CSS 课程的评价: 一共选择了三种课，首先考虑阿里云大学CSS, 发现换了html的导师，每个视频30多分种，实在不想看下去。就是找了源html老师的视频，下载后发现每个视频三四分钟，够短了，讲的也很好，可是分了几百个视频。。。。迫于时间紧迫，转投宁皓网，一直喜欢他的课的原因就是够简练，缺点就是过去简练了，很多东西都一笔带过。还是要结合html老师的课和网上资源来看。 课程链接： 满幽默的，分集太多 + ninghao够简练，过于简练。。 CSS 练习 链接 查看方式 在这个链接https://htmlpreview.github.io/?https://github.com/YueqingSheng/build_a_blog_from_scratch/blob/master/css/尾部加入标签文件名，文件名列表如下： 如： 想查看background.html这个例子，点这个链接 csss的解释在CSS cheatsheet下 ","link":"https://yueqingsheng.github.io/post/day-4/"},{"title":"CSS cheatsheet","content":"目的 结构样式相分离, html只做结构，css做样式 h1 { color: orange; } p { color: pink; } 字体 font-size font-family 支持汉字， 默认14px microsoft yahei， 尽量使用偶数号，各种字体用逗号隔开 &quot;微软雅黑&quot;,arial, sans-serif 按顺序没有的话往后找 如果字体内包括 空格 #$ 需要加引号 尽量使用默认字体 Unicode 字体 不支持中文字体的时候，使用Unicode代替 font-weight normal bold bolder lighter, 100-900 100的整数倍 font-style normal italic 综合字体样式 {font: font-style font-weight font-size font-family;}必须按顺序 前面可以省略，必须包括 font-size 和 font-family 注释 快捷键 ctrl + / 或者 /* 注释*/ 选择器 标签选择器 p{ } div{ } 标签作为选择器 类选择器 .类名{属性：属性1 } &lt;div class=&quot;类名&quot;&gt; 命名规则 相应的效果 或者主体名 （见名知义） 多类名选择器 &lt;div class=&quot;font20 pink&quot;&gt; id选择器 #class{ } &lt;div id=&quot;class&quot;&gt; class选择器和id选择器区别 类选择器是可以重复多次使用的，如人名 id选择器好比身份证，是唯一的 通配符选择器 *{ *代表所有选择器 color: red; } &lt;div id=&quot;class&quot;&gt; 伪类选择器 链接伪类 主要针对于&lt;a&gt; 简写方式 a{} a:hover{} 派生选择器 比方说，你希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： li strong { font-style: italic; font-weight: normal; } 群选择器 #main, #header{ main 跟 header 共同的样式 } 样式 内嵌样式 &lt;h2 style=&quot;color:green&quot; &gt;测试&lt;/h2&gt; 外部样式 &lt;link rel=&quot;stylesheet&quot;样式表 href=&quot;outside_style.css&quot; type=&quot;text/css&quot; /&gt; CSS 特性 继承 内部标签会继承外部内部的样式 不是所有的属性都会被继承，如边框，边距 层叠 内部标签会叠加所有外部的样式， 如果外部样式有冲突，继承离最近的外部标签，或者当前定义的样式 标签&lt;类 &lt;id &lt;行内样式 行内style，派生选择器会累计分数，#mainbody h2 101 盒模型 小技巧： margin:0 auto; (上下边距0，左右边距自动，即居中) 浮动 img style=&quot;float:right;margin-left:20px;margin-bottom:20px h2 style=&quot;clear:both&quot; 背景 background: url(b.jpg) ; 定位 position: absolute;right:0;top:0: ","link":"https://yueqingsheng.github.io/post/css/"},{"title":"Day 3","content":"Today Do list 给自己网站加个歌单吧，插件只能一首一首手动输入，那就慢慢加吧。新加了一首 css课程 part1 字体 选择器 css 内容太多了， 明天再学一部分，就开始angular了。挖个坑。 忽然发现css 可以在markdown内用，把文章改的很好看，那就用上了。 h1 { color: orange; } p { color: darksalmon; } ","link":"https://yueqingsheng.github.io/post/day3/"},{"title":"Today's little fun","content":" h1 { color: orange; } 闲着没事，把Gridea主题商店逛了下,发现了个很好看的免费主题啊，点这里，配置了一下博客完全焕然一新啊，云养猫，计划通。 顺藤摸瓜找到了源作者的博客，和他模仿的源源作者的博客（俄罗斯套娃）， 源作者 源源作者 很漂亮啊，跟我的审美差不多（臭不要脸） 再就是很羡慕，这些能把自己的技术转换成实际生产力的人啊，为了兴趣而写代码，看看他们写的博客，再看看自己。。。还是要努力啊。希望自己有天也有能力，能实现自己想做的想法。 另外，源作者网站的音乐很好听啊，我直接copy到我的网站上了，哈哈，有兴趣可以听听，我循环了一晚上。 ","link":"https://yueqingsheng.github.io/post/todays-little-fun/"},{"title":"Day 2","content":"Today Do list 添加 html 链接, github html课程 1-10 html课程 11-20 html课程 21-33 html就是种书写格式，学了markdown, latex，再加上这个的我一脸懵逼，这种不就是用的时候查下表就行的么。吐槽下一种行业一种写法，能不能统一下。。 肝完了 yes!🤣 明天开始肝css了，还要简单学下数据绑定，就开始学angular了。 html 下demo 查看方法 对每种html标签都写了例子，查看方式 在这个链接https://htmlpreview.github.io/?https://github.com/YueqingSheng/build_a_blog_from_scratch/blob/master/html/尾部加入标签文件名，文件名列表如下： 如： 想查看image.html这个例子，点这个链接👇 https://htmlpreview.github.io/?https://github.com/YueqingSheng/build_a_blog_from_scratch/blob/master/html/image.html html标签的解释在html cheatsheet下 ","link":"https://yueqingsheng.github.io/post/day-2/"},{"title":"简单总结下我的全栈学习路线","content":"加油，加油！😄 前端 前端学习中不用刻意去记一些东西，记好笔记（或者直接用我的），到时候查就行了。理解优先 课程选择： html 阿里云大学 css 课程链接： 同一个老师，分集太多，学第一部分到选择器然后转宁皓网就行 + ninghao比较简练 js: 宁皓网 新手推荐这个系列 框架： angular因为我后端用的是nestjs angular去屎吧, vue万岁！ vue推荐极客大学 推荐工具 有些课历史比较久了，所以开发工具有点老，推荐开发工具vscode +插件： VScode 插件推荐 open in browser(写完代码，直接 ctrl+s 保存 ，alt+b 浏览器打开超方便) tabnine+ autoimport + auto close tag （以上三个全是自动补全） prettier (自动格式化代码) angular essential(插件包) Settings Sync 在不同设备同步设置插件 终端推荐使用zsh windows 配置方法： 安装bash, wsl 安装oh-my-zsh bash 内设置默认shell为zsh 下载必要组件如 node npm 在vscode 里配置默认shell 为 wsl html,css 自动补全 (有兴趣可以了解下, 用习惯了开发效率很高) Emmet 可以用缩写写标签和属性 其他 github 这个必须要有啊，懂得都懂 强烈建议写个博客网站，原因么，很多，一个是云端保存笔记，一个是可以使用Markdoｗｎ, markdown 内部可以使用html.css 语法，边学边写。（另外个原因，可以自己魔改网站啊，很有动力，学以致用） 0基础搭建博客 推荐这个 Gridea 后端 目前学习计划是 后端nestjs（mongodb + graphql +exception handler+ environment storage），相当于重写一遍后端了，现在后端写的太乱。 下一步就是学 pandas ,numpy 基础 + 爬虫+ pytorch or tf 学习整理数据。 ","link":"https://yueqingsheng.github.io/post/jian-dan-zong-jie-xia-wo-de-wang-zhan-xue-xi-lu-xian/"},{"title":"Day 1","content":"Why? 为什么要写个博客网站呢？ 理由很简单，也很自然，代码敲的多了，学习过程中，有很多东西容易忘，学习记的笔记需要找个地方存放下来。本地的话，不方便查阅和备份。刚好最近在学习angular+ nestjs 技术栈, 那就用它搭个网站吧。 About this site 这个网站目前是临时的，只是记录下搭建博客网站的历程，其中学习的东西和笔记，也会先传在这里记录一下。 About that site 目前定下的技术栈为 angular+ mongodb+ graphql + nestjs ， maybe websocket and microservices。如果感觉能用上也可以。 Today Do list nestjs 试了下 websocket 搞了个简易聊天室还蛮好玩的。https://ninghao.net/course/7990#toc 使用Gridea 搭了这个网站 https://gridea.dev 添加了评论 找个好用的Markdown 编辑器 , 暂时使用Gridea 编辑 开始学习html, css https://developer.aliyun.com/course/1742 老师贼搞笑，说要把浏览器当成女朋友🤣 ","link":"https://yueqingsheng.github.io/post/day-1/"},{"title":"html cheatsheet","content":"html 转义工具 here Basics The visible part of the HTML document is between &lt;body&gt; and &lt;/body&gt;. &lt;html&gt; 根标签 &lt;head&gt; 头标签 &lt;title&gt;&lt;/title&gt; 标题标签（网站标题） &lt;/head&gt; &lt;body&gt; 主体标签 &lt;/body&gt; &lt;/html&gt; example 快速生成 html:5 或者 ! 单标签 &lt;label /&gt; &lt;br /&gt; 多标签 &lt;lable&gt; 内容&lt;/label&gt; 关系 嵌套 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;/html&gt; 并列 &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; 文档类型 &lt;!DOCTYPE&gt; 声明 html 版本 &lt;!DOCTYPE html&gt; : html5 html5向下兼容其他版本 &lt;meta charset=&quot;UTF-8&quot;&gt; 字符集 标题 &lt;h1&gt; 到 &lt;h6&gt; 段落 &lt;p&gt; 分段，自动换行 水平线标签 &lt;hr/&gt; horizontal 换行 &lt;br/&gt; 段落会自动空出间隔 div span 网页布局 &lt;div&gt; &lt;span&gt; 文本格式化 加粗 important text 斜体 emphasized 删除线 deleted 下划线 inserted 标签属性 key=&quot;value&quot; 图像标签 &lt;img src=&quot;wo.jpg&quot;/&gt; 链接标签 &lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; 锚点定位 &lt;a href=&quot;#go&quot;&gt; &lt;h3 id=&quot;go&quot;&gt; base标签 &lt;head&gt;&lt;base target=&quot;_blank&quot; /&gt;&lt;/head&gt; 所有链接以新窗口打开 特殊字符 注释标签 &lt;!--注释--&gt; 无序列表 &lt;ul&gt; &lt;li&gt;elements&lt;/li&gt; &lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;elements&lt;/li&gt; &lt;/ol&gt; 自定义列表 &lt;dl&gt; &lt;dt&gt;elements&lt;/dt&gt; &lt;dd&gt;subelements&lt;/dd&gt; &lt;/dl&gt; ","link":"https://yueqingsheng.github.io/post/html-cheatsheet/"},{"title":"markdown cheatsheet","content":"行内代码 &lt;html&gt; &lt;head&gt; &lt;title&gt;多行代码，第一行反引号后面，输入代码块所使用的语言，实现代码高亮&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 上方是☝️分割线 斜体 斜体 加粗 done to do &lt; 转义字符&gt; html 转义工具 here 区块 这里 第一层嵌套 第二层嵌套 ","link":"https://yueqingsheng.github.io/post/markdown-cheetsheet/"},{"title":"关于","content":"最近想用 angular + mongodb + graphql + nestjs 搭个网站，在这里记录下流程 反正也没人看，就写点自己想写的东西吧。😊 网站文章封面图片来源 ","link":"https://yueqingsheng.github.io/post/about/"}]}