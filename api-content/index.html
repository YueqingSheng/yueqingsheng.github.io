{"posts":[{"title":"RSS订阅（Feedly + Rsshub）","content":"每天被各个网站上和app的推荐算法烦到了，被动接受了很多无用信息，RSS 最吸引人之处，就在于它能让你看到「开放互联网未经过滤的样子」，给你一个「自己决定看什么」的机会。 一直有个想法搭个RSS信息聚合的网站，找了一圈发现有很多现成的工具了。完全可以使用这些工具解决。（不用写代码了，yeah!） Feedly 网站链接 找了几个，发现feedly是页面展示最好的一个，而且还有手机端app。 网页 app 唯一的缺点，对图片的预览不是很好。 看图片推荐切换到cards view, 设置成直接打开网站。 RSS源 RSSHUB已经包含了大多数获取的来源，如果还没有的话，推荐RSSHUB Radar这个插件，可以自动获取当前网站是否有rss link。 结合这两个基本上，每天所有的信息源都可以获取到了，比如接入常看的youtube频道，网易云歌单, b站up主，画师，微博，电台，直播。 RSS 是用于分发Web 站点上的内容的摘要的一种简单的XML 格式。它能够用于共享各种各样的信息。 我感觉可以把RSS理解成爬虫爬下来然后整理的一种数据格式，所以基本上，网上能浏览的网页，都可以做成RSS来看。也可以把它利用成获取各种通知和推送的工具，比如看直播课，大学信息，追剧更新。 添加源方法 在Feedly里直接复制RSSHUB里的链接就行了 RSS里看视频 Done! 在想RSS能否扩展成一个网站浏览所有信息呢？（使用视频播放，音频播放，以及直播流） 拓展： 推荐阅读 你的新闻 App 被推荐算法「毁」了，但 RSS 真的能拯救你吗 随着RSS进化，某一天这个技术本身也会拿来做推荐算法的优化。所以重点不是在于技术本身，而是个人是否有寻求有价值信息的能力。 ","link":"https://yueqingsheng.github.io/post/rss-ding-yue-feedly-rsshub/"},{"title":"用sao从0写一个脚手架（cli, scafolding, sao）","content":"看了一些文章，发现saojs 包括了一个简单的generator流程。但是网上详细介绍的文章太少了，作为一个js小白，把流程记录下。 Run/Test 第一步是先把脚手架跑起来，这里使用了ava测试。参考 AVA 安装 ：npm install ava -g 开始测试：ava snapshot testing 第一次测试ava会生成main.js.snap和main.js.md，然后自动比对之后生成的snapshot是否跟储存的一致。参考 snapshot更新：ava -u Sao generators test parameters 测试能跑起来了下面看一下，sao testing的参数 answers 的格式为 { useRouter: true } Ejs docs Inquiryjs docs 参考 如何开发一个可爱的CLI（一） ava test ","link":"https://yueqingsheng.github.io/post/yong-sao-cong-0-xie-yi-ge-jiao-shou-jia-cli-scafolding-sao/"},{"title":"nestjs 后端代码自动生成（数据表，curd接口，文档）","content":"起因 最近给公司写接口的过程中，发现每有一种新的数据形式，出现就需要重新写一个数据表，并提供相关的数据接口。这个过程中有很多的代码复用。 一开始我写了一组使用范类的常用controller和service，并让新写的controller和service继承他们，效果还可以，但是还是要自己写entity以及配置数据库一些重复的操作。所以我想能否也省去写这些部分的时间。 实现结果 只通过一个json文件（即数据格式），生成一系列接口以及文档。 test.json {&quot;name&quot;: &quot;hi&quot;, &quot;age&quot;: 1} 生成效果（下面都是通过一个json生成的内容） 生成的文档目录(更新了app.module) 接口 接口内包括筛选，查找，分页，缓存等一系列选项。 数据格式文档 数据表 实现思路 nesjs有类似component的概念，component之间可以通过插入继承来实现复用。我这里使用了继承，因为想复用的部分都是可以共用的增查删改操作。 在网上搜索资料的时候发现，有人也有同样的思路，并写了一个包nestjsx/crud。star数有点少, 不过很好用，暂时只支持typeorm。既然有了轮子就不用自己造了。这个包含了swagger的配置，所以会自动生成文档。 基于这个包扩展开来，我要做的只是把json转成entity.ts文件，生成module,controller, service(继承crud)以及配置好数据库就行了。实现很简单我用了jupter notebook 然后转成了python。源码地址 实现过程在ipynb里，py是转换好的文件。 运行 ipython beg.py test(实例/数据表名) test.json(数据内容) 对nestjsx/crud的改进部分 增加了json转entity 补充了swagger分区（ApiTags）和显示entity内部属性（ApiModelProperty） 生成module,controller,service,并注入entiity repository 更新app.module 之后的扩展方向 丰富json数据类型支持，目前只支持string, int, bool 添加mongodb支持 提供更多entity column选项 添加接口权限控制 根据list of json 批量生成接口 生成一个接口，供前端使用，前端可以根据数据需求创造接口。 js重新打包成cli发布到npm 0.0.1 添加relation {} 为 one to one or many to one (default one to one) [] 为 one to many or many to many (default one to many) 只生成entity 描述 descrption 根据 已知bug json 中不能用id属性，因为id是由primaryGenerateColumn默认生成的。 ","link":"https://yueqingsheng.github.io/post/nestjs-hou-duan-dai-ma-zi-dong-sheng-cheng-shu-ju-biao-curd-jie-kou-wen-dang/"},{"title":"青春有你2 评论分析拓展","content":"2020/4/30 更新 1. 多线程数据爬取 获取视频列表 获取视频列表的url为https://www.iqiyi.com/v_19ryi480ks.html。 即任意一期右侧的正片这一栏。 找到 li标签下 class为play-list-item的data-td属性 需要注意爬取后的列表第一个为预告，可以去掉，这里只爬取所有正片 获取评论列表 接口 url参数： content_id: 视频id 通过上方的的视频列表中获取 last_id: 上个最后的视频id，每次获取完成后，使用最后一个id，作为下次获取的last_id page: 翻页的页数 page_size: 每页评论的个数 upremaining: 1最后一页， 0 后面还有内容 如何获取全部评论 两个思路 检查lastid 是否重复了，说明获取到最后一个 其实返回的data里有一个参数，&quot;upremaining&quot;:0。检查这个为1就可以了。 大部分同学都使用last_id翻页，其实参数里自带page,使用page=1，2，3，4也可以实现翻页 page_size可以设大一点，减少请求次数。最大为40 因为评论数量过多，使用多进程爬取。每一个进程爬取一个视频下的评论,总共花了1分3秒。不用多线程的话，估计要20多分钟。 截至2020日4月29日总共爬取了254287条数据。 2. 数据清洗 发现很多评论里出现多次刷同一个选手名的现象。所以做一下选手名去重，这样能在预测选手成绩时能保证合理性，防止多计算出现次数。 如: 虞书欣虞书欣虞书欣虞书欣虞书欣冲呀！！！ 清洗后为 虞书欣冲呀！！！ 3. 分词 数据请求后, 评论列表不再改变可以转化为tuple使用, tuple的access速度会比list快 使用tuple分词用了 9分3秒，会比list快十几秒。 4. 选手词频统计 经过26万条评论统计，按前20选手姓名出现频率排序 人名去重后，词频少了很多。 根据25号官方排名，前9名内除第9不一样，其他基本吻合。 5. 词云 按照词频显示词云 之前用形状和上色绘制了下词云，但是感觉效果没有原生的好。(这个是基于1000条数据生成的) 6. 节目评价 总体还是正向和中性评价占了绝大多数，95%。 随机打印一点 评价 正向： ['因为看了书欣的电视剧才来看这个的，喜欢她的性格', '我也喜欢左卓', '好喜欢刘雨昕！', '我真的太爱刘雨昕了', '好看好看', '看了这期，真的很心疼喻言', '安崎反差萌真的绝了，好看的颜值和有趣的灵魂她都拥有。', '我也喜欢虞书欣', '虞书欣加油', '冲着虞书欣搞笑视频来的，后面发现太太太多想pick的了。这种模式是看的第一个，努力又融洽的氛围真好。'] 中性： ['乃万！', '乃万', '我要去看男团了拜拜，记得给我点赞', '大家要帮忙投票了吗我这儿还有13票', '大家有要帮忙投票的吗我还有14', '虞书欣', '乃万简直是可盐可甜可rap 可vocal， 随时写词的到处撩妹的博爱艺术家 。', '谢可寅小姐姐要加油喽。', '刘雨昕', '林凡'] 负面; ['刘雨昕你咋不是个男的啊太帅了', '看得累死了磨磨叽叽', '我爱死所有训练生了', '傅如乔 爱死你了', '我就是看美女跳舞的，谁是谁，这个真不关心，长的都挺好看的，挺养眼', ''安琪的肚子真的不好看 感觉肚子肉好多 总喜欢露着腰,'入股不亏', '赵小棠什么鬼哦！', '真失望 为什么不是刘雨欣！ 突然不想看了', '不要脸', '小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！真的很棒！'] 模型把很多人名识别成了中性词，对英文的词性识别可能还不是很好。 有一些负面评价识别还行，但是也有不准的时候。比如“爱死了”， &quot;小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！&quot;可能把呜呜呜识别成负面了。 总结 跟原项目主要区别：多进程爬虫，多视频爬取，选手名去重，list改用tuple 经过爬取所有评论和同一句子人名去重后，发现数据可视化后还是变化挺大的。有很多人一个评论发很多重复的一个人名。 可拓展方面 评论生成，用文本生成模型生成一些青春有你相关的评论。 其实表情也是很好的反映观众心情的label, 也可以做这方面情感分析，finetuning 一下。根据评论生成表情，也会很有意思。 评论中还包括了大量的图片和动图，抓取下来，也可以做一些相应的拓展。 评论的用户信息分析，如地区 生成一个动态直方图，用户根据日期看不同日期的统计变化。参考视频，随便一个视频几万的播放量，我酸了 ","link":"https://yueqingsheng.github.io/post/qing-chun-you-ni-2-ping-lun-fen-xi/"},{"title":"Vue","content":"使用 CDN &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 数据绑定 括号绑定 {{message}} //括号中可使用表达式 如 {{message+ message}} 指令式绑定 &lt;div v-bind:id=&quot;message&quot;&gt;&lt;/div&gt; 简写形式 &lt;div :id=&quot;message&quot;&gt;&lt;/div&gt; 这里我们遇到了一点新东西。你看到的 v-bind attribute 被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title attribute 和 Vue 实例的 message 属性保持一致”。 响应式 可以这样理解：当一个状态改变之后，与这个状态相关的事务也立即随之改变，从前端来看就是数据状态改变后相关 DOM 也随之改变。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。 v-if v-else v-show v-for &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{message}}{{message+ message}} &lt;div :id=&quot;message&quot;&gt;&lt;/div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt; &lt;span v-if=&quot;!item.del&quot;&gt;{{item.title}}&lt;/span&gt; &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{item.title}}&lt;/span&gt; &lt;button v-show=&quot;!item.del&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { message: &quot;Hello World&quot;, list: [ { title: &quot;课程1&quot;, del: false, }, { title: &quot;课程2&quot;, del: true, }, ], }, }); &lt;/script&gt; &lt;/body&gt; 组件 Vue.component(&quot;todo-item&quot;,{ props:{ title: String, del: { type: Boolean, default: false, }, }, template: ` &lt;li &gt; &lt;span v-if=&quot;!del&quot;&gt;{{title}}&lt;/span&gt; &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{title}}&lt;/span&gt; &lt;button v-show=&quot;!del&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; `, data: function(){ return {} }, methods: { }, }) Vue.component(&quot;todo-list&quot;, { template: ` &lt;ul&gt; &lt;todo-item v-for=&quot;item in list&quot; :title=&quot;item.title&quot; :del=&quot;!item.del&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; `, data: function () { return { list: [ { title: &quot;课程1&quot;, del: false, }, { title: &quot;课程2&quot;, del: true, }, ]} } }) 组件中data 不能使用同一个data,因为pass by reference ，在一个地方改变，其他地方也会改变。data要求唯一化。 ","link":"https://yueqingsheng.github.io/post/vue/"},{"title":"第一次神经网络实践","content":"简单总结下教训： 输入，输出 输入就是 a和 b, 输出是c。 First attempt 一开始想把天数，1到28天作为输入，28天的感染人数作为输出。去找 天数和 感染的函数关系。错误的原因，28天只是任意的28天时间段，去强行找 1-28 和感染的关系是不成立的。也没有关系。 Second attempt 用RNN实现，方向是对的。能力不够复现RNN或LSTM(吐槽下，老师说如果要写的话，要从0复现一个，地狱级难度任务) 总结 其实确认输入输出，最重要的就是确立，想找的是什么与什么直接的关系。相互影响的那两个量。题目写的已经很清楚了，用c_t 和 t_pd 预测 c_inf 其中忽视的问题 只看到了cost变大，没有去考虑原因。原因是因为梯度爆炸。梯度爆炸的原因是，输入之间差值太大，呈现exponetial爆炸增长。 ！！！！ 最重要学到的点，什么时候要做归一化，即Normalizition 归一化，在处理奇异值时候特别重要，如果数据存在极大或极小值，会严重影响weight 的收敛。归一化即，把输入和输出限制在同意范围内，如[0,1],映射到同一维度内。 参考:机器学习——标准化/归一化的目的和作用 Anyway, 有空的话，可以用LSTM复现个玩玩。获取一个多维度输入，输出将来的感染人数。直到感染变化为0为止。 ","link":"https://yueqingsheng.github.io/post/di-yi-ci-shen-jing-wang-luo-shi-jian/"},{"title":"Python","content":"Print print 会自动换行，print(end=&quot;&quot;)会取消换行，end为结束后缀 遍历文件 os.walk() Python method walk() generates the file names in a directory tree by walking the tree either top-down or bottom-up. for root,dirs,files in os.walk(path): for fname in files: if filename in fname: result.append([id,fname]) string check contains str = \"Messi is the best soccer player\" >>> \"soccer\" in str True >>> \"football\" in str False 三引号 三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。 print('''I'm going to the movies''') html = ''' &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt; Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt; &lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt; &lt;B&gt;%s&lt;/B&gt;&lt;P&gt; &lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt; &lt;/BODY&gt;&lt;/HTML&gt; ''' print(html) 元组和列表 元组是不可变的， 而列表是可变的。 我们可以修改列表的值，但是不能修改元组的值。 由于列表是可变的，我们不能将列表用作字典中的key。 但可以使用元组作为字典key。 同构与异构 习惯上元组多用于用于存储异构元素，异构元素即不同数据类型的元素，比如(ip,port)。 另一方面，列表用于存储异构元素，这些元素属于相同类型的元素，比如[int1,in2,in3]。 JSON Python list(dict) to json string json.dumps 用于将 Python 对象编码成 JSON 字符串。 import json data = [ { 'b' : 2, 'd' : 4, 'a' : 1, 'c' : 3, 'e' : 5 } ] json = json.dumps(data) print(json) [{&quot;b&quot;: 2, &quot;d&quot;: 4, &quot;a&quot;: 1, &quot;c&quot;: 3, &quot;e&quot;: 5}] json string to python list(dict)_ json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。 import json jsonData = '{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}' text = json.loads(jsonData) #将string转换为dict print(text) 打包并压缩 把当前目录下所有文件打包压缩成a.tar.zip tar -zcvf a.tar.zip ./ 解压 -C 指定目录 tar -zxvf a.tar.zip -C ../ 爬虫 request模块： requests是python实现的简单易用的HTTP库，官网地址：http://cn.python-requests.org/zh_CN/latest/ requests.get(url)可以发送一个http get请求，返回服务器响应内容。 BeautifulSoup库： BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。网址：https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ BeautifulSoup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml。 BeautifulSoup(markup, &quot;html.parser&quot;)或者BeautifulSoup(markup, &quot;lxml&quot;)，推荐使用lxml作为解析器,因为效率更高。 通过tag标签逐层查找: soup.select(&quot;body a&quot;) 获取属性 tag.get('href') 或者 tag['href'] 如果不确定某个属性是否存在时,用 tag.get('attr') 方法去获取它,跟获取Python字典的key一样 tag['class'] KeyError: 'class' print(tag.get('class')) None link = star['link'] headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } #！！！请在以下完成对每个选手图片的爬取，将所有图片url存储在一个列表pic_urls中！！！ pic_urls = [] response = requests.get(link,headers=headers) #将一段文档传入BeautifulSoup的构造方法,就能得到一个文档的对象, 可以传入一段字符串 soup = BeautifulSoup(response.text,'lxml') pic_list_url = soup.select(&quot;.summary-pic a&quot;)[0]['href'] tags1 = soup.select('div .shixian_zhaobiao') tag1 = tags1[0] tag2 = tag1.find(name = 'dl') tags2 = tag2.find_all(name = 'a') jsonp to json response_json = response[ response.index(&quot;(&quot;) + 1 : response.rindex(&quot;) } catch&quot;)] 或者get请求的时候，去掉callback=,则会返回json 动态请求 如果数据是动态加载，可以在浏览器network里查看请求的api 写入文件 With the &quot;With&quot; statement, you get better syntax and exceptions handling. &quot;The with statement simplifies exception handling by encapsulating common preparation and cleanup tasks.&quot; In addition, it will automatically close the file. The with statement provides a way for ensuring that a clean-up is always used. with open('output.txt', 'w') as file: # Use file to refer to the file object file.write('Hi there!') with 省去写exception handler和close file pandas dataframe cut 将age按0-5，5-20...bins 分成 既几部分，label为[婴儿，青年...] ages = np.array([1,5,10,40,36,12,58,62,77,89,100,18,20,25,30,32]) #年龄数据 pd.cut(ages, [0,5,20,30,50,100], labels=[u&quot;婴儿&quot;,u&quot;青年&quot;,u&quot;中年&quot;,u&quot;壮年&quot;,u&quot;老年&quot;]) 参考 value_counts df.value_counts() 以Series形式返回指定列的不同取值的频率,默认按频率从高到低排序 groupby df['name'].groupby(df['zone']) s = grouped.count() zone 中国上海 5 中国北京 9 df = pd.DataFrame({'Animal': ['Falcon', 'Falcon', 'Parrot', 'Parrot'], 'Max Speed': [380., 370., 24., 26.]}) df Animal Max Speed 0 Falcon 380.0 1 Falcon 370.0 2 Parrot 24.0 3 Parrot 26.0 df.groupby(['Animal']).mean() Max Speed Animal Falcon 375.0 Parrot 25.0 matplot size plt.figure(figsize=(12, 12)) %matplotlib inline %matplotlib inline 可以在Ipython编译器里直接使用，功能是可以内嵌绘图，并且可以省略掉plt.show()这一步 pie 参数： x :(每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化； labels :(每一块)饼图外侧显示的说明文字； explode :(每一块)离开中心距离； startangle :起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起； shadow :在饼图下面画一个阴影。默认值：False，即不画阴影； ## draw pie labels = [&quot;45-50kg&quot;,'&lt;45kg','50-55kg','55kg'] plt.pie(weightsfreq.values, explode=(0.1,0.1,0.1,0.1),labels=labels, shadow=True,autopct='%.2f%%',startangle=90) plt.axis('equal') plt.legend(loc=&quot;upper right&quot;,fontsize=10,bbox_to_anchor=(1.1,1.05),borderaxespad=0.3) plt.title('''《青春有你2》选手体重分布''',fontsize = 10) plt.savefig('/home/aistudio/work/result/bar_result03.jpg') 参考 正圆 plt.axis('equal') string format python &gt;3.6 &gt;&gt;&gt; name = 'hoxis' &gt;&gt;&gt; age = 18 &gt;&gt;&gt; f&quot;hi, {name}, are you {age}&quot; 'hi, hoxis, are you 18' 百分号 %%表示百分号 &gt;&gt;&gt; print('数据的比例是:%.2f%%' %(scale * 100)) 数据的比例是:10.00% &gt;&gt;&gt; print('数据的比例是:%d%%' %(scale * 100)) 数据的比例是:10% 参考 词云 根据词频绘制词云图 参数 word_f:统计出的词频结果 # 生成对象 mask = np.array(Image.open(&quot;alice_mask.png&quot;)) wc = WordCloud(mask=mask, font_path='SimHei.ttf', mode='RGBA', background_color=None) wc.fit_words(word_f) # 显示词云 plt.imshow(wc, interpolation='bilinear') plt.axis(&quot;off&quot;) plt.show() # 保存到文件 wc.to_file('wordcloud.png') matlibplot 加载中文字体 #下载中文字体 wget https://mydueros.cdn.bcebos.com/font/simhei.ttf #在操作系统中创建字体目录fonts（可能已经有 mkdir .fonts # 复制字体文件到该路径 cp simhei.ttf .fonts/ #复制字体到当前使用的conda环境中的matplotlib下的指定路径 cp simhei.ttf /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/matplotlib/mpl-data/fonts/ttf/ # Linux系统默认字体文件路径 ls /usr/share/fonts/ # 查看系统可用的ttf格式中文字体 fc-list :lang=zh | grep &quot;.ttf&quot; # 设置显示中文 matplotlib.rcParams['font.san-serif'] = ['SimHei'] # 解决负号'-'显示为方块的问题 matplotlib.rcParams['axes.unicode_minus'] = False 如果没成功，尝试 from matplotlib.font_manager import _rebuild _rebuild() #reload一下 jieba 分词 jieba.load_userdict('name.txt') #name.txt 为用户自定义分词 seg = jieba.lcut(text,cut_all=False) 停用词 stopwords = [line.strip() for line in open(file_path, encoding=&quot;UTF-8&quot;).readlines()] for word in sentence: if word not in stopwords: if len(word) &gt; 1: counts[word] = counts.get(word, 0) + 1 字典 .get(key,value) value为如果不存在返回的值，counts.get(word, 0)： word不存在于counts中则返回 0 中文常用停用词词表 多进程 多进程共同的全局变量，需要使用特殊方式声明： from multiprocessing import Process, Value, Array, Manager def f(n, a): n.value = 3.1415927 for i in range(len(a)): a[i] = -a[i] if __name__ == '__main__': num = Value('d', 0.0) arr = Array('i', range(10)) lis = Manager().list() p = Process(target=f, args=(num, arr)) p.start() p.join() print(num.value) print(arr[:]) 多进程list 使用前需转换回普通list， list(lis) .join() 可以等待进程执行结束后再输出 多进程的一个大坑：broken pipe 解决方案不要在主线程外使用shared object,这样主线程使用的时候修改，会影响子线程的这个object 解决方案：移除主线程的修改，或者把修改放到子线程跑完之后 解释 .join() 主线程等待子线程跑完。python默认是先执行完主线程 process= [] for c_id in content_ids: # 每个进程爬取一个视频下的评论 p = Process(target=getMovieinfo,args=(c_id,)) process.append(p) p.start() #等待所有线程任务结束。 for p in process: p.join() print(&quot;总共获取了&quot;,len(comments),'条评论') 这样主线程就会阻塞了 参考 ","link":"https://yueqingsheng.github.io/post/python/"},{"title":"Day 18","content":"[x] lecture 28 [x] lecture 29 [ ] lecture 30 TODO vector embeddings [x] lecture 31 cs489 蛮有意思的，neuro science 从头贯穿到尾，讲neural network 的起源，和各种机制设置的原因。整个学期其实就一个Model, 就是人脑神经。从脑科学的角度改进network和思考大脑是如何解决某项任务的，如视觉系统。 ","link":"https://yueqingsheng.github.io/post/day-18/"},{"title":"Day 17","content":" code: chat vue vue 看了 react angular文档，太复杂了。转vue了。 ","link":"https://yueqingsheng.github.io/post/day-17/"},{"title":"Day 16","content":" code: chat 课程价格 评价 评分 今天 windows, mysql 直接抽了，不知道为啥，完全不听typeorm的改动，我服了。本来半天能写完的代码，硬是debug一天。结果发现是数据库的问题。 ","link":"https://yueqingsheng.github.io/post/day-16/"},{"title":"Day 15","content":" code: chat code: morning 订单 课程价格 评价 订单表设计： 类型： 课程， (谈一谈)talk, 要传 图片 课程标题： 订单的话用课程号区分吧，定为timestamp ok, tradeno class: 关系 counselor: 关系 标题 body, 图片服务器根据type和body查找订单，存储Image和关系 订单评价： 评价： comment 包含 counselor, course 里有评价, counselor里 eager， 流程就按post里走 评分： 每次评价都创建一个即使为空，按 （原来的+new）/总数 课程价格： price class ， 包含 几天 ","link":"https://yueqingsheng.github.io/post/day-15/"},{"title":"Day 14","content":" Angular 起步2 Angular 表单 Angular 路由 Angular 守卫 Angular 异步路由 code: chat code: morning 小细节：修改了首页图标跳转 ","link":"https://yueqingsheng.github.io/post/day-14/"},{"title":"Day 13","content":" Angular 起步1 code: chat code: morning ","link":"https://yueqingsheng.github.io/post/day-13/"},{"title":"Day 12","content":" Angular Components 略微修改了主题，简化了标题下的header，以及返回按钮（加粗），有空加个返回顶部 配置了vscode 实现了 terminal 和 editor 全部自动化 和代码高亮主题 code: chat code: morning ","link":"https://yueqingsheng.github.io/post/day-12/"},{"title":"Day 11","content":"充满希望的春天来了。😉 code: chat code: morning A5 done Angular start 白天把作业写完了，晚上写了会angular,配置了插件。prettier(格式化) 和 angular essential（待学习），配置了下主题。 抽空排一下温柔的歌单吧。 ","link":"https://yueqingsheng.github.io/post/day-11/"},{"title":"Angular","content":"为什么js推荐使用单引号 单引号和多引号区别，没啥区别，单引号编译速度更快，而且单引号内可以使用双引号，有时候内部是json 格式必须用双引号 中文解释 模块 创建模块post 放在 modules/post 下 ng generate module modules/post componet 是生成的html 和css,ts 文件 模块导入 需要导出的模块在module 的 exports中添加，exports: [PostComponent], 引用的模块导入：imports: [PostModule], 数据绑定 在component.ts 内声明 .html 使用{{值}} *ngFor *ngfor 会自动扩展成 &lt;ng-template ngfor&gt; *是一种语法糖，缩写形式 &lt;li *ngFor=&quot;let entity of entities&quot;&gt; &lt;h4&gt;{{ entity.title }}&lt;/h4&gt; &lt;/li&gt; *ngIf &lt;p *ngIf=&quot;entity.body&quot;&gt;{{ entity.body }}&lt;/p&gt; 属性绑定 &lt;a title=&quot;{{ entity.title }}&quot; &gt;{{ entity.title }}&lt;/a&gt; &lt;a [title]=&quot;entity.title&quot;&gt;{{ entity.title }}&lt;/a&gt; 第二种形式可以绑定标签不存在的属性值 如 text-content, Angular 官方文档在绑定属性几乎都是使用[]，而插值表达式{{}}更多是用于显示，两者最大的区别就是后者会将{{}}语句里执行完的值再转换string 类型。 事件绑定 &lt;button (click)=&quot;removeItem(i)&quot;&gt;Remove&lt;/button&gt; 参数直接填就行 双向绑定 Module import { FormsModule } from '@angular/forms'; // &lt;-- NgModel lives here app.module.ts (@NgModule imports) content_copy imports: [ BrowserModule, FormsModule ], &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt; [(ngModel)] 是 Angular 的双向数据绑定语法。 这里把 hero.name 属性绑定到了 HTML 的 textbox 元素上，以便数据流可以双向流动：从 hero.name 属性流动到 textbox，并且从 textbox 流回到 hero.name 。 父子组件 父传子 传递数据， 父组件ul, 数据为entities在父组件内， 必须在子部件属性内赋值， 子部件使用@Input,， //@Input 此命令用来修饰属性是用来接收父组件传递的值 参考 有兴趣了解下单向数据流 angular 更新view，是在model更新阶段进行，不是model生成view阶段。 &lt;ul&gt; &lt;app-post-item *ngFor = &quot;let entity of entities&quot; [entity] = entity&gt; &lt;/app-post-item&gt; &lt;/ul&gt; 子传父（function） This example features an &lt;input&gt; where a user can enter a value and click a &lt;button&gt; that raises an event. The EventEmitter then relays the data to the parent component. 子部件 @Output() newItemEvent = new EventEmitter&lt;string&gt;(); addNewItem(value: string) { this.newItemEvent.emit(value); } &lt;button (click)=&quot;addNewItem(newItem.value)&quot;&gt;Add to parent's list&lt;/button&gt; 父部件 &lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;&lt;/app-item-output&gt; The event binding, (newItemEvent)='addItem($event)', tells Angular to connect the event in the child, newItemEvent, to the method in the parent, addItem(), 路由 basics app-routing.module.ts const routes: Routes = [{ path: 'posts', component: PostComponent }]; router link &lt;a [routerLink]=&quot;['/posts', entity.id]&quot; [title]=&quot;entity.title&quot; [textContent]=&quot;entity.title&quot; &gt;&lt;/a&gt; import from app-routing module paramMap constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.route.paramMap.subscribe((params) =&gt; { const postId = +params.get('id'); console.log(postId); }); Model 标记可选属性使用问号 body? 服务 @Injectable({ providedIn: 'root' }) root表示在任何位置可以使用 注入 componet.ts constructor(private postService: PostService) { this.entities = posts; } 表单 看这个文章，更详细点 pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 演示： 这是一个pre标签 哈 哈 formBuilder registerForm = this.formBuilder.group({ username: ['', Validators.required], password: ['', [Validators.required, Validators.minLength(6)]], }); ","link":"https://yueqingsheng.github.io/post/angular/"},{"title":"nestjs的坑","content":"不定期更新 变量名 变量命名时尽量不要用type, class 这些名称，以免用的时候，报一些奇怪的错误。编译器不知道是，自定义的名，还是语法里的意思。comment 也是关键字，需自己导包，我也是服了。 eager eager 谨慎使用，特别是relation有相互包含的时候。必须只能加在一边，防止重复包含，导致stack overflow。 eager 只会在find里生效,querybuilder 必须join find find 有很多选项足够用了可以代替 queryBuilder OneToMany Save 例子： 商品储存多个价格， data 是发送的商品数据，其中包含了price data.price = await this.priceRepository.save(price); data = await this.repository.create(data); return await this.repository.save(data); 注意 data.price 这一步是必须的，是为了更新刚储存完的id号，typeorm 用id 来建立关系 环境变量 process.env. 在for root里不好使，即使在main.ts里提前执行了config()。 非 for root 使用 require('dotenv').config() rocess.env. for root 使用 aynscfor root 在服务器更新 .env 文件 ##数据库更新 typeorm 更新的很随缘，如果发现数据格式不符bug。可以把dist文件夹删了 重跑一遍。 如 enum更新，或Column type更新 typeorm 从 entity.js 读取column 信息。 Controller 切记不要写这种路径 Get(':id') Get('user') Swagger paramter 参数必须声明类型，swagger才能识别到 nestjsx/crud 版本最好4.6.0， 4.5同时get by id和relation会报sql syntax error ","link":"https://yueqingsheng.github.io/post/nestjs-de-keng/"},{"title":"Day 10","content":" lecture 27 lecture 28 lecture 29 lecture 30 code: chat code: morning A5 1done 2a 差解释 明天上午大概就能写完作业了，有空把population 图画一下，还挺有意思的。开始学angular ","link":"https://yueqingsheng.github.io/post/day-10/"},{"title":"Day 9","content":" lecture 24 lecture 25 lecture 26 lecture 27 lecture 28 lecture 29 code: chat code: morning 公司网站推广配置 睡眠1-11点，早上8点接了个电话又睡着了。看来调整生物钟不是一天的事情，早睡早起后依然很困。 最近不知道怎么了，每天把自己弄得很累。不知道什么时候开始，分给她的时间很少。可能是潜意识认为，不会再分开了，没有关心到她。挺自责的。感觉自己好像远远没开始那么努力了，虽然一直喜欢他，但是聊的越来越少。 其实这么多年都，没法放下。我也很想，这种状态下去，但有时候觉得只是表面的假象。这段恋爱都是自己骗自己，因为见不到面。每次分手和好原因大致相同，都还是回到原地。应该拿出一段时间，回国去陪她。做个计划吧。 今天听课放的视频，训练猴子操作手柄游戏，用电脑建立模型，然后让电脑模仿猴子操作游戏，还蛮有意思的（encode step, known X and A）。之后通过相关神经元的刺激，就可以得知猴子在想什么了(decode step)。(know A and output X, try to minimize least squre of DA-X, to get D, i.e weight of decoding) ","link":"https://yueqingsheng.github.io/post/day-9/"},{"title":"Pull request（第一次参与开源项目）","content":"学了CSS 和 html 基础，突然想起来前几天给主题作者提的意见，他刚好比较忙，那能不能我自己改下呢，嘿嘿。 fork 项目到自己git 下 git remote add upstream https://github.com/QibaiAluminum/EKT.git 添加源项目链接 push 改动 到github 提交 pull request ","link":"https://yueqingsheng.github.io/post/pull-requestdi-yi-ci-can-yu-kai-yuan-xiang-mu/"},{"title":"Day 8","content":"每天 TODO list 新增计划： code: chat code: morning 今天心情不好啊，效率有点低。 接下来几天要先写AI作业了，网站开发先放一下。 ","link":"https://yueqingsheng.github.io/post/day-8/"},{"title":"Day 7","content":" nestjs 配置好微信支付，这文档神坑，真的服了，使用插件 notadd-pay, 参考配置文章 nestjs 配置好微信支付，这文档神坑，真的服了，使用插件 notadd-pay, 参考[配置文章](https://blog.csdn.net/ZChangfeng/article/details/78899618) 设计了订单库 设置了付款及退款的返回 修复bugs ","link":"https://yueqingsheng.github.io/post/day-7/"},{"title":"docker 自动化脚本配置","content":" clone https://github.com/YueqingSheng/auto-deploy.git 在主目录下编写脚本 在 routes/index.js 下添加接口 参考Route这里 push 服务器 脚本添加权限 forever restart ./bin/www TODO: 自动化 4-6步 By webhook spawn exec方法 在 node.js child_process模块中的应用及区别 解决 Error: maxBuffer exceeded docker logs－查看docker容器日志 ","link":"https://yueqingsheng.github.io/post/docker-zi-dong-hua-jiao-ben-pei-zhi/"},{"title":"javascript cheatsheet","content":"DOM（文档对象模型） 文档树： each label is a node in the tree getElementById document.getElementById('page-title') getElementsByTagName document.getElementsByTagName('li') querySelectorAll querySelectorAll('.class a') 返回所有 querySelector 返回找到的第一个 访问属性 e.nodeName 标签名 e.innerText 内部文字 e.paretnNode 父节点 e.nextElementSibling 下一个兄弟元素 previousElementSibling e.childNodes 子节点 e.childElementCount 返回子节点数量 e.firstELementChild 第一个子节点 e.lastELementChild 最后一个子节点 修改 用=赋值 创建新的节点 步骤： var newMember = document.creatElement('li') var text = document.createTextNode('你好啊'); newMember.appendChild(text) document.querySelector('#list').appendChild(newMember) 添加到最后 insertBefore 插入到特定位置 countrylist.insertBefore(newMember, countrylist.firstChild) 修改CSS document.getElementById(id).style.property=新样式 事件 onclick=JavaScript <!DOCTYPE html> 点击文本! 绑定函数 &lt;p&gt;点击按钮执行 &lt;em&gt;displayDate()&lt;/em&gt; 函数.&lt;/p&gt; &lt;button onclick=&quot;displayDate()&quot;&gt;点这里&lt;/button&gt; &lt;script&gt; function displayDate(){ document.getElementById(&quot;demo&quot;).innerHTML=Date(); } &lt;/script&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; onload onunload onload 和 onunload 事件会在用户进入或离开页面时被触发 onmouseover 和 onmouseout 事件 onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 JavaScript HTML DOM EventListener document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate); ","link":"https://yueqingsheng.github.io/post/javascript-cheatsheet/"},{"title":"Day 6","content":"PR 通过了 哈哈，接下来有时间的话可以简单魔改下主题 start angular AI 作业 ","link":"https://yueqingsheng.github.io/post/day-6/"},{"title":"Day 5","content":" js 基础 魔改下主题，添加封面图 start angular 很难坚持下去啊，第5天了，各种事会干扰一下，效率明显没有前几天高了。考虑下早睡早起？ 可能会提高些效率。 ","link":"https://yueqingsheng.github.io/post/day-5/"},{"title":"Day 4","content":" nestjs 配置微信支付 css课程 part2 浮动 css课程 part3 盒子 css课程 part4 定位 对CSS 课程的评价: 一共选择了三种课，首先考虑阿里云大学CSS, 发现换了html的导师，每个视频30多分种，实在不想看下去。就是找了源html老师的视频，下载后发现每个视频三四分钟，够短了，讲的也很好，可是分了几百个视频。。。。迫于时间紧迫，转投宁皓网，一直喜欢他的课的原因就是够简练，缺点就是过去简练了，很多东西都一笔带过。还是要结合html老师的课和网上资源来看。 课程链接： 满幽默的，分集太多 + ninghao够简练，过于简练。。 CSS 练习 链接 查看方式 在这个链接https://htmlpreview.github.io/?https://github.com/YueqingSheng/build_a_blog_from_scratch/blob/master/css/尾部加入标签文件名，文件名列表如下： 如： 想查看background.html这个例子，点这个链接 csss的解释在CSS cheatsheet下 ","link":"https://yueqingsheng.github.io/post/day-4/"},{"title":"CSS cheatsheet","content":"目的 结构样式相分离, html只做结构，css做样式 h1 { color: orange; } p { color: pink; } 字体 font-size font-family 支持汉字， 默认14px microsoft yahei， 尽量使用偶数号，各种字体用逗号隔开 &quot;微软雅黑&quot;,arial, sans-serif 按顺序没有的话往后找 如果字体内包括 空格 #$ 需要加引号 尽量使用默认字体 Unicode 字体 不支持中文字体的时候，使用Unicode代替 font-weight normal bold bolder lighter, 100-900 100的整数倍 font-style normal italic 综合字体样式 {font: font-style font-weight font-size font-family;}必须按顺序 前面可以省略，必须包括 font-size 和 font-family 注释 快捷键 ctrl + / 或者 /* 注释*/ 选择器 标签选择器 p{ } div{ } 标签作为选择器 类选择器 .类名{属性：属性1 } &lt;div class=&quot;类名&quot;&gt; 命名规则 相应的效果 或者主体名 （见名知义） 多类名选择器 &lt;div class=&quot;font20 pink&quot;&gt; id选择器 #class{ } &lt;div id=&quot;class&quot;&gt; class选择器和id选择器区别 类选择器是可以重复多次使用的，如人名 id选择器好比身份证，是唯一的 通配符选择器 *{ *代表所有选择器 color: red; } &lt;div id=&quot;class&quot;&gt; 伪类选择器 链接伪类 主要针对于&lt;a&gt; 简写方式 a{} a:hover{} 派生选择器 比方说，你希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： li strong { font-style: italic; font-weight: normal; } 群选择器 #main, #header{ main 跟 header 共同的样式 } 样式 内嵌样式 &lt;h2 style=&quot;color:green&quot; &gt;测试&lt;/h2&gt; 外部样式 &lt;link rel=&quot;stylesheet&quot;样式表 href=&quot;outside_style.css&quot; type=&quot;text/css&quot; /&gt; CSS 特性 继承 内部标签会继承外部内部的样式 不是所有的属性都会被继承，如边框，边距 层叠 内部标签会叠加所有外部的样式， 如果外部样式有冲突，继承离最近的外部标签，或者当前定义的样式 标签&lt;类 &lt;id &lt;行内样式 行内style，派生选择器会累计分数，#mainbody h2 101 盒模型 小技巧： margin:0 auto; (上下边距0，左右边距自动，即居中) 浮动 img style=&quot;float:right;margin-left:20px;margin-bottom:20px h2 style=&quot;clear:both&quot; 背景 background: url(b.jpg) ; 定位 position: absolute;right:0;top:0: ","link":"https://yueqingsheng.github.io/post/css/"},{"title":"Day 3","content":"Today Do list 给自己网站加个歌单吧，插件只能一首一首手动输入，那就慢慢加吧。新加了一首 css课程 part1 字体 选择器 css 内容太多了， 明天再学一部分，就开始angular了。挖个坑。 忽然发现css 可以在markdown内用，把文章改的很好看，那就用上了。 h1 { color: orange; } p { color: darksalmon; } ","link":"https://yueqingsheng.github.io/post/day3/"},{"title":"Today's little fun","content":" h1 { color: orange; } 闲着没事，把Gridea主题商店逛了下,发现了个很好看的免费主题啊，点这里，配置了一下博客完全焕然一新啊，云养猫，计划通。 顺藤摸瓜找到了源作者的博客，和他模仿的源源作者的博客（俄罗斯套娃）， 源作者 源源作者 很漂亮啊，跟我的审美差不多（臭不要脸） 再就是很羡慕，这些能把自己的技术转换成实际生产力的人啊，为了兴趣而写代码，看看他们写的博客，再看看自己。。。还是要努力啊。希望自己有天也有能力，能实现自己想做的想法。 另外，源作者网站的音乐很好听啊，我直接copy到我的网站上了，哈哈，有兴趣可以听听，我循环了一晚上。 ","link":"https://yueqingsheng.github.io/post/todays-little-fun/"},{"title":"Day 2","content":"Today Do list 添加 html 链接, github html课程 1-10 html课程 11-20 html课程 21-33 html就是种书写格式，学了markdown, latex，再加上这个的我一脸懵逼，这种不就是用的时候查下表就行的么。吐槽下一种行业一种写法，能不能统一下。。 肝完了 yes!🤣 明天开始肝css了，还要简单学下数据绑定，就开始学angular了。 html 下demo 查看方法 对每种html标签都写了例子，查看方式 在这个链接https://htmlpreview.github.io/?https://github.com/YueqingSheng/build_a_blog_from_scratch/blob/master/html/尾部加入标签文件名，文件名列表如下： 如： 想查看image.html这个例子，点这个链接👇 https://htmlpreview.github.io/?https://github.com/YueqingSheng/build_a_blog_from_scratch/blob/master/html/image.html html标签的解释在html cheatsheet下 ","link":"https://yueqingsheng.github.io/post/day-2/"},{"title":"简单总结下我的全栈学习路线","content":"加油，加油！😄 前端 前端学习中不用刻意去记一些东西，记好笔记（或者直接用我的），到时候查就行了。理解优先 课程选择： html 阿里云大学 css 课程链接： 同一个老师，分集太多，学第一部分到选择器然后转宁皓网就行 + ninghao够简练，过于简练。。 js: 宁皓网 新手推荐这个系列 框架： angular因为我后端用的是nestjs angular去屎吧, vue万岁！ vue推荐极客大学 推荐工具 有些课历史比较久了，所以开发工具有点老，推荐开发工具vscode +插件： VScode 插件推荐 open in browser(写完代码，直接 ctrl+s 保存 ，alt+b 浏览器打开超方便) tabnine+ autoimport + auto close tag （以上三个全是自动补全） prettier (自动格式化代码) angular essential(插件包) Settings Sync 在不同设备同步设置插件 终端推荐使用zsh windows 配置方法： 安装bash, wsl 安装oh-my-zsh bash 内设置默认shell为zsh 下载必要组件如 node npm 在vscode 里配置默认shell 为 wsl html,css 自动补全 (有兴趣可以了解下, 用习惯了开发效率很高) Emmet 可以用缩写写标签和属性 其他 github 这个必须要有啊，懂得都懂 强烈建议写个博客网站，原因么，很多，一个是云端保存笔记，一个是可以使用Markdoｗｎ, markdown 内部可以使用html.css 语法，边学边写。（另外个原因，可以自己魔改网站啊，很有动力，学以致用） 0基础搭建博客 推荐这个 Gridea 后端 目前学习计划是 后端nestjs（mongodb + graphql +exception handler+ environment storage），相当于重写一遍后端了，现在后端写的太乱。 下一步就是学 pandas ,numpy 基础 + 爬虫+ pytorch or tf 学习整理数据。 ","link":"https://yueqingsheng.github.io/post/jian-dan-zong-jie-xia-wo-de-wang-zhan-xue-xi-lu-xian/"},{"title":"Day 1","content":"Why? 为什么要写个博客网站呢？ 理由很简单，也很自然，代码敲的多了，学习过程中，有很多东西容易忘，学习记的笔记需要找个地方存放下来。本地的话，不方便查阅和备份。刚好最近在学习angular+ nestjs 技术栈, 那就用它搭个网站吧。 About this site 这个网站目前是临时的，只是记录下搭建博客网站的历程，其中学习的东西和笔记，也会先传在这里记录一下。 About that site 目前定下的技术栈为 angular+ mongodb+ graphql + nestjs ， maybe websocket and microservices。如果感觉能用上也可以。 Today Do list nestjs 试了下 websocket 搞了个简易聊天室还蛮好玩的。https://ninghao.net/course/7990#toc 使用Gridea 搭了这个网站 https://gridea.dev 添加了评论 找个好用的Markdown 编辑器 , 暂时使用Gridea 编辑 开始学习html, css https://developer.aliyun.com/course/1742 老师贼搞笑，说要把浏览器当成女朋友🤣 ","link":"https://yueqingsheng.github.io/post/day-1/"},{"title":"html cheatsheet","content":"html 转义工具 here Basics The visible part of the HTML document is between &lt;body&gt; and &lt;/body&gt;. &lt;html&gt; 根标签 &lt;head&gt; 头标签 &lt;title&gt;&lt;/title&gt; 标题标签（网站标题） &lt;/head&gt; &lt;body&gt; 主体标签 &lt;/body&gt; &lt;/html&gt; example 快速生成 html:5 或者 ! 单标签 &lt;label /&gt; &lt;br /&gt; 多标签 &lt;lable&gt; 内容&lt;/label&gt; 关系 嵌套 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;/html&gt; 并列 &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; 文档类型 &lt;!DOCTYPE&gt; 声明 html 版本 &lt;!DOCTYPE html&gt; : html5 html5向下兼容其他版本 &lt;meta charset=&quot;UTF-8&quot;&gt; 字符集 标题 &lt;h1&gt; 到 &lt;h6&gt; 段落 &lt;p&gt; 分段，自动换行 水平线标签 &lt;hr/&gt; horizontal 换行 &lt;br/&gt; 段落会自动空出间隔 div span 网页布局 &lt;div&gt; &lt;span&gt; 文本格式化 加粗 important text 斜体 emphasized 删除线 deleted 下划线 inserted 标签属性 key=&quot;value&quot; 图像标签 &lt;img src=&quot;wo.jpg&quot;/&gt; 链接标签 &lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; 锚点定位 &lt;a href=&quot;#go&quot;&gt; &lt;h3 id=&quot;go&quot;&gt; base标签 &lt;head&gt;&lt;base target=&quot;_blank&quot; /&gt;&lt;/head&gt; 所有链接以新窗口打开 特殊字符 注释标签 &lt;!--注释--&gt; 无序列表 &lt;ul&gt; &lt;li&gt;elements&lt;/li&gt; &lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;elements&lt;/li&gt; &lt;/ol&gt; 自定义列表 &lt;dl&gt; &lt;dt&gt;elements&lt;/dt&gt; &lt;dd&gt;subelements&lt;/dd&gt; &lt;/dl&gt; ","link":"https://yueqingsheng.github.io/post/html-cheatsheet/"},{"title":"markdown cheatsheet","content":"行内代码 &lt;html&gt; &lt;head&gt; &lt;title&gt;多行代码，第一行反引号后面，输入代码块所使用的语言，实现代码高亮&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 上方是☝️分割线 斜体 斜体 加粗 done to do &lt; 转义字符&gt; html 转义工具 here 区块 这里 第一层嵌套 第二层嵌套 ","link":"https://yueqingsheng.github.io/post/markdown-cheetsheet/"},{"title":"关于","content":"最近想用 angular + mongodb + graphql + nestjs 搭个网站，在这里记录下流程 反正也没人看，就写点自己想写的东西吧。😊 网站图片来源 ","link":"https://yueqingsheng.github.io/post/about/"}]}