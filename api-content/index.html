{"posts":[{"title":"GRE 数学","content":"错题整理 Which of the two quantities is greater? Quantity A: 35,043×25,430 Quantity B: 35,430×25,043 Explanation:If we have two pairs of numbers, and both pairs add up to the same total, then the pair with the larger product will be the pair that's closer together. So the answer is the first pair. (This picture might help: if you want a rectangle with a fixed perimeter to have the biggest possible area, you want it to be a square.) 周长为固定及和为固定时，边长接近的面积(乘积)最大 To fill a larger concert hall, a madrigal singing group consisting of sopranos, altos, and basses, in a 5:7:3 ratio, needs 40 singers. What is the least number of basses the group will need? The ratio is : 5 singers, 7 altos , and 3 basses AND you know there are at least 40 singers. Using the unknown multiplier which is the sum of the ratios or 15 X Now, 15 divided for the first ratio 5 is 3. So you must have 3 times ALL the elements present in the group. The least number of singer we said that is 40. As a matter of fact, this is confirmed by 15*3=45. (the questions tell you that you do have 40 ≥≥ singers. 7*3 = 21 (≥≥) and 3*3= 9 (≥≥) The answer is 9, 注意按比例要45个不是40个 计算时差 A并B并C＝A+B+C-(AB+AC+BC)+ABC. ","link":"https://yueqingsheng.github.io/gre-shu-xue/"},{"title":"GRE 笔记4 填空51-98","content":" 填空技巧：填空三选，如果一个正面，一个负面，一个中性，排除中性。如果两个正向，或两个负向，一般是选另外一个。 53.loath 不情愿的 54.第二空对应competing 同义词 58.defined 清晰的， scientifc 是正向的，一般不会100%错。 63. 英国人口构成{北欧三国（斯堪的纳维亚Scandinavian）欧洲：法国，荷兰英国人口构成 \\begin{cases} 北欧三国（斯堪的纳维亚 Scandinavian）\\\\ 欧洲：法国，荷兰 \\end{cases}英国人口构成{北欧三国（斯堪的纳维亚Scandinavian）欧洲：法国，荷兰​ one theory: theory of everything, String theory and M-theory have been proposed as theories of everything. 71.finding 新的发现 Although + 否定词（not, counterintutive） 转折前后取同 80.strait 海峡，churlish=rude, admire 赞赏 ~= credit 名誉 82.scientific 伽利略之后时期（靠观测，实验）， Aristotle 古代科学（纯理论） 84.alleged 声称的 = fake 87.selective 认真挑选过的 对应 assembled detail for all =despite while not/ although not/ 程度不同的取同 protoscience -&gt; modern science transformative = mindblowing = new view toll 通行费 substaintial 大量的 三空题，注意第三个空可能会重复之前空或者文章意思。 ","link":"https://yueqingsheng.github.io/ytjfWdszp/"},{"title":"GRE 笔记2 填空1-50 单词和常识","content":" Tips for TC Do not merely try to consider each possible combination of answers; doing so will take too long and is open to error. Instead, try to analyze the passage in the following way: 1. Read through the passage to get an overall sense of it. 2. Identify words or phrases that seem particularly significant. 3. Think up your own words for the blanks. 4. Do not assume that the first blank is the one that should be filled first. 5. Double-check your answers. 2.Humanitarian emergencies 人道主义救援 rather 后不跟 than 时后可省略 resign to 屈服 （阅读时可省略）联想记忆： Trump resign to 学校抗议遣返。 Math review 复习时看OG 5.language instinct 和 viusal engineer 相同，表示两个状态同时存在，和后面 think of language 和 of instinct 分别的两个观点对立 7.protoscientific 词根：第一，原始的 protoscience 和 modern science分界点， Galileo （伽利略）通过observation 木星，推翻地心说。 at all 一点 supreme court 最高法院 supremacy 霸权 quantum supremacy 量子霸权 两句话时间对比 8.promise 前途 希望 remote sensing 遥感是指非接触的，远距离的探测技术。一般指运用传感器/遥感器对物体的电磁波的辐射、反射特性的探测。 sites 遗址 Archaelogy 考古学 12.一些伦理学家担心，更深入地理解大脑也许无异于为某些行为开脱。如果我们发现自由意志只是神经回路系统制造的一种假象，要如何令人们为自己的行为负责? 如果人类发现自由意志是假的就不会控制自己的行为了，找到理由开脱。 词根: ex = not , culp = criminal exculpation = 脱罪 culprit 犯罪的人 14.Thought not 让步转折， 不是那么强烈，还是很强烈 如果选 unbounded的话，就会变成，“Though 不是强烈到没边了，还是太强烈以至于“ 强烈到没边（unbounded） 和 great 形成程度取反关系。类比一下，小明跑步虽然不是世界上最快的，还是太快以至于一般人追赶不上。 18.sluggish = lazy 19.motley 混杂的，assortment 各种各样，混合物 -&gt; 相反对于 monolithic 单一的 20.founders 创立人 &gt; 美国开国元勋（英语：Founding Fathers of the United States）是指签署《美国独立宣言》和《美国宪法》的政治领导人以及参与美国革命的领袖，又译作建国先贤。约翰·亚当斯、 本杰明·富兰克林、亚历山大·汉密尔顿、约翰·杰伊、托马斯·杰斐逊、詹姆斯·麦迪逊和乔治·华盛顿. concur 赞同 in their own views, in reality 对比 23.by virtue of = because of 由于 incisivive 准确的 = right priori assumption = cliche 陈词滥调 前后取反 a priori 未经观察分析的，既定的 vitiate 损害 25.lament 悲痛（追悼会） has never been greater 不能更好了 perenial lament 常年抱怨 -&gt; 取反 30.解析：in one direction they have a affinity with newspaper photographs 对应的就是空格，newspaper photographs 就是写实的特征，所以正确答案选 B 选项。documentary 纪实的。 翻译：在莫卧儿王朝时期的印度创作的画在志向上是纪实性的但在表现上却是装饰性的：一方面它们和报纸的照片类似，一方面它们有珠宝的错综复杂。 33.demographic 人口构成，人口学 34.aver 断言， averse 反对 , avow 公开宣称， disavow 否认 注意区分 39.live up to 能达到，遵守，不辜负 45.satirize 讽刺， aspirant 欲望 48.scifi-fiction 科幻小说 ","link":"https://yueqingsheng.github.io/ma3bpEnOQ/"},{"title":"GRE 笔记3 阅读2","content":" early view = some = tended to = because = seem R11 tended to = early view elect to 选择 保持单身 as champion of 和 as critics of 形成对比 institution 事情 Yet 但是 = but distort 曲解 this view = feminist scholar consequently author = new view, imply oppressive 残酷 R13 thereby + ing 通过。。方式 Because = early view compelling 令人幸福的, 让人相信的 evolve = timeline 取反 compromise 损害 premodern 农业改革之前 dismiss 不接受 physiology 生理学 R15 fiction 和 life history = document 对应 反义 hiatus = gap curb 控制或限制 R16 double-edged: of a knife, having two cutting edges 对不同人名观点做笔记 protagonist 主人公 R18 Some = early view hunter-gatherer 农业改革之前，智人 澳洲比美国环境恶劣，却有证据，说明美国之前根本没有人 R19 segregated South 南方种族隔离 determination 决心 literacy 识字率 record circulation 破纪录的发行量 R20 chronically 长期的 present 存在 qualitatively 质变 ","link":"https://yueqingsheng.github.io/gre-bi-ji-3-yue-du-2/"},{"title":"GRE 笔记1 阅读1 结构分析法","content":" 1. 文章多层结构解析法(40%) 教你如何彻底读懂一篇GRE英文阅读文章(100~500 words), 永远读懂句子内部关系,句子与句子之间的逻辑关系, 几个段落之间逻辑关系, 文章主要的pros and cons. Active engagement with the text, asking questions, formulating and evaluating hypotheses, reflecting on the relationship of the particular text to other texts and information. - Are they contrasting? Are they consistent? - Does one support the other? - Does one spell another out in greater detail? - Is one an application of another to a particular circumstance? 8.9 阅读初测 10/20 2h 一道题目只有1.5min, 也就说 一个小短文, 从看文章到做完2个Question, 你只有3min R1 第一句 Although the passenger pigeons, now extinct, were abundant in eighteenth- and nineteenth-century America, archaeological studies at twelfth-century Cahokian sites in the present day United States examined household food trash and found that traces of passenger pigeon were quite rare. timeline从前往后, timeline 就是 time+event 12世纪的sites, 鸽子trace少，18, 19世纪, 鸽子多; 20-21世纪, 鸽子灭绝. What is not an opinion? 1. An opinion is not a statement of fact. 2. An opinion is not a question. 3. An opinion is not a fragment. 4. An opinion expresses one idea. 5. An opinion does not simply announce the idea you will argue. 第一句话不是一个观点，因为符合1。观点所有时间地点人物事件 转折, 都要有。ETS 一定会有一个 “转” 第二句 Given that the sites were close to a huge passenger pigeon roost documented by John James Audubon in the nineteenth century and that Cahokians consumed almost every other animal protein source available, the archaeologists conducting the studies concluded the passenger pigeon population had once been very limited before increasing dramatically in post-Columbian America. 前半句不是观点，是个客观事实。后半句= view 考古学者提出来了一个conclusion， 所以是个观点。 post-Columbian: Referring to the cultures of the American continent after the European influence, specifically to the era after the continent was visited by Christopher Columbus.被哥伦布发现后的时期。 哥伦布是个男的，那么拉丁文的 地名呢, 要换成女性 阴性词所以呢是Columbia 秦始皇统一了中国, 秦就是chin，a就是地名的阴性后缀。 为啥都是阴性后缀 - 拉丁文地名 约定俗成, Europa Europa, or Jupiter II, is the smallest of the four Galilean moons orbiting Jupiter, and the sixth-closest to the planet of all the 79 known moons of Jupiter. It is also the sixth-largest moon in the Solar System. OG考察题材: Physical sciences Biological sciences Social sciences Arts and humanities Everyday topics 第二句强调一个 change，12世纪- 1492少 ，1492-now 多。 第三句 Other archaeologists have criticized those conclusions on the grounds that passenger pigeon bones would not be likely to be preserved. 主要是攻击了这个 on the gound that = reason/evidence 论点 (不是结论conclusion) opinion = view = conclusion = claim on the ground that = for the reason that = because 12世纪鸽子也许很多, 土著人也吃了无数鸽子,但是吃过的骨头都没有保存下来, 而已。反驳上面说的鸽子骨头少（这个evidence） -&gt; 12世纪-1492没有什么鸽子 第四句 But all the archaeological projects found plenty of bird bones- and even bones from fish. 不可能保存不下骨头，反驳上一句，对证据的反向驳斥再取反， counter - counter -view。 总结 文章结构 : 第一句话 fact 第二句话 提出 opinion = view 第三句话 提出反对的 counter -view 最后一句 counter - counter -view 最后一句话, 是对第二句话的取同 view = counter-counter-view 取同 题目 第一题 E counter - counter -view 对应了counter- objection 第二题 Which of the following, if true, would most call into question the reasoning of “the archaeologists conducting the studies”? E. Passenger pigeons tended not to roost at the same sites for very many generations 12世纪的 Cahokian sites 很小 没有鸽子, 不能说明 100% 美洲都没有鸽子，也许其他纽约 洛杉矶有鸽子聚集地呢。12世纪也许恰好 Cahokian 没有鸽子。 R2 整理全部生词，运用结构解析法， 翻译提前完成 第一句 divide 表示2个对立的观点 or 学派 第二句 technicians 和 landscape painters 取反， 中间有一个 while 第二句跟第一句，举例子, 解释说明, 取同。 所以第二句的others 应该是说 before 19世纪的是艺术流派 第三句 dichotomy 同义替换 divide aesthetic = visual effects = landscapge painting 第四句 Until the 1980s是考点词了, until 这个词 是before 还是 after? before 看到 before、 after 、 until 脑子里习惯性有一个取反 Time-event, 先对时间取反, 再对 event 取反 最后一句 才没有什么所谓的 divide dichotomy = boundary, no boundary at all so 文章结构， 5句话讲early view，最后一句话, 讲new view puzzle = question = 不认可early view R3 第一句话, 看到some 想到什么, 是一个early view While few people doubt that 让步取同 R4 note 表示 发现了一个问题 R8 early view , early evidence, although 表示后面有观点会取反，形成对比 qualify 取反 R10 4000 years ago = -4000 at least 选项有 80% 可能是正确的 ","link":"https://yueqingsheng.github.io/gre-bi-ji/"},{"title":"月报 8月","content":"月报 8月 ","link":"https://yueqingsheng.github.io/yue-bao-8-yue/"},{"title":"月报 7月","content":"两个多月没出现过了🙁，最近打算在自学 GRE 考试，看的内容不多。这个月最火的就是 GPT-3 demo 了，有些自然语言到代码生成的样例确实蛮意思的，根据描述就可以生成 SQL, Figma 或者 CSS 样式了。 AI CNN 入门讲解，对基础概念理解比较不错。 什么是CNN？写给小白的机器学习入门贴 用之前提到过的 OPENAI 的 GPT-3 API 做的样例，包括了根据描述生成代码之类的比较有意思的东西 。 10 COOL GPT-3 DEMOS Github 上整理的 demo awesome-gpt3 文章 感觉把 Computer Science 这个行业讲的蛮好的，建议毕业生或有兴趣从事 CS 的都看一下 《黑客与画家》第二章。 2 黑客与画家 视频 软饭硬吃，哈哈，有以前毅吧那味了。 广东爱情故事 认真做历史科普的人不多了，老阴阳师做科普的更不多了。最近读了篇 GRE 文章讲，虽然在科技发展如此快的时代，有些科学常识是如此的珍贵，对于普通人却像腐烂在温室里的花，无人在乎。 西方灾难史：美国大萧条（全集），点这里看全集哦。 ","link":"https://yueqingsheng.github.io/zhou-bao-7-yue/"},{"title":"递归","content":"递归模板，记住递归是对每一层做的操作 题目1：二叉树的最大深度 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 ldepth = self.maxDepth(root.left) + 1 rdepth = self.maxDepth(root.right) + 1 return max(ldepth, rdepth) 可以把判断叶子节点去掉的原因，可以多走一层走到叶子节点下一层发现没有就返回上来0。每走一层就加1，走到叶子节点下一层，返回0 +1 也是一样的。 官方解法，每往下走一层就+1， 然后每层取左右两边最大的深度 class Solution: def maxDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 else: left_height = self.maxDepth(root.left) right_height = self.maxDepth(root.right) return max(left_height, right_height) + 1 ","link":"https://yueqingsheng.github.io/di-gui/"},{"title":"  树、二叉树","content":"数跟图的区别是有没有闭环 二叉搜索树： 遍历 查询，插入 logn 插入：先查找位置，再插入 删除，去第一个大于parent node的节点。 平均 O(log(n)) 最差情况 O(n) 题目1： N 叉树前序遍历 给定一个 N 叉树，返回其节点值的前序遍历。 &quot;&quot;&quot; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children &quot;&quot;&quot; class Solution: def preorder(self, root: 'Node') -&gt; List[int]: path = [] def traverse(node): if node: path.append(node.val) for n in node.children: traverse(n) traverse(root) return path ","link":"https://yueqingsheng.github.io/shu-er-cha-shu/"},{"title":"链表","content":"数组访问 O(1), 添加删除 O(n) 链表访问O(n), 添加删除 O(1) 跳表 log(n) 基于有序的链表 Redis LevelDB python swap x, y = y, x 题目1： 删除排序数组中的重复项 解法1：一开始的思路是把数组循环一遍，有重复的就删除掉，O(n^2) 的效率 数组循环删除的方法，复制一遍数组或者使用反向遍历 为什么反向遍历不会出现 index 的错误？ This implies that if you iterate the list back to front, if you remove an item at the current index, everything to it's right shifts left - but that doesn't matter, since you've already dealt with all the elements to the right of the current position, and you're moving left - the next element to the left is unaffected by the change, and so the iterator gives you the element you expect. a b c x d a b c d python range range(start, stop, step) reverse: range(len(x)-1, -1, -1) class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums) == 1: return len(nums) for i in range(len(nums)-1,0,-1): if nums[i] == nums[i-1]: nums.pop(i) return len(nums) 解法2： 双指针 O(n) 一个指针指向要放不同element的下标，另外一个指针用来搜索下一个要放的元素 class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i = 0 for j in range(len(nums)): if nums[i] != nums[j]: nums[i+1] = nums[j] i = i + 1 return len(nums[:i+1]) ","link":"https://yueqingsheng.github.io/lian-biao/"},{"title":"算法基础","content":"时间复杂度和空间复杂度分析 时间复杂度： Big O noataion 递归分析： Master Theorem 二叉树遍历 O(n) DFS, BFS O(n) 空间复杂度 入门题1: StrStr 注意检查空字符串 class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if len(needle) == 0 : return 0 for i in range(len(haystack)): if haystack[i : i + len(needle)] == needle: return i return -1 入门题2: 子集 分解问题使用递归解决 我的解法：把所有可能过一遍，去重 class Solution: def subsets(self, nums) : subsets = [[]] def subset(nums): if len(nums) == 0: return subsets.append(nums) for n in nums: nums_copy = nums[:] nums_copy.remove(n) if nums_copy not in subsets: subset(nums_copy) return subset(nums) return subsets 官方解法1: 从小到大，每次有新数出现的时候，把之前的可能序列合并上这个数 class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: n = len(nums) output = [[]] for num in nums: output += [curr + [num] for curr in output] return output python listt concatenata a = [] a += [3] a = a+ [3] 官方解法2: 回溯法 ","link":"https://yueqingsheng.github.io/shi-jian-fu-za-du-he-kong-jian-fu-za-du-fen-xi/"},{"title":"Windows 本地运行 Jupyter 作业教程","content":"推荐 Anaconda 傻瓜式安装，安装完后启动 Jupyter 直接在本地运行下载下来的 notebook 会有几个问题，提供下解决方案： 1. ERROR: Invalid requirement: '#' 当命令行语句和注释在同一行时候会报错，可以把同行的注释去掉，或者挪到上面 2. module could not be found 找不到雅达利 乒乓环境 做如下几步 卸载 gym and atari-py (If already installed): pip uninstall atari-py pip uninstall gym[atari] 下载 VS build 工具 : https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16 运行并选择 &quot;C++ build tools&quot;安装. 重启电脑 安装 cmake, atari-py and gym pip install cmake pip install atari-py pip install gym[atari] 跑一下测试: import atari_py print(atari_py.list_games()) 如果成功会 print 下面 ['adventure', 'air_raid', 'alien', 'amidar', 'assault', 'asterix', 'asteroids', 'atlantis', 'bank_heist', 'battle_zone', 'beam_rider', 'berzerk', 'bowling', 'boxing', 'breakout', 'carnival', 'centipede', 'chopper_command', 'crazy_climber', 'defender', 'demon_attack', 'double_dunk', 'elevator_action', 'enduro', 'fishing_derby', 'freeway', 'frostbite', 'gopher', 'gravitar', 'hero', 'ice_hockey', 'jamesbond', 'journey_escape', 'kaboom', 'kangaroo', 'krull', 'kung_fu_master', 'montezuma_revenge', 'ms_pacman', 'name_this_game', 'phoenix', 'pitfall', 'pong', 'pooyan', 'private_eye', 'qbert', 'riverraid', 'road_runner', 'robotank', 'seaquest', 'skiing', 'solaris', 'space_invaders', 'star_gunner', 'tennis', 'time_pilot', 'tutankham', 'up_n_down', 'venture', 'video_pinball', 'wizard_of_wor', 'yars_revenge', 'zaxxon'] 3. WRN Found non-empty CUDA_VISIBLE_DEVICES. But PARL found that Paddle was not complied with CUDA, which may cause issues. keneral dead 这个错误 Kernel 会挂掉，然后无限重启，主要是 检测到了电脑里的GPU, 但是没有安装 Cuda 导致的。 因为这里我们只使用 CPU 来跑，所以把 GPU 检测关闭就好了 在最后运行代码前加上这两行： import os os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;-1&quot; ","link":"https://yueqingsheng.github.io/windows-ben-di-yun-xing-jupyter-zuo-ye-jiao-cheng/"},{"title":"强化学习 Day5 连续空间动作 DDPG","content":" DQN 扩展到连续控制动作空间 策略网络负责对外展示动作, critc 对action 打分，action -&gt; Q value，迎合评委网络使 Q 尽可能高 Q 网络逼近 Q-target, 使用 MSE Q target 不稳定，所以专门建立 target_Q 和 target_P 网络（next_action ） 为了防止 target_Q 网络更新, (定期copy), 需要 stop gradient 只更新 θ\\thetaθ, 所以minimize 中 传入要更新的 actor 参数 总结 ","link":"https://yueqingsheng.github.io/qiang-hua-xue-xi-day5-lian-xu-kong-jian-dong-zuo-ddpg/"},{"title":"系统设计7 GFS","content":" Scenario Service clinet + Server 多台机器怎么沟通？ Storage 保存一个文件 MetaData 的访问更多，A, B 两种存储结构 机械硬盘，磁头调需要时间，所以选择A 文件内容分段储存还是连续存储，B 适合修改或追加内容 100T，block 太多，增加 block 大小， 4k -&gt; 64M, 劣势浪费了小空间， 4m 占用了64m空间 10P，一台电脑 0.1P offset 可以只存在 Chunk server 上 换格子不用通知 Master Read &amp; Write 写入 一次写入还是多次写入，传输单位是Chunk 和Master 沟通，直接给chunk server 写 读入 并行从不同 Chunk server 读入 Scale 单 Master 检查损坏 CheckSum, XOR(exclusive OR) 相同为0， 不同为1，有误检情况，极低 1 个 cheksum 4bytes, 1 个 chunk 1个 chunksum Replica 备份 B. 单次通讯 实战 QPS ","link":"https://yueqingsheng.github.io/xi-tong-she-ji-7-gfs/"},{"title":"强化学习 Day 4 基于策略方法","content":"Value-based vs policy-based policy based : 直接求action policy based: 输出动作的概率 最后一层 softmax episode: 每轮游戏 优化目的： max 每个episode的总reward 环境的随机性无法控制 期望回报 环境概率是未知的， N是 episode数。 优化策略函数 优化目标 期望回报最大， 梯度上升 蒙特卡洛每个 Episode 更新一次， 时序差分每个action更新一次 根据公式反向推到G1G_1G1​ Reinforce 每个 Episode , 通过 (st,at)(s_t, a_t)(st​,at​) 求出 G_t, 对于每一步使用 ln 函数更新神经网络参数值 类比 Cross entrophy, 因为sum_ln 不一定是正确的acition, 只是真实的action, 所以需要乘上总奖励系数 G 流程图 总结 ","link":"https://yueqingsheng.github.io/qiang-hua-xue-xi-day-4-ji-yu-ce-lue-fang-fa/"},{"title":"系统设计6 聊天系统","content":"设计微信 Scenario 微信不是点对点通信？ 不是，可以留言。历史消息存在服务器，留一段时间(缓冲期)删除，或者不删除。 Service Storage Thread table (会话) 有些信息是私有的，未读，静音 方法 1 私有的信息存在 User thread, 如何知道参与人，查找所有表里有相同therad_id， primary key = userId + thread id 弊端：需要跨表查询比较慢 方法 2 实际情况下使用cache , 减少跨表次数。 通过 参与者 查询 thread id Message 存储结构（写多读少） Nosql(optimize for write) Thread SQL NoSQL 可行解 Scale 实时 Push notification 局限性： 无法支持 Web 端 Socket: 支持 Server push 给客户端 Channel Service 支持群聊 channel service 里的 key 就是 channel 的名字，value 是在这个 channel 下有哪些人。 因为 channel 是一个 key-value 的存储结构，value 是一个 set，支持用户上下线（增删），所以 Redis 是可以很好支持 value 是 set 的一种 key-value 结构。 Q &amp; A 多机登录 用户在线状态显示 ","link":"https://yueqingsheng.github.io/xi-tong-she-ji-6-liao-tian-xi-tong/"},{"title":"强化学习 Day 3 神经网络方法","content":"Q 表不适合的场景 状态太多或者不可数，表格无法容纳 值函数近似 神经网络 拟合任意函数 map x(输入)-&gt;y（输出） DQN 拟合Q表格，找出 s 到 Q 的 maping, 即 Q 表格 s=&gt; Q（a∗a_*a∗​）, 输出一个包含不同 a 的向量， 逼近 Target Q 创新点 1. 经验回放 存储一部分经验数据，从中随机选取一部分 (batch) 更新数据 off-policy 回顾 士兵 (behavior policy): 根据战术攻打堡垒，拿到战斗经验，给到军师分析 军师 (Target policy): 根据经验，提升战术，让前方战士打的更好 战术 (Q table) DQN， 军师从士兵的经验池随机抽取一部分经验。使用缓冲区存储经验，经验可以重复利用。 sample 输入 batch_size 输出抽取的5个数组 2. 固定 Q 目标 保持 Q_target 稳定， 定期 copy Q DQN 流程图 PARL DQN model 神经网络， Algorithm loss function , agent 和环境交互 model.py 输入 obs(S)，通过神经网络计算 Q 值 algorithm init : 输入model 和 参数，copy model, 初始化参数,model , target_model sync_target: 同步 model, target_model 参数 predict: 返回 model 的值， Q learn: 计算 target_Q freeze target_Q, 阻止梯度传递，防止参数更新 计算 Q(s,a) layers.cast(done) true 返回 1， false 返回 0 action 做 onehot， 乘以 Q(s,a) 得到 real Q 计算 loss agent: 更新网络，获取 Q 值。 CartPole 总结 跟 Q learning 主要区别就是使用神经网络计算 Q 值，扩展了 Q 值的范围。并使用经验回放和固定Q目标，重复利用了经验样本和稳定了算法。 拓展 DQN调参 ","link":"https://yueqingsheng.github.io/qiang-hua-xue-xi-day-3-shen-jing-wang-luo-fang-fa/"},{"title":"Day 2 Sarsa & Q-learning 实现思路","content":"第一步把 Q table 看一下 16行4列的np array， 每一格为Q(state, action)的值 sample和predict: 就是ϵ\\epsilonϵ-greedy算法 sample 在 0-1 roll 一个数，如果这个数小于等于1- ϵ\\epsilonϵ 就触发argmax事件，否则触发随机行动。 可能会用到的函数： numpy.random.uniform(low=0.0, high=1.0, size=None) 在 low 到 high 范围取size个样本，默认0到1取一个样本 numpy.random.choice(a, size=None, replace=True, p=None) 从 a 列表里随机选size个数， a可以是1维列表或者int, int的话就是 range(a) Parameters: a: If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a was np.arange(n) predict 从第 s/obs 行，取 Q 值最大的 a。=&gt; find the max index of value，即求最大值的坐标。 因为有可能有多个最大值，我们不想每次都走同一个action, 所以从这些最大值的坐标随机出一个。 可能会用到的函数： 从 2D Numpy Array 选某行： ndArray[row_index] 或者 ndArray[row_index, :] numpy.where(condition) 输出满足条件 ((condition)) 元素的坐标 (等价于numpy.nonzero)。这里的坐标以tuple的形式给出。 这里 np.where 返回类似 (array([0, 1, 2, 3]),) 元组这种格式。所以用下标取出第一个array learn 这里就是先把方括号里的算出来，再乘 α\\alphaα 加上原来的值 Q learning 的 sample 和 predict 和 Sarsa 完全一样，唯一就是 更新 Q 的公式不同。 显示视图 把 test_episode 里的这两行反注释掉 gridworld.py 下载地址：https://raw.githubusercontent.com/PaddlePaddle/PARL/develop/examples/tutorials/lesson1/gridworld.py from gridworld import FrozenLakeWapper env = gym.make(&quot;FrozenLake-v0&quot;, is_slippery=False) env = FrozenLakeWapper(env) 错误：no display name and no $DISPLAY environment variable Jupyter没有窗口环境，要本地运行，或者远程terminal跑才行 结果展示 Sarsa Q-learning ","link":"https://yueqingsheng.github.io/day-2-zuo-ye-si-lu/"},{"title":"强化学习 Day 2 Sarsa & Q-learning","content":"强化学习MDP四元组&lt;S, A, P, R&gt; 强化学习是解决跟时间相关的序列决策问题。 p[st+1,rt∣st,at]p[s_{t+1}, r_{t} | s_{t}, a_{t}] p[st+1​,rt​∣st​,at​] 在st时刻，选择at动作的时候，转移到st+1 而且拿到 rt奖励的概率\\text{在$s_ t$时刻，选择$a_t$动作的时候，转移到$s_{t+1}$ 而且拿到 $r_{t}$奖励}的概率 在st​时刻，选择at​动作的时候，转移到st+1​ 而且拿到 rt​奖励的概率 马尔可夫性质: 当前时刻的状态仅与前一时刻的状态和动作有关，与其他时刻的状态和动作条件独立。 马尔可夫决策过程（Markov Decision Process, MDP）是序贯决策（sequential decision）的数学模型，用于在系统状态具有马尔可夫性质的环境中模拟智能体可实现的随机性策略与回报 P函数：随机性，转移到另外一种状态的概率 R函数：奖励函数 Model-based vs Model-free Model based: 如果 P, R 已知，则环境是已知的，可以用动态规划计算最优方案。 Model free: 当解决未知或随机的环境时，即 P, R 未知，可以使用强化学习。 Q 函数 Q的目标是未来的总收益 但是当时间过长时，需要加一个 γ\\gammaγ 衰减系数，时间越久，对当前的收益影响越小 更新Q表格 下个状态的价值可以用来强化上一个状态的价值，如结合食物和铃声一起影响狗的食欲（流口水）。 这个公式其实就是把每一步的收益逼近于未来收益之和，即走到这一步获得的总收益。每一次向目标值的方向更新一点。 每次跳转到下一个状态时，通过这些Sarsa参数，便可得知当前状态的Q value。 算法：每走一步，先选出要做的动作。再走下一步，通过状态s2s_2s2​，从Q表拿到a2a_2a2​, 然后通过下一步和上一步的参数更新 Q(s1,a1)Q(s_1, a_1)Q(s1​,a1​) 如何通过状态 s 去取出动作 a ？ ϵ\\epsilonϵ-greedy Sarsa 代码 paddle实现链接 Off-Policy Off-Policy 不和环境交互 Q-learning Q-learning vs Sarsa Q-learning 的下个状态选取使Q最大的action Off-Policy vs On-policy policy: 策略是指通过状态 s 去取出动作 a 的 方法/概率。Policy specifies an action 𝑎, that is taken in a state 𝑠 (or more precisely, 𝜋 is a probability, that an action 𝑎 is taken in a state 𝑠). 行为策略：用来与环境互动收集情报、产生数据的策略，即训练过程中的策略。 π(a|s) 目标策略：在行为策略产生的数据中不断学习和优化得到的策略，即学习训练完毕后拿去做行为评估的策略。µ(a|s) 区别是 on-policy 通过的与环境交互的经验更新Q, 按以往经验来。 off-policy 就不管之前经验了，通过任意方式获取action, 比如 greedy。 总结 On policy 对于保留目前探索的成果有好处 ，但容易陷入局部最优。不够冒险。 Off policy 够冒险，容易达到全局最优，但收敛更慢，试错更多，不适合现实中试错成本太大的尝试。 拓展： ON-POLICY VS OFF-POLICY REINFORCEMENT LEARNING ","link":"https://yueqingsheng.github.io/qiang-hua-xue-xi-day-2-sarsa-q-learning/"},{"title":"强化学习 Day 1 Introduction","content":"什么是强化学习？ 两部分 三要素 在 Flappy bird 中 agent environment state action reward 鸟 鸟周围的环境，水管、天空（包括小鸟本身） 拍个照（目前的像素） 向上向下动作 距离（越远奖励越高） 动一下截个图 再决定下一个动作 跟环境交互，决策。 奖励是延迟的。迷宫走完，才有奖励。 强化学习和其他机器学习的关系 监督样本一般样本内无关系。强化学习，样本之间相互影响。 基于价值会向固定方向走，基于策略随机性更高一些。 RL agent &lt;-&gt; environment 交互接口 reset 重置 render 渲染目前 step 交互一步 Step 输出参数 1-36 位置（36格内的位置） -1 reward(奖励，每走一步会有惩罚，目标最少步数走完) true/false 游戏是否完成 info 额外信息 git clone --depth=1 depth 用于指定克隆深度，为 1 即表示只克隆最近一次 commit. 可以解决项目过大的问题 总结 拓展：为什么有人说 Python 的多线程是鸡肋呢？ 图片来源：PARL 强化学习公开课 Lesson1 ","link":"https://yueqingsheng.github.io/qiang-hua-xue-xi/"},{"title":"系统设计5 基于地理位置的信息系统（Location based service)","content":"RPC(remote procedure call) 不同的机器之间调用函数 http包含了很多验证信息, 不高效 Google S2(位置储存 查询系统) System design = logic design + infrastructure design(架构设计) Scenario 收集用户信息，预测打车概率。 Service Storage Trip Table:（单） 读多写少 每四秒查一次附近的接单信息 Location Table: 读少写多 每四秒写一次driver location 范围查询 二维查询映射到一维 Google S2 Geohash 查看公共前缀相似度，32份， 为什么是 1：2？ 4 * 8（180，360）纬经度比 为什么上下方两行长？ 因为地球是圆的，上下占的面积相当于三角形 为什么是 4*8? 缺陷 ：刚好在线上，线两边差距大 查询 Google 半径两公里以内的车 geohash LIKE 9q9hv%, %分号在后面，表示以9q9hv开头 Redis value: set 删除 O(1) list 删除O(n) 匹配 Scale 迁移成本低，损失成本大。单点 Failure DB sharding 按Geo hash 前四位 Uber 使用城市 Sharding 定义城市 Geo Fence 求一个点是否在多边形内 乘客在边界上，记录城市连接关系 机场 先找到城市，再查询 airport fence 减少风险 Master slave 换数据库Riak ","link":"https://yueqingsheng.github.io/xi-tong-she-ji-5-ji-yu-di-li-wei-zhi-de-xin-xi-xi-tong-location-based-service/"},{"title":"nestjs 统一返回格式","content":"统一返回格式 ｛data：object，message：请求成功，code：200｝ 成功的格式 { &quot;statusCode&quot;: 200, &quot;data&quot;: { &quot;username&quot;: &quot;string&quot;, &quot;access_token&quot;: &quot;XXX&quot; }, &quot;code&quot;: 0, &quot;message&quot;: &quot;请求成功&quot; } 失败的格式 { &quot;statusCode&quot;: 401, &quot;data&quot;: { &quot;error&quot;: &quot;Client Error&quot; }, &quot;message&quot;: &quot;请求失败&quot;, &quot;code&quot;: 1, &quot;url&quot;: &quot;/api/auth/profile&quot; } 暂定code代表成功，1代表失败，成功data里是返回内容，失败data里是错误信息。 拦截全部的错误请求 src/core/filters/all-exception.filter’; import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch() export class AllExceptionFilter&lt;T&gt; implements ExceptionFilter { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse&lt;Response&gt;(); const request = ctx.getRequest&lt;Request&gt;(); const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; const message = exception.message.message ? exception.message.message : `${status &gt;= 500 ? 'Service Error' : 'Client Error'}`; const errorResponse = { statusCode: status, data: { error: message }, message: '请求失败', code: 1, // 自定义code }; // 设置返回的状态码、请求头、发送错误信息 response.status(status); response.header('Content-Type', 'application/json; charset=utf-8'); response.send(errorResponse); } } 拦截成功的返回数据 src/core/interceptors/response.interceptor’; import { CallHandler, ExecutionContext, Injectable, NestInterceptor, } from '@nestjs/common'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { Response } from 'express'; @Injectable() export class ResponseInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const response = context.switchToHttp().getResponse&lt;Response&gt;(); console.log(response.statusCode); return next.handle().pipe( map(data =&gt; { return { data, code: 0, message: '请求成功', statusCode: response.statusCode, }; }), ); } } 全局注册 main.ts ... import { TransformInterceptor } from './core/interceptor/transform.interceptor'; async function bootstrap() { ... // 全局注册拦截器 app.useGlobalFilters(new AllExceptionFilter()); app.useGlobalInterceptors(new ResponseInterceptor()); ... } bootstrap(); ","link":"https://yueqingsheng.github.io/nestjs-tong-yi-fan-hui-ge-shi/"},{"title":"系统设计4 API设计和短网址","content":"网站系统，域名 访问Google You type maps.google.com into the address bar of your browser. The browser checks the cache for a DNS record to find the corresponding IP address of maps.google.com. The browser sends an HTTP request to the webserver. webserver =&gt; http server(Apache, nginx) http server =&gt; WebApplication(Django, nodejs) webapplication response API 设计 直接使用user id是不安全的，正确方式是通过登陆后的token获取id News Feed List Web Api 翻页 Pagination 多请求一个 page_size = n + 1, max_id = the last item id, real displayed = n items refresh find items id &gt; max_id (latest) Mention 直接返回缺点 短网址 Service 转换算法 随机生成去重 SQL NoSQL Scale 优化 response time Use Cache 地理位置提速 centralized mysql + distributed memcached 一台数据库服务器搞不定 练习 Custom url (自定义链接 转 longurl) 自增Id法： 单独创建一个 cutsom url -&gt; longurl 数据表 随机生成法： 直接存储 custom url ","link":"https://yueqingsheng.github.io/xi-tong-she-ji-4-duan-lian-jie/"},{"title":"系统设计 3 sharding&hash","content":"Scale QPS Single point failure(一台服务器挂) sharding 数据拆分 解决 single point failure 分摊流量 replica 数据复制 数据恢复 分摊流量 数据库拆分 竖向拆分 缺点： 当表单特别大，column无法拆分时无法用 横向拆分 新数据放新机器，老数据放老机器的问题是什么？ 根据数据的新旧程度来拆分的话，新数据的访问次数比旧数据的访问次数是要明显多的，会导致数据访问不均匀的问题。 这种方法并不会导致存储不均匀，最多只有最新的一台机器的数据相对少一些，其他的机器都还是均匀的。也不会导致不知道数据去哪台机器取，比如根据 id 来拆分，0~99在1号机器，1-199 在2号机器的话，根据 id 可以算出对应的机器是哪个 75%的数据迁移 一致性哈希算法 匀走相邻两台机器的一部分数据 缺陷： 改进： 红黑树（balanced tree） 数据复制 Replica Replica vs Backup SQL NoSQL 实战1：User Table Sharding 怎么取数据就怎么拆数据库 按照 username找用户 查username-&gt;id表 实战2：Friendship Table Sharding 双向好友关系，必须存两条关系 实战4： News Feed/Timeline Sharding owner id/userid 实战5： LintCode Submission (user/problem/status) ","link":"https://yueqingsheng.github.io/xi-tong-she-ji-3-databaseandhash/"},{"title":"随想","content":"会记录一些突然想到的想法到这里 开会 会议中有太多的干扰项，具体实现的方案应该放在会议前去做。多人的交流和干扰，反而会使想出一个好的解决方案的效率降低。 项目宏伟的缺陷 一些宏伟项目想法在提出来的时候，可能会很好。但是应该在每部分的实现逻辑（细节）尽可能完善后（想出来，或者demo实现一下），再招聘程序员去做。 bug解决方案 当卡在某个bug自己短时间内无法解决时，或找不到原因，最有效率的方式是去搜索这个问题，查看别人是怎么解决的。 时间规划 可以给计划设个下限和上限，以避免规划没达到的心里落差。 娱乐至死 正如赫胥黎在《重访美丽新世界》里提到的，那些随时准备反抗独裁的自由意志论者和唯理论者“完全忽视了 人们对于娱乐的无尽欲望”。在《一九八四》中，人们受制于痛苦，而在《美丽新世界》 中，人们由于享乐失去了自由。简而言之，奥威尔担心我们憎恨的东西会毁掉我们，而 赫胥黎担心的是，我们将毁于我们热爱的东西。 最后，他试图在《美丽新世界》中告诉我们，人们感到痛苦的不是他们用笑声代替了思考，而 是他们不知道自己为什么笑以及为什么不再思考。 -- 摘自《娱乐至死》 ","link":"https://yueqingsheng.github.io/sui-xiang 2/"},{"title":"jupyter","content":"自动输出多行 from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = &quot;all&quot; 安装包 can not find module import sys !{sys.executable} -m pip install pypinyin ","link":"https://yueqingsheng.github.io/jupyter/"},{"title":"系统设计 Week 2 Database&Cache(数据库和缓存)","content":"用户系统 Scenario(QPS)&amp;Service QPS = DAU*用户平均每天请求次数/每天多少秒（86400） QPS与数据存储 Cache（读多写少） File system 可以作为网络请求和计算结果的cache 跟hashmap区别，cache有淘汰机制（LRU，LSU） ttl: time to live Set User cache delete, database set.有可能第二个 多线程下，可能造成数据不一致。 当执行完cache delete, 另外线程get user 获取了旧数据（cache）, 再执行database set (新数据-&gt;数据不一致 加锁（不同机器，系统) 常用方法 database.set, cache.delete 同时用 set set, 多进程会有修改数据库情况，然后缓存set旧的data 第一种情况因为读多改少，出现概率低。cache hit 概率大，通常&gt;98% 如何解决一致性 问题 ttl(time to live) 允许短时间的不一致 读少写多 （多用数据库，分摊请求） Cache 架构 登录系统 UUID:通常用UUID来作为Session Key(Session Token)，UUID(Universal Unique ID): UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为1632=2128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。所以通俗的称之为宇宙爆炸都不会出现重复的ID字段。 Cookie里内容越少越好 只允许一台机器登录 存储device token, 监测到不同device, 把其他设备账户logout 好友关系 方案1: 优点：只存储1条数据，节省一半空间。（当你要存 1 和 2 是好友的时候，你可能存为 &lt;1,2&gt; 也可能存为 &lt;2,1&gt;。我们只存成 &lt;1,2&gt; 的形式，原因有两个，第一是方便查询，否则你查询的时候得分别差 &lt;1,2&gt; 是否存在和 &lt;2,1&gt; 是否存在。第二个是节省一半的存储空间。） 缺点： 查询时 or 操作慢一些 方案2: 优点： 查询语句简单，查询速度快。空间换取时间 Transaction: 事务。代表一些列操作要打包在一起，同时成果或者同时失败。比如我转你 10 块钱，你的余额要 +10，我的余额要 -10。这是两条数据库操作，必须同时成功或者同时失败。不能只有一条操作成功。这种打包，就叫做 Transaction。 NoSQL(Cassandra) Row key: 存储到哪台机器的索引，nosql 用于分布式 Column key: 支持范围查询 和 复合值查询 NoSQL VS SQL 选择原则： transaction 不能选NoSQL(通常在一台机器完成) 擅长部分 一个网站会使用多种数据库 NoSql 存单向好友关系 NoSql 存储User 根据 emial/phone/username查询 共同好友 A userid B userid =&gt; A和B交集 六度关系 ","link":"https://yueqingsheng.github.io/xi-tong-she-ji-week-2-databaseandcacheshu-ju-ku-he-huan-cun/"},{"title":"python cheatsheet","content":"Comprehensive Python Cheatsheet Download text file, Buy PDF, Fork me on GitHub or Check out FAQ. Contents 1. Collections: List, Dictionary, Set, Tuple, Range, Enumerate, Iterator, Generator. 2. Types: Type, String, Regular_Exp, Format, Numbers, Combinatorics, Datetime. 3. Syntax: Args, Inline, Closure, Decorator, Class, Duck_Type, Enum, Exception. 4. System: Exit, Print, Input, Command_Line_Arguments, Open, Path, OS_Commands. 5. Data: JSON, Pickle, CSV, SQLite, Bytes, Struct, Array, Memory_View, Deque. 6. Advanced: Threading, Operator, Introspection, Metaprograming, Eval, Coroutines. 7. Libraries: Progress_Bar, Plot, Table, Curses, Logging, Scraping, Web, Profile, NumPy, Image, Audio, Pygame. Main if __name__ == '__main__': # Runs main() if file wasn't imported. main() List &lt;list&gt; = &lt;list&gt;[from_inclusive : to_exclusive : ±step_size] &lt;list&gt;.append(&lt;el&gt;) # Or: &lt;list&gt; += [&lt;el&gt;] &lt;list&gt;.extend(&lt;collection&gt;) # Or: &lt;list&gt; += &lt;collection&gt; &lt;list&gt;.sort() &lt;list&gt;.reverse() &lt;list&gt; = sorted(&lt;collection&gt;) &lt;iter&gt; = reversed(&lt;list&gt;) sum_of_elements = sum(&lt;collection&gt;) elementwise_sum = [sum(pair) for pair in zip(list_a, list_b)] sorted_by_second = sorted(&lt;collection&gt;, key=lambda el: el[1]) sorted_by_both = sorted(&lt;collection&gt;, key=lambda el: (el[1], el[0])) flatter_list = list(itertools.chain.from_iterable(&lt;list&gt;)) product_of_elems = functools.reduce(lambda out, el: out * el, &lt;collection&gt;) list_of_chars = list(&lt;str&gt;) Module operator provides functions itemgetter() and mul() that offer the same functionality as lambda expressions above. &lt;int&gt; = &lt;list&gt;.count(&lt;el&gt;) # Returns number of occurrences. Also works on strings. index = &lt;list&gt;.index(&lt;el&gt;) # Returns index of first occurrence or raises ValueError. &lt;list&gt;.insert(index, &lt;el&gt;) # Inserts item at index and moves the rest to the right. &lt;el&gt; = &lt;list&gt;.pop([index]) # Removes and returns item at index or from the end. &lt;list&gt;.remove(&lt;el&gt;) # Removes first occurrence of item or raises ValueError. &lt;list&gt;.clear() # Removes all items. Also works on dictionary and set. Dictionary &lt;view&gt; = &lt;dict&gt;.keys() # Coll. of keys that reflects changes. &lt;view&gt; = &lt;dict&gt;.values() # Coll. of values that reflects changes. &lt;view&gt; = &lt;dict&gt;.items() # Coll. of key-value tuples that reflects chgs. value = &lt;dict&gt;.get(key, default=None) # Returns default if key is missing. value = &lt;dict&gt;.setdefault(key, default=None) # Returns and writes default if key is missing. &lt;dict&gt; = collections.defaultdict(&lt;type&gt;) # Creates a dict with default value of type. &lt;dict&gt; = collections.defaultdict(lambda: 1) # Creates a dict with default value 1. &lt;dict&gt; = dict(&lt;collection&gt;) # Creates a dict from coll. of key-value pairs. &lt;dict&gt; = dict(zip(keys, values)) # Creates a dict from two collections. &lt;dict&gt; = dict.fromkeys(keys [, value]) # Creates a dict from collection of keys. &lt;dict&gt;.update(&lt;dict&gt;) # Adds items. Replaces ones with matching keys. value = &lt;dict&gt;.pop(key) # Removes item or raises KeyError. {k for k, v in &lt;dict&gt;.items() if v == value} # Returns set of keys that point to the value. {k: v for k, v in &lt;dict&gt;.items() if k in keys} # Returns a dictionary, filtered by keys. Counter &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; colors = ['blue', 'blue', 'blue', 'red', 'red'] &gt;&gt;&gt; counter = Counter(colors) &gt;&gt;&gt; counter['yellow'] += 1 Counter({'blue': 3, 'red': 2, 'yellow': 1}) &gt;&gt;&gt; counter.most_common()[0] ('blue', 3) Set &lt;set&gt; = set() &lt;set&gt;.add(&lt;el&gt;) # Or: &lt;set&gt; |= {&lt;el&gt;} &lt;set&gt;.update(&lt;collection&gt;) # Or: &lt;set&gt; |= &lt;set&gt; &lt;set&gt; = &lt;set&gt;.union(&lt;coll.&gt;) # Or: &lt;set&gt; | &lt;set&gt; &lt;set&gt; = &lt;set&gt;.intersection(&lt;coll.&gt;) # Or: &lt;set&gt; &amp; &lt;set&gt; &lt;set&gt; = &lt;set&gt;.difference(&lt;coll.&gt;) # Or: &lt;set&gt; - &lt;set&gt; &lt;set&gt; = &lt;set&gt;.symmetric_difference(&lt;coll.&gt;) # Or: &lt;set&gt; ^ &lt;set&gt; &lt;bool&gt; = &lt;set&gt;.issubset(&lt;coll.&gt;) # Or: &lt;set&gt; &lt;= &lt;set&gt; &lt;bool&gt; = &lt;set&gt;.issuperset(&lt;coll.&gt;) # Or: &lt;set&gt; &gt;= &lt;set&gt; &lt;el&gt; = &lt;set&gt;.pop() # Raises KeyError if empty. &lt;set&gt;.remove(&lt;el&gt;) # Raises KeyError if missing. &lt;set&gt;.discard(&lt;el&gt;) # Doesn't raise an error. Frozen Set Is immutable and hashable. That means it can be used as a key in a dictionary or as an element in a set. &lt;frozenset&gt; = frozenset(&lt;collection&gt;) Tuple Tuple is an immutable and hashable list. &lt;tuple&gt; = () &lt;tuple&gt; = (&lt;el&gt;, ) &lt;tuple&gt; = (&lt;el_1&gt;, &lt;el_2&gt; [, ...]) Named Tuple Tuple's subclass with named elements. &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Point = namedtuple('Point', 'x y') &gt;&gt;&gt; p = Point(1, y=2) Point(x=1, y=2) &gt;&gt;&gt; p[0] 1 &gt;&gt;&gt; p.x 1 &gt;&gt;&gt; getattr(p, 'y') 2 &gt;&gt;&gt; p._fields # Or: Point._fields ('x', 'y') Range &lt;range&gt; = range(to_exclusive) &lt;range&gt; = range(from_inclusive, to_exclusive) &lt;range&gt; = range(from_inclusive, to_exclusive, ±step_size) from_inclusive = &lt;range&gt;.start to_exclusive = &lt;range&gt;.stop Enumerate for i, el in enumerate(&lt;collection&gt; [, i_start]): ... Iterator &lt;iter&gt; = iter(&lt;collection&gt;) # `iter(&lt;iter&gt;)` returns unmodified iterator. &lt;iter&gt; = iter(&lt;function&gt;, to_exclusive) # A sequence of return values until 'to_exclusive'. &lt;el&gt; = next(&lt;iter&gt; [, default]) # Raises StopIteration or returns 'default' on end. &lt;list&gt; = list(&lt;iter&gt;) # Returns a list of iterator's remaining elements. Itertools from itertools import count, repeat, cycle, chain, islice &lt;iter&gt; = count(start=0, step=1) # Returns updated value endlessly. Accepts floats. &lt;iter&gt; = repeat(&lt;el&gt; [, times]) # Returns element endlessly or 'times' times. &lt;iter&gt; = cycle(&lt;collection&gt;) # Repeats the sequence endlessly. &lt;iter&gt; = chain(&lt;coll_1&gt;, &lt;coll_2&gt; [, ...]) # Empties collections in order. &lt;iter&gt; = chain.from_iterable(&lt;collection&gt;) # Empties collections inside a collection in order. &lt;iter&gt; = islice(&lt;collection&gt;, to_exclusive) &lt;iter&gt; = islice(&lt;collection&gt;, from_inclusive, to_exclusive [, +step_size]) Generator Any function that contains a yield statement returns a generator. Generators and iterators are interchangeable. def count(start, step): while True: yield start start += step &gt;&gt;&gt; counter = count(10, 2) &gt;&gt;&gt; next(counter), next(counter), next(counter) (10, 12, 14) Type Everything is an object. Every object has a type. Type and class are synonymous. &lt;type&gt; = type(&lt;el&gt;) # Or: &lt;el&gt;.__class__ &lt;bool&gt; = isinstance(&lt;el&gt;, &lt;type&gt;) # Or: issubclass(type(&lt;el&gt;), &lt;type&gt;) &gt;&gt;&gt; type('a'), 'a'.__class__, str (&lt;class 'str'&gt;, &lt;class 'str'&gt;, &lt;class 'str'&gt;) Some types do not have built-in names, so they must be imported: from types import FunctionType, MethodType, LambdaType, GeneratorType Abstract Base Classes Each abstract base class specifies a set of virtual subclasses. These classes are then recognized by isinstance() and issubclass() as subclasses of the ABC, although they are really not. &gt;&gt;&gt; from collections.abc import Sequence, Collection, Iterable &gt;&gt;&gt; isinstance([1, 2, 3], Iterable) True +------------------+------------+------------+------------+ | | Sequence | Collection | Iterable | +------------------+------------+------------+------------+ | list, range, str | yes | yes | yes | | dict, set | | yes | yes | | iter | | | yes | +------------------+------------+------------+------------+ &gt;&gt;&gt; from numbers import Integral, Rational, Real, Complex, Number &gt;&gt;&gt; isinstance(123, Number) True +--------------------+----------+----------+----------+----------+----------+ | | Integral | Rational | Real | Complex | Number | +--------------------+----------+----------+----------+----------+----------+ | int | yes | yes | yes | yes | yes | | fractions.Fraction | | yes | yes | yes | yes | | float | | | yes | yes | yes | | complex | | | | yes | yes | | decimal.Decimal | | | | | yes | +--------------------+----------+----------+----------+----------+----------+ String &lt;str&gt; = &lt;str&gt;.strip() # Strips all whitespace characters from both ends. &lt;str&gt; = &lt;str&gt;.strip('&lt;chars&gt;') # Strips all passed characters from both ends. &lt;list&gt; = &lt;str&gt;.split() # Splits on one or more whitespace characters. &lt;list&gt; = &lt;str&gt;.split(sep=None, maxsplit=-1) # Splits on 'sep' str at most 'maxsplit' times. &lt;list&gt; = &lt;str&gt;.splitlines(keepends=False) # Splits on \\n,\\r,\\r\\n. Keeps them if 'keepends'. &lt;str&gt; = &lt;str&gt;.join(&lt;coll_of_strings&gt;) # Joins elements using string as separator. &lt;bool&gt; = &lt;sub_str&gt; in &lt;str&gt; # Checks if string contains a substring. &lt;bool&gt; = &lt;str&gt;.startswith(&lt;sub_str&gt;) # Pass tuple of strings for multiple options. &lt;bool&gt; = &lt;str&gt;.endswith(&lt;sub_str&gt;) # Pass tuple of strings for multiple options. &lt;int&gt; = &lt;str&gt;.find(&lt;sub_str&gt;) # Returns start index of first match or -1. &lt;int&gt; = &lt;str&gt;.index(&lt;sub_str&gt;) # Same but raises ValueError if missing. &lt;str&gt; = &lt;str&gt;.replace(old, new [, count]) # Replaces 'old' with 'new' at most 'count' times. &lt;str&gt; = &lt;str&gt;.translate(&lt;table&gt;) # Use `str.maketrans(&lt;dict&gt;)` to generate table. &lt;str&gt; = chr(&lt;int&gt;) # Converts int to Unicode char. &lt;int&gt; = ord(&lt;str&gt;) # Converts Unicode char to int. Also: 'lstrip()', 'rstrip()'. Also: 'lower()', 'upper()', 'capitalize()' and 'title()'. Property Methods +---------------+----------+----------+----------+----------+----------+ | | [ !#$%…] | [a-zA-Z] | [¼½¾] | [²³¹] | [0-9] | +---------------+----------+----------+----------+----------+----------+ | isprintable() | yes | yes | yes | yes | yes | | isalnum() | | yes | yes | yes | yes | | isnumeric() | | | yes | yes | yes | | isdigit() | | | | yes | yes | | isdecimal() | | | | | yes | +---------------+----------+----------+----------+----------+----------+ Also: 'isspace()' checks for '[ \\t\\n\\r\\f\\v…]'. Regex import re &lt;str&gt; = re.sub(&lt;regex&gt;, new, text, count=0) # Substitutes all occurrences with 'new'. &lt;list&gt; = re.findall(&lt;regex&gt;, text) # Returns all occurrences as strings. &lt;list&gt; = re.split(&lt;regex&gt;, text, maxsplit=0) # Use brackets in regex to include the matches. &lt;Match&gt; = re.search(&lt;regex&gt;, text) # Searches for first occurrence of the pattern. &lt;Match&gt; = re.match(&lt;regex&gt;, text) # Searches only at the beginning of the text. &lt;iter&gt; = re.finditer(&lt;regex&gt;, text) # Returns all occurrences as match objects. Search() and match() return None if they can't find a match. Argument 'flags=re.IGNORECASE' can be used with all functions. Argument 'flags=re.MULTILINE' makes '^' and '$' match the start/end of each line. Argument 'flags=re.DOTALL' makes dot also accept the '\\n'. Use r'\\1' or '\\\\1' for backreference. Add '?' after an operator to make it non-greedy. Match Object &lt;str&gt; = &lt;Match&gt;.group() # Returns the whole match. Also group(0). &lt;str&gt; = &lt;Match&gt;.group(1) # Returns part in the first bracket. &lt;tuple&gt; = &lt;Match&gt;.groups() # Returns all bracketed parts. &lt;int&gt; = &lt;Match&gt;.start() # Returns start index of the match. &lt;int&gt; = &lt;Match&gt;.end() # Returns exclusive end index of the match. Special Sequences By default digits, alphanumerics and whitespaces from all alphabets are matched, unless 'flags=re.ASCII' argument is used. Use a capital letter for negation. '\\d' == '[0-9]' # Matches any digit. '\\w' == '[a-zA-Z0-9_]' # Matches any alphanumeric. '\\s' == '[ \\t\\n\\r\\f\\v]' # Matches any whitespace. Format &lt;str&gt; = f'{&lt;el_1&gt;}, {&lt;el_2&gt;}' &lt;str&gt; = '{}, {}'.format(&lt;el_1&gt;, &lt;el_2&gt;) Attributes &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Person = namedtuple('Person', 'name height') &gt;&gt;&gt; person = Person('Jean-Luc', 187) &gt;&gt;&gt; f'{person.height}' '187' &gt;&gt;&gt; '{p.height}'.format(p=person) '187' General Options {&lt;el&gt;:&lt;10} # '&lt;el&gt; ' {&lt;el&gt;:^10} # ' &lt;el&gt; ' {&lt;el&gt;:&gt;10} # ' &lt;el&gt;' {&lt;el&gt;:.&lt;10} # '&lt;el&gt;......' {&lt;el&gt;:&lt;0} # '&lt;el&gt;' Strings '!r' calls object's repr() method, instead of str(), to get a string. {'abcde'!r:10} # &quot;'abcde' &quot; {'abcde':10.3} # 'abc ' {'abcde':.3} # 'abc' Numbers { 123456:10,} # ' 123,456' { 123456:10_} # ' 123_456' { 123456:+10} # ' +123456' {-123456:=10} # '- 123456' { 123456: } # ' 123456' {-123456: } # '-123456' Floats {1.23456:10.3} # ' 1.23' {1.23456:10.3f} # ' 1.235' {1.23456:10.3e} # ' 1.235e+00' {1.23456:10.3%} # ' 123.456%' Comparison of presentation types: +---------------+-----------------+-----------------+-----------------+-----------------+ | | {&lt;float&gt;} | {&lt;float&gt;:f} | {&lt;float&gt;:e} | {&lt;float&gt;:%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | '5.6789e-05' | '0.000057' | '5.678900e-05' | '0.005679%' | | 0.00056789 | '0.00056789' | '0.000568' | '5.678900e-04' | '0.056789%' | | 0.0056789 | '0.0056789' | '0.005679' | '5.678900e-03' | '0.567890%' | | 0.056789 | '0.056789' | '0.056789' | '5.678900e-02' | '5.678900%' | | 0.56789 | '0.56789' | '0.567890' | '5.678900e-01' | '56.789000%' | | 5.6789 | '5.6789' | '5.678900' | '5.678900e+00' | '567.890000%' | | 56.789 | '56.789' | '56.789000' | '5.678900e+01' | '5678.900000%' | | 567.89 | '567.89' | '567.890000' | '5.678900e+02' | '56789.000000%' | +---------------+-----------------+-----------------+-----------------+-----------------+ +---------------+-----------------+-----------------+-----------------+-----------------+ | | {&lt;float&gt;:.2} | {&lt;float&gt;:.2f} | {&lt;float&gt;:.2e} | {&lt;float&gt;:.2%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | '5.7e-05' | '0.00' | '5.68e-05' | '0.01%' | | 0.00056789 | '0.00057' | '0.00' | '5.68e-04' | '0.06%' | | 0.0056789 | '0.0057' | '0.01' | '5.68e-03' | '0.57%' | | 0.056789 | '0.057' | '0.06' | '5.68e-02' | '5.68%' | | 0.56789 | '0.57' | '0.57' | '5.68e-01' | '56.79%' | | 5.6789 | '5.7' | '5.68' | '5.68e+00' | '567.89%' | | 56.789 | '5.7e+01' | '56.79' | '5.68e+01' | '5678.90%' | | 567.89 | '5.7e+02' | '567.89' | '5.68e+02' | '56789.00%' | +---------------+-----------------+-----------------+-----------------+-----------------+ Ints {90:c} # 'Z' {90:b} # '1011010' {90:X} # '5A' Numbers Types &lt;int&gt; = int(&lt;float/str/bool&gt;) # Or: math.floor(&lt;float&gt;) &lt;float&gt; = float(&lt;int/str/bool&gt;) # Or: &lt;real&gt;e±&lt;int&gt; &lt;complex&gt; = complex(real=0, imag=0) # Or: &lt;real&gt; ± &lt;real&gt;j &lt;Fraction&gt; = fractions.Fraction(0, 1) # Or: Fraction(numerator=0, denominator=1) &lt;Decimal&gt; = decimal.Decimal(&lt;str/int&gt;) # Or: Decimal((sign, digits, exponent)) 'int(&lt;str&gt;)' and 'float(&lt;str&gt;)' raise ValueError on malformed strings. Decimal numbers can be represented exactly, unlike floats where '1.1 + 2.2 != 3.3'. Precision of decimal operations is set with: 'decimal.getcontext().prec = &lt;int&gt;'. Basic Functions &lt;num&gt; = pow(&lt;num&gt;, &lt;num&gt;) # Or: &lt;num&gt; ** &lt;num&gt; &lt;num&gt; = abs(&lt;num&gt;) # &lt;float&gt; = abs(&lt;complex&gt;) &lt;num&gt; = round(&lt;num&gt; [, ±ndigits]) # `round(126, -1) == 130` Math from math import e, pi, inf, nan, isinf, isnan from math import cos, acos, sin, asin, tan, atan, degrees, radians from math import log, log10, log2 Statistics from statistics import mean, median, variance, stdev, pvariance, pstdev Random from random import random, randint, choice, shuffle &lt;float&gt; = random() &lt;int&gt; = randint(from_inclusive, to_inclusive) &lt;el&gt; = choice(&lt;list&gt;) shuffle(&lt;list&gt;) Bin, Hex &lt;int&gt; = 0b&lt;bin&gt; # Or: 0x&lt;hex&gt; &lt;int&gt; = int('±&lt;bin&gt;', 2) # Or: int('±&lt;hex&gt;', 16) &lt;int&gt; = int('±0b&lt;bin&gt;', 0) # Or: int('±0x&lt;hex&gt;', 0) '[-]0b&lt;bin&gt;' = bin(&lt;int&gt;) # Or: hex(&lt;int&gt;) Bitwise Operators &lt;int&gt; = &lt;int&gt; &amp; &lt;int&gt; # And &lt;int&gt; = &lt;int&gt; | &lt;int&gt; # Or &lt;int&gt; = &lt;int&gt; ^ &lt;int&gt; # Xor (0 if both bits equal) &lt;int&gt; = &lt;int&gt; &lt;&lt; n_bits # Shift left (&gt;&gt; for right) &lt;int&gt; = ~&lt;int&gt; # Not (also: -&lt;int&gt; - 1) Combinatorics Every function returns an iterator. If you want to print the iterator, you need to pass it to the list() function first! from itertools import product, combinations, combinations_with_replacement, permutations &gt;&gt;&gt; product([0, 1], repeat=3) [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)] &gt;&gt;&gt; product('ab', '12') [('a', '1'), ('a', '2'), ('b', '1'), ('b', '2')] &gt;&gt;&gt; combinations('abc', 2) [('a', 'b'), ('a', 'c'), ('b', 'c')] &gt;&gt;&gt; combinations_with_replacement('abc', 2) [('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')] &gt;&gt;&gt; permutations('abc', 2) [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')] Datetime Module 'datetime' provides 'date' &lt;D&gt;, 'time' &lt;T&gt;, 'datetime' &lt;DT&gt; and 'timedelta' &lt;TD&gt; classes. All are immutable and hashable. Time and datetime objects can be 'aware' &lt;a&gt;, meaning they have defined timezone, or 'naive' &lt;n&gt;, meaning they don't. If object is naive, it is presumed to be in the system's timezone. from datetime import date, time, datetime, timedelta from dateutil.tz import UTC, tzlocal, gettz, resolve_imaginary Constructors &lt;D&gt; = date(year, month, day) &lt;T&gt; = time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0) &lt;DT&gt; = datetime(year, month, day, hour=0, minute=0, second=0, ...) &lt;TD&gt; = timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) Use '&lt;D/DT&gt;.weekday()' to get the day of the week (Mon == 0). 'fold=1' means the second pass in case of time jumping back for one hour. '&lt;DTa&gt; = resolve_imaginary(&lt;DTa&gt;)' fixes DTs that fall into the missing hour. Now &lt;D/DTn&gt; = D/DT.today() # Current local date or naive datetime. &lt;DTn&gt; = DT.utcnow() # Naive datetime from current UTC time. &lt;DTa&gt; = DT.now(&lt;tzinfo&gt;) # Aware datetime from current tz time. To extract time use '&lt;DTn&gt;.time()', '&lt;DTa&gt;.time()' or '&lt;DTa&gt;.timetz()'. Timezone &lt;tzinfo&gt; = UTC # UTC timezone. London without DST. &lt;tzinfo&gt; = tzlocal() # Local timezone. Also gettz(). &lt;tzinfo&gt; = gettz('&lt;Continent&gt;/&lt;City&gt;') # 'Continent/City_Name' timezone or None. &lt;DTa&gt; = &lt;DT&gt;.astimezone(&lt;tzinfo&gt;) # Datetime, converted to passed timezone. &lt;Ta/DTa&gt; = &lt;T/DT&gt;.replace(tzinfo=&lt;tzinfo&gt;) # Unconverted object with new timezone. Encode &lt;D/T/DT&gt; = D/T/DT.fromisoformat('&lt;iso&gt;') # Object from ISO string. Raises ValueError. &lt;DT&gt; = DT.strptime(&lt;str&gt;, '&lt;format&gt;') # Datetime from str, according to format. &lt;D/DTn&gt; = D/DT.fromordinal(&lt;int&gt;) # D/DTn from days since Christ, at midnight. &lt;DTn&gt; = DT.fromtimestamp(&lt;real&gt;) # Local time DTn from seconds since Epoch. &lt;DTa&gt; = DT.fromtimestamp(&lt;real&gt;, &lt;tz.&gt;) # Aware datetime from seconds since Epoch. ISO strings come in following forms: 'YYYY-MM-DD', 'HH:MM:SS.ffffff[±&lt;offset&gt;]', or both separated by an arbitrary character. Offset is formatted as: 'HH:MM'. Epoch on Unix systems is: '1970-01-01 00:00 UTC', '1970-01-01 01:00 CET', ... Decode &lt;str&gt; = &lt;D/T/DT&gt;.isoformat(sep='T') # Also timespec='auto/hours/minutes/seconds'. &lt;str&gt; = &lt;D/T/DT&gt;.strftime('&lt;format&gt;') # Custom string representation. &lt;int&gt; = &lt;D/DT&gt;.toordinal() # Days since Christ, ignoring time and tz. &lt;float&gt; = &lt;DTn&gt;.timestamp() # Seconds since Epoch, from DTn in local tz. &lt;float&gt; = &lt;DTa&gt;.timestamp() # Seconds since Epoch, from DTa. Format &gt;&gt;&gt; from datetime import datetime &gt;&gt;&gt; dt = datetime.strptime('2015-05-14 23:39:00.00 +0200', '%Y-%m-%d %H:%M:%S.%f %z') &gt;&gt;&gt; dt.strftime(&quot;%A, %dth of %B '%y, %I:%M%p %Z&quot;) &quot;Thursday, 14th of May '15, 11:39PM UTC+02:00&quot; When parsing, '%z' also accepts '±HH:MM'. For abbreviated weekday and month use '%a' and '%b'. Arithmetics &lt;D/DT&gt; = &lt;D/DT&gt; ± &lt;TD&gt; # Returned datetime can fall into missing hour. &lt;TD&gt; = &lt;D/DTn&gt; - &lt;D/DTn&gt; # Returns the difference, ignoring time jumps. &lt;TD&gt; = &lt;DTa&gt; - &lt;DTa&gt; # Ignores time jumps if they share tzinfo object. &lt;TD&gt; = &lt;DT_UTC&gt; - &lt;DT_UTC&gt; # Convert DTs to UTC to get the actual delta. Arguments Inside Function Call &lt;function&gt;(&lt;positional_args&gt;) # f(0, 0) &lt;function&gt;(&lt;keyword_args&gt;) # f(x=0, y=0) &lt;function&gt;(&lt;positional_args&gt;, &lt;keyword_args&gt;) # f(0, y=0) Inside Function Definition def f(&lt;nondefault_args&gt;): # def f(x, y): def f(&lt;default_args&gt;): # def f(x=0, y=0): def f(&lt;nondefault_args&gt;, &lt;default_args&gt;): # def f(x, y=0): Splat Operator Inside Function Call Splat expands a collection into positional arguments, while splatty-splat expands a dictionary into keyword arguments. args = (1, 2) kwargs = {'x': 3, 'y': 4, 'z': 5} func(*args, **kwargs) Is the same as: func(1, 2, x=3, y=4, z=5) Inside Function Definition Splat combines zero or more positional arguments into a tuple, while splatty-splat combines zero or more keyword arguments into a dictionary. def add(*a): return sum(a) &gt;&gt;&gt; add(1, 2, 3) 6 Legal argument combinations: def f(x, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*, x, y, z): # f(x=1, y=2, z=3) def f(x, *, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, y, *, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) def f(*args): # f(1, 2, 3) def f(x, *args): # f(1, 2, 3) def f(*args, z): # f(1, 2, z=3) def f(x, *args, z): # f(1, 2, z=3) def f(**kwargs): # f(x=1, y=2, z=3) def f(x, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(*, x, **kwargs): # f(x=1, y=2, z=3) def f(*args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(x, *args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*args, y, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, *args, z, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) Other Uses &lt;list&gt; = [*&lt;collection&gt; [, ...]] &lt;set&gt; = {*&lt;collection&gt; [, ...]} &lt;tuple&gt; = (*&lt;collection&gt;, [...]) &lt;dict&gt; = {**&lt;dict&gt; [, ...]} head, *body, tail = &lt;collection&gt; Inline Lambda &lt;function&gt; = lambda: &lt;return_value&gt; &lt;function&gt; = lambda &lt;argument_1&gt;, &lt;argument_2&gt;: &lt;return_value&gt; Comprehension &lt;list&gt; = [i+1 for i in range(10)] # [1, 2, ..., 10] &lt;set&gt; = {i for i in range(10) if i &gt; 5} # {6, 7, 8, 9} &lt;iter&gt; = (i+5 for i in range(10)) # (5, 6, ..., 14) &lt;dict&gt; = {i: i*2 for i in range(10)} # {0: 0, 1: 2, ..., 9: 18} out = [i+j for i in range(10) for j in range(10)] Is the same as: out = [] for i in range(10): for j in range(10): out.append(i+j) Map, Filter, Reduce from functools import reduce &lt;iter&gt; = map(lambda x: x + 1, range(10)) # (1, 2, ..., 10) &lt;iter&gt; = filter(lambda x: x &gt; 5, range(10)) # (6, 7, 8, 9) &lt;obj&gt; = reduce(lambda out, x: out + x, range(10)) # 45 Any, All &lt;bool&gt; = any(&lt;collection&gt;) # False if empty. &lt;bool&gt; = all(el[1] for el in &lt;collection&gt;) # True if empty. If - Else &lt;obj&gt; = &lt;expression_if_true&gt; if &lt;condition&gt; else &lt;expression_if_false&gt; &gt;&gt;&gt; [a if a else 'zero' for a in (0, 1, 2, 3)] ['zero', 1, 2, 3] Namedtuple, Enum, Dataclass from collections import namedtuple Point = namedtuple('Point', 'x y') point = Point(0, 0) from enum import Enum Direction = Enum('Direction', 'n e s w') direction = Direction.n from dataclasses import make_dataclass Creature = make_dataclass('Creature', ['location', 'direction']) creature = Creature(Point(0, 0), Direction.n) Closure We have a closure in Python when: A nested function references a value of its enclosing function and then the enclosing function returns the nested function. def get_multiplier(a): def out(b): return a * b return out &gt;&gt;&gt; multiply_by_3 = get_multiplier(3) &gt;&gt;&gt; multiply_by_3(10) 30 If multiple nested functions within enclosing function reference the same value, that value gets shared. To dynamically access function's first free variable use '&lt;function&gt;.__closure__[0].cell_contents'. Partial from functools import partial &lt;function&gt; = partial(&lt;function&gt; [, &lt;arg_1&gt;, &lt;arg_2&gt;, ...]) &gt;&gt;&gt; import operator as op &gt;&gt;&gt; multiply_by_3 = partial(op.mul, 3) &gt;&gt;&gt; multiply_by_3(10) 30 Partial is also useful in cases when function needs to be passed as an argument, because it enables us to set its arguments beforehand. A few examples being: 'defaultdict(&lt;function&gt;)', 'iter(&lt;function&gt;, to_exclusive)' and dataclass's 'field(default_factory=&lt;function&gt;)'. Non-Local If variable is being assigned to anywhere in the scope, it is regarded as a local variable, unless it is declared as a 'global' or a 'nonlocal'. def get_counter(): i = 0 def out(): nonlocal i i += 1 return i return out &gt;&gt;&gt; counter = get_counter() &gt;&gt;&gt; counter(), counter(), counter() (1, 2, 3) Decorator A decorator takes a function, adds some functionality and returns it. @decorator_name def function_that_gets_passed_to_decorator(): ... Debugger Example Decorator that prints function's name every time it gets called. from functools import wraps def debug(func): @wraps(func) def out(*args, **kwargs): print(func.__name__) return func(*args, **kwargs) return out @debug def add(x, y): return x + y Wraps is a helper decorator that copies the metadata of the passed function (func) to the function it is wrapping (out). Without it 'add.__name__' would return 'out'. LRU Cache Decorator that caches function's return values. All function's arguments must be hashable. from functools import lru_cache @lru_cache(maxsize=None) def fib(n): return n if n &lt; 2 else fib(n-2) + fib(n-1) CPython interpreter limits recursion depth to 1000 by default. To increase it use 'sys.setrecursionlimit(&lt;depth&gt;)'. Parametrized Decorator A decorator that accepts arguments and returns a normal decorator that accepts a function. from functools import wraps def debug(print_result=False): def decorator(func): @wraps(func) def out(*args, **kwargs): result = func(*args, **kwargs) print(func.__name__, result if print_result else '') return result return out return decorator @debug(print_result=True) def add(x, y): return x + y Class class &lt;name&gt;: def __init__(self, a): self.a = a def __repr__(self): class_name = self.__class__.__name__ return f'{class_name}({self.a!r})' def __str__(self): return str(self.a) @classmethod def get_class_name(cls): return cls.__name__ Return value of repr() should be unambiguous and of str() readable. If only repr() is defined, it will also be used for str(). Str() use cases: print(&lt;el&gt;) print(f'{&lt;el&gt;}') raise Exception(&lt;el&gt;) loguru.logger.debug(&lt;el&gt;) csv.writer(&lt;file&gt;).writerow([&lt;el&gt;]) Repr() use cases: print([&lt;el&gt;]) print(f'{&lt;el&gt;!r}') &gt;&gt;&gt; &lt;el&gt; loguru.logger.exception() Z = dataclasses.make_dataclass('Z', ['a']); print(Z(&lt;el&gt;)) Constructor Overloading class &lt;name&gt;: def __init__(self, a=None): self.a = a Inheritance class Person: def __init__(self, name, age): self.name = name self.age = age class Employee(Person): def __init__(self, name, age, staff_num): super().__init__(name, age) self.staff_num = staff_num Multiple Inheritance class A: pass class B: pass class C(A, B): pass MRO determines the order in which parent classes are traversed when searching for a method: &gt;&gt;&gt; C.mro() [&lt;class 'C'&gt;, &lt;class 'A'&gt;, &lt;class 'B'&gt;, &lt;class 'object'&gt;] Property Pythonic way of implementing getters and setters. class MyClass: @property def a(self): return self._a @a.setter def a(self, value): self._a = value &gt;&gt;&gt; el = MyClass() &gt;&gt;&gt; el.a = 123 &gt;&gt;&gt; el.a 123 Dataclass Decorator that automatically generates init(), repr() and eq() special methods. from dataclasses import dataclass, field @dataclass(order=False, frozen=False) class &lt;class_name&gt;: &lt;attr_name_1&gt;: &lt;type&gt; &lt;attr_name_2&gt;: &lt;type&gt; = &lt;default_value&gt; &lt;attr_name_3&gt;: list/dict/set = field(default_factory=list/dict/set) Objects can be made sortable with 'order=True' and/or immutable and hashable with 'frozen=True'. Function field() is needed because '&lt;attr_name&gt;: list = []' would make a list that is shared among all instances. Default_factory can be any callable. Inline: from dataclasses import make_dataclass &lt;class&gt; = make_dataclass('&lt;class_name&gt;', &lt;coll_of_attribute_names&gt;) &lt;class&gt; = make_dataclass('&lt;class_name&gt;', &lt;coll_of_tuples&gt;) &lt;tuple&gt; = ('&lt;attr_name&gt;', &lt;type&gt; [, &lt;default_value&gt;]) Slots Mechanism that restricts objects to attributes listed in 'slots' and significantly reduces their memory footprint. class MyClassWithSlots: __slots__ = ['a'] def __init__(self): self.a = 1 Copy from copy import copy, deepcopy &lt;object&gt; = copy(&lt;object&gt;) &lt;object&gt; = deepcopy(&lt;object&gt;) Duck Types A duck type is an implicit type that prescribes a set of special methods. Any object that has those methods defined is considered a member of that duck type. Comparable If eq() method is not overridden, it returns 'id(self) == id(other)', which is the same as 'self is other'. That means all objects compare not equal by default. Only the left side object has eq() method called, unless it returns NotImplemented, in which case the right object is consulted. class MyComparable: def __init__(self, a): self.a = a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented Hashable Hashable object needs both hash() and eq() methods and its hash value should never change. Hashable objects that compare equal must have the same hash value, meaning default hash() that returns 'id(self)' will not do. That is why Python automatically makes classes unhashable if you only implement eq(). class MyHashable: def __init__(self, a): self._a = a @property def a(self): return self._a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented def __hash__(self): return hash(self.a) Sortable With total_ordering decorator, you only need to provide eq() and one of lt(), gt(), le() or ge() special methods. from functools import total_ordering @total_ordering class MySortable: def __init__(self, a): self.a = a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented def __lt__(self, other): if isinstance(other, type(self)): return self.a &lt; other.a return NotImplemented Iterator Any object that has methods next() and iter() is an iterator. Next() should return next item or raise StopIteration. Iter() should return 'self'. class Counter: def __init__(self): self.i = 0 def __next__(self): self.i += 1 return self.i def __iter__(self): return self &gt;&gt;&gt; counter = Counter() &gt;&gt;&gt; next(counter), next(counter), next(counter) (1, 2, 3) Python has many different iterator objects: Iterators returned by the iter() function, such as list_iterator and set_iterator. Objects returned by the itertools module, such as count, repeat and cycle. Generators returned by the generator functions and generator expressions. File objects returned by the open() function, etc. Callable All functions and classes have a call() method, hence are callable. When this cheatsheet uses '&lt;function&gt;' as an argument, it actually means '&lt;callable&gt;'. class Counter: def __init__(self): self.i = 0 def __call__(self): self.i += 1 return self.i &gt;&gt;&gt; counter = Counter() &gt;&gt;&gt; counter(), counter(), counter() (1, 2, 3) Context Manager Enter() should lock the resources and optionally return an object. Exit() should release the resources. Any exception that happens inside the with block is passed to the exit() method. If it wishes to suppress the exception it must return a true value. class MyOpen: def __init__(self, filename): self.filename = filename def __enter__(self): self.file = open(self.filename) return self.file def __exit__(self, exc_type, exception, traceback): self.file.close() &gt;&gt;&gt; with open('test.txt', 'w') as file: ... file.write('Hello World!') &gt;&gt;&gt; with MyOpen('test.txt') as file: ... print(file.read()) Hello World! Iterable Duck Types Iterable Only required method is iter(). It should return an iterator of object's items. Contains() automatically works on any object that has iter() defined. class MyIterable: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a &gt;&gt;&gt; obj = MyIterable([1, 2, 3]) &gt;&gt;&gt; [el for el in obj] [1, 2, 3] &gt;&gt;&gt; 1 in obj True Collection Only required methods are iter() and len(). This cheatsheet actually means '&lt;iterable&gt;' when it uses '&lt;collection&gt;'. I chose not to use the name 'iterable' because it sounds scarier and more vague than 'collection'. class MyCollection: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a def __len__(self): return len(self.a) Sequence Only required methods are len() and getitem(). Getitem() should return an item at index or raise IndexError. Iter() and contains() automatically work on any object that has getitem() defined. Reversed() automatically works on any object that has getitem() and len() defined. class MySequence: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a def __len__(self): return len(self.a) def __getitem__(self, i): return self.a[i] def __reversed__(self): return reversed(self.a) ABC Sequence It's a richer interface than the basic sequence. Extending it generates iter(), contains(), reversed(), index() and count(). Unlike 'abc.Iterable' and 'abc.Collection', it is not a duck type. That is why 'issubclass(MySequence, abc.Sequence)' would return False even if MySequence had all the methods defined. from collections import abc class MyAbcSequence(abc.Sequence): def __init__(self, a): self.a = a def __len__(self): return len(self.a) def __getitem__(self, i): return self.a[i] Table of required and automatically available special methods: +------------+------------+------------+------------+--------------+ | | Iterable | Collection | Sequence | abc.Sequence | +------------+------------+------------+------------+--------------+ | iter() | REQ | REQ | Yes | Yes | | contains() | Yes | Yes | Yes | Yes | | len() | | REQ | REQ | REQ | | getitem() | | | REQ | REQ | | reversed() | | | Yes | Yes | | index() | | | | Yes | | count() | | | | Yes | +------------+------------+------------+------------+--------------+ Other ABCs that generate missing methods are: MutableSequence, Set, MutableSet, Mapping and MutableMapping. Names of their required methods are stored in '&lt;abc&gt;.__abstractmethods__'. Enum from enum import Enum, auto class &lt;enum_name&gt;(Enum): &lt;member_name_1&gt; = &lt;value_1&gt; &lt;member_name_2&gt; = &lt;value_2_a&gt;, &lt;value_2_b&gt; &lt;member_name_3&gt; = auto() If there are no numeric values before auto(), it returns 1. Otherwise it returns an increment of the last numeric value. &lt;member&gt; = &lt;enum&gt;.&lt;member_name&gt; # Returns a member. &lt;member&gt; = &lt;enum&gt;['&lt;member_name&gt;'] # Returns a member or raises KeyError. &lt;member&gt; = &lt;enum&gt;(&lt;value&gt;) # Returns a member or raises ValueError. &lt;str&gt; = &lt;member&gt;.name # Returns member's name. &lt;obj&gt; = &lt;member&gt;.value # Returns member's value. list_of_members = list(&lt;enum&gt;) member_names = [a.name for a in &lt;enum&gt;] member_values = [a.value for a in &lt;enum&gt;] random_member = random.choice(list(&lt;enum&gt;)) def get_next_member(member): members = list(member.__class__) index = (members.index(member) + 1) % len(members) return members[index] Inline Cutlery = Enum('Cutlery', 'fork knife spoon') Cutlery = Enum('Cutlery', ['fork', 'knife', 'spoon']) Cutlery = Enum('Cutlery', {'fork': 1, 'knife': 2, 'spoon': 3}) User-defined functions cannot be values, so they must be wrapped: from functools import partial LogicOp = Enum('LogicOp', {'AND': partial(lambda l, r: l and r), 'OR' : partial(lambda l, r: l or r)}) Another solution in this particular case is to use built-in functions and_() and or_() from the module operator. Exceptions Basic Example try: &lt;code&gt; except &lt;exception&gt;: &lt;code&gt; Complex Example try: &lt;code_1&gt; except &lt;exception_a&gt;: &lt;code_2_a&gt; except &lt;exception_b&gt;: &lt;code_2_b&gt; else: &lt;code_2_c&gt; finally: &lt;code_3&gt; Catching Exceptions except &lt;exception&gt;: except &lt;exception&gt; as &lt;name&gt;: except (&lt;exception&gt;, ...): except (&lt;exception&gt;, ...) as &lt;name&gt;: Also catches subclasses of the exception. Use 'traceback.print_exc()' to print the error message to stderr. Raising Exceptions raise &lt;exception&gt; raise &lt;exception&gt;() raise &lt;exception&gt;(&lt;el&gt; [, ...]) Re-raising caught exception: except &lt;exception&gt; as &lt;name&gt;: ... raise Exception Object arguments = &lt;name&gt;.args exc_type = &lt;name&gt;.__class__ filename = &lt;name&gt;.__traceback__.tb_frame.f_code.co_filename func_name = &lt;name&gt;.__traceback__.tb_frame.f_code.co_name line = linecache.getline(filename, &lt;name&gt;.__traceback__.tb_lineno) error_msg = traceback.format_exception(exc_type, &lt;name&gt;, &lt;name&gt;.__traceback__) Built-in Exceptions BaseException +-- SystemExit # Raised by the sys.exit() function. +-- KeyboardInterrupt # Raised when the user hits the interrupt key (ctrl-c). +-- Exception # User-defined exceptions should be derived from this class. +-- ArithmeticError # Base class for arithmetic errors. | +-- ZeroDivisionError # Raised when dividing by zero. +-- AttributeError # Raised when an attribute is missing. +-- EOFError # Raised by input() when it hits end-of-file condition. +-- LookupError # Raised when a look-up on a collection fails. | +-- IndexError # Raised when a sequence index is out of range. | +-- KeyError # Raised when a dictionary key or set element is not found. +-- NameError # Raised when a variable name is not found. +-- OSError # Failures such as “file not found” or “disk full”. | +-- FileNotFoundError # When a file or directory is requested but doesn't exist. +-- RuntimeError # Raised by errors that don't fall into other categories. | +-- RecursionError # Raised when the maximum recursion depth is exceeded. +-- StopIteration # Raised by next() when run on an empty iterator. +-- TypeError # Raised when an argument is of wrong type. +-- ValueError # When an argument is of right type but inappropriate value. +-- UnicodeError # Raised when encoding/decoding strings to/from bytes fails. Collections and their exceptions: +-----------+------------+------------+------------+ | | list | dict | set | +-----------+------------+------------+------------+ | getitem() | IndexError | KeyError | | | pop() | IndexError | KeyError | KeyError | | remove() | ValueError | | KeyError | | index() | ValueError | | | +-----------+------------+------------+------------+ Useful built-in exceptions: raise TypeError('Argument is of wrong type!') raise ValueError('Argument is of right type but inappropriate value!') raise RuntimeError('None of above!') User-defined Exceptions class MyError(Exception): pass class MyInputError(MyError): pass Exit Exits the interpreter by raising SystemExit exception. import sys sys.exit() # Exits with exit code 0 (success). sys.exit(&lt;el&gt;) # Prints to stderr and exits with 1. sys.exit(&lt;int&gt;) # Exits with passed exit code. Print print(&lt;el_1&gt;, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Use 'file=sys.stderr' for messages about errors. Use 'flush=True' to forcibly flush the stream. Pretty Print from pprint import pprint pprint(&lt;collection&gt;, width=80, depth=None, compact=False, sort_dicts=True) Levels deeper than 'depth' get replaced by '...'. Input Reads a line from user input or pipe if present. &lt;str&gt; = input(prompt=None) Trailing newline gets stripped. Prompt string is printed to the standard output before reading input. Raises EOFError when user hits EOF (ctrl-d/z) or input stream gets exhausted. Command Line Arguments import sys script_name = sys.argv[0] arguments = sys.argv[1:] Argument Parser from argparse import ArgumentParser, FileType p = ArgumentParser(description=&lt;str&gt;) p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', action='store_true') # Flag p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', type=&lt;type&gt;) # Option p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs=1) # First argument p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='+') # Remaining arguments p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='*') # Optional arguments args = p.parse_args() # Exits on error. value = args.&lt;name&gt; Use 'help=&lt;str&gt;' to set argument description. Use 'default=&lt;el&gt;' to set the default value. Use 'type=FileType(&lt;mode&gt;)' for files. Open Opens the file and returns a corresponding file object. &lt;file&gt; = open('&lt;path&gt;', mode='r', encoding=None, newline=None) 'encoding=None' means that the default encoding is used, which is platform dependent. Best practice is to use 'encoding=&quot;utf-8&quot;' whenever possible. 'newline=None' means all different end of line combinations are converted to '\\n' on read, while on write all '\\n' characters are converted to system's default line separator. 'newline=&quot;&quot;' means no conversions take place, but input is still broken into chunks by readline() and readlines() on either '\\n', '\\r' or '\\r\\n'. Modes 'r' - Read (default). 'w' - Write (truncate). 'x' - Write or fail if the file already exists. 'a' - Append. 'w+' - Read and write (truncate). 'r+' - Read and write from the start. 'a+' - Read and write from the end. 't' - Text mode (default). 'b' - Binary mode. Exceptions 'FileNotFoundError' can be raised when reading with 'r' or 'r+'. 'FileExistsError' can be raised when writing with 'x'. 'IsADirectoryError' and 'PermissionError' can be raised by any. 'OSError' is the parent class of all listed exceptions. File Object &lt;file&gt;.seek(0) # Moves to the start of the file. &lt;file&gt;.seek(offset) # Moves 'offset' chars/bytes from the start. &lt;file&gt;.seek(0, 2) # Moves to the end of the file. &lt;bin_file&gt;.seek(±offset, &lt;anchor&gt;) # Anchor: 0 start, 1 current position, 2 end. &lt;str/bytes&gt; = &lt;file&gt;.read(size=-1) # Reads 'size' chars/bytes or until EOF. &lt;str/bytes&gt; = &lt;file&gt;.readline() # Returns a line or empty string/bytes on EOF. &lt;list&gt; = &lt;file&gt;.readlines() # Returns a list of remaining lines. &lt;str/bytes&gt; = next(&lt;file&gt;) # Returns a line using buffer. Do not mix. &lt;file&gt;.write(&lt;str/bytes&gt;) # Writes a string or bytes object. &lt;file&gt;.writelines(&lt;collection&gt;) # Writes a coll. of strings or bytes objects. &lt;file&gt;.flush() # Flushes write buffer. Methods do not add or strip trailing newlines, even writelines(). Read Text from File def read_file(filename): with open(filename, encoding='utf-8') as file: return file.readlines() Write Text to File def write_to_file(filename, text): with open(filename, 'w', encoding='utf-8') as file: file.write(text) Path from os import getcwd, path, listdir from glob import glob &lt;str&gt; = getcwd() # Returns the current working directory. &lt;str&gt; = path.join(&lt;path&gt;, ...) # Joins two or more pathname components. &lt;str&gt; = path.abspath(&lt;path&gt;) # Returns absolute path. &lt;str&gt; = path.basename(&lt;path&gt;) # Returns final component of the path. &lt;str&gt; = path.dirname(&lt;path&gt;) # Returns path without the final component. &lt;tup.&gt; = path.splitext(&lt;path&gt;) # Splits on last period of the final component. &lt;list&gt; = listdir(path='.') # Returns filenames located at path. &lt;list&gt; = glob('&lt;pattern&gt;') # Returns paths matching the wildcard pattern. &lt;bool&gt; = path.exists(&lt;path&gt;) # Or: &lt;Path&gt;.exists() &lt;bool&gt; = path.isfile(&lt;path&gt;) # Or: &lt;DirEntry/Path&gt;.is_file() &lt;bool&gt; = path.isdir(&lt;path&gt;) # Or: &lt;DirEntry/Path&gt;.is_dir() DirEntry Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type information. from os import scandir &lt;iter&gt; = scandir(path='.') # Returns DirEntry objects located at path. &lt;str&gt; = &lt;DirEntry&gt;.path # Returns path as a string. &lt;str&gt; = &lt;DirEntry&gt;.name # Returns final component as a string. &lt;file&gt; = open(&lt;DirEntry&gt;) # Opens the file and returns file object. Path Object from pathlib import Path &lt;Path&gt; = Path(&lt;path&gt; [, ...]) # Accepts strings, Paths and DirEntry objects. &lt;Path&gt; = &lt;path&gt; / &lt;path&gt; [/ ...] # One of the paths must be a Path object. &lt;Path&gt; = Path() # Returns relative cwd. Also Path('.'). &lt;Path&gt; = Path.cwd() # Returns absolute cwd. Also Path().resolve(). &lt;Path&gt; = &lt;Path&gt;.resolve() # Returns absolute Path without symlinks. &lt;Path&gt; = &lt;Path&gt;.parent # Returns Path without final component. &lt;str&gt; = &lt;Path&gt;.name # Returns final component as a string. &lt;str&gt; = &lt;Path&gt;.stem # Returns final component without extension. &lt;str&gt; = &lt;Path&gt;.suffix # Returns final component's extension. &lt;tup.&gt; = &lt;Path&gt;.parts # Returns all components as strings. &lt;iter&gt; = &lt;Path&gt;.iterdir() # Returns dir contents as Path objects. &lt;iter&gt; = &lt;Path&gt;.glob('&lt;pattern&gt;') # Returns Paths matching the wildcard pattern. &lt;str&gt; = str(&lt;Path&gt;) # Returns path as a string. &lt;file&gt; = open(&lt;Path&gt;) # Opens the file and returns file object. OS Commands Files and Directories Paths can be either strings, Paths or DirEntry objects. Functions report OS related errors by raising either OSError or one of its subclasses. import os, shutil os.chdir(&lt;path&gt;) # Changes the current working directory. os.mkdir(&lt;path&gt;, mode=0o777) # Creates a directory. Mode is in octal. shutil.copy(from, to) # Copies the file. 'to' can exist or be a dir. shutil.copytree(from, to) # Copies the directory. 'to' must not exist. os.rename(from, to) # Renames/moves the file or directory. os.replace(from, to) # Same, but overwrites 'to' if it exists. os.remove(&lt;path&gt;) # Deletes the file. os.rmdir(&lt;path&gt;) # Deletes the empty directory. shutil.rmtree(&lt;path&gt;) # Deletes the directory. Shell Commands import os &lt;str&gt; = os.popen('&lt;shell_command&gt;').read() Sends '1 + 1' to the basic calculator and captures its output: &gt;&gt;&gt; from subprocess import run &gt;&gt;&gt; run('bc', input='1 + 1\\n', capture_output=True, encoding='utf-8') CompletedProcess(args='bc', returncode=0, stdout='2\\n', stderr='') Sends test.in to the basic calculator running in standard mode and saves its output to test.out: &gt;&gt;&gt; from shlex import split &gt;&gt;&gt; os.popen('echo 1 + 1 &gt; test.in') &gt;&gt;&gt; run(split('bc -s'), stdin=open('test.in'), stdout=open('test.out', 'w')) CompletedProcess(args=['bc', '-s'], returncode=0) &gt;&gt;&gt; open('test.out').read() '2\\n' JSON Text file format for storing collections of strings and numbers. import json &lt;str&gt; = json.dumps(&lt;object&gt;, ensure_ascii=True, indent=None) &lt;object&gt; = json.loads(&lt;str&gt;) Read Object from JSON File def read_json_file(filename): with open(filename, encoding='utf-8') as file: return json.load(file) Write Object to JSON File def write_to_json_file(filename, an_object): with open(filename, 'w', encoding='utf-8') as file: json.dump(an_object, file, ensure_ascii=False, indent=2) Pickle Binary file format for storing objects. import pickle &lt;bytes&gt; = pickle.dumps(&lt;object&gt;) &lt;object&gt; = pickle.loads(&lt;bytes&gt;) Read Object from File def read_pickle_file(filename): with open(filename, 'rb') as file: return pickle.load(file) Write Object to File def write_to_pickle_file(filename, an_object): with open(filename, 'wb') as file: pickle.dump(an_object, file) CSV Text file format for storing spreadsheets. import csv Read &lt;reader&gt; = csv.reader(&lt;file&gt;) # Also: `dialect='excel', delimiter=','`. &lt;list&gt; = next(&lt;reader&gt;) # Returns next row as a list of strings. &lt;list&gt; = list(&lt;reader&gt;) # Returns list of remaining rows. File must be opened with 'newline=&quot;&quot;' argument, or newlines embedded inside quoted fields will not be interpreted correctly! Write &lt;writer&gt; = csv.writer(&lt;file&gt;) # Also: `dialect='excel', delimiter=','`. &lt;writer&gt;.writerow(&lt;collection&gt;) # Encodes objects using `str(&lt;el&gt;)`. &lt;writer&gt;.writerows(&lt;coll_of_coll&gt;) # Appends multiple rows. File must be opened with 'newline=&quot;&quot;' argument, or '\\r' will be added in front of every '\\n' on platforms that use '\\r\\n' line endings! Parameters 'dialect' - Master parameter that sets the default values. 'delimiter' - A one-character string used to separate fields. 'quotechar' - Character for quoting fields that contain special characters. 'doublequote' - Whether quotechars inside fields get doubled or escaped. 'skipinitialspace' - Whether whitespace after delimiter gets stripped. 'lineterminator' - Specifies how writer terminates rows. 'quoting' - Controls the amount of quoting: 0 - as necessary, 1 - all. 'escapechar' - Character for escaping 'quotechar' if 'doublequote' is False. Dialects +------------------+--------------+--------------+--------------+ | | excel | excel-tab | unix | +------------------+--------------+--------------+--------------+ | delimiter | ',' | '\\t' | ',' | | quotechar | '&quot;' | '&quot;' | '&quot;' | | doublequote | True | True | True | | skipinitialspace | False | False | False | | lineterminator | '\\r\\n' | '\\r\\n' | '\\n' | | quoting | 0 | 0 | 1 | | escapechar | None | None | None | +------------------+--------------+--------------+--------------+ Read Rows from CSV File def read_csv_file(filename): with open(filename, encoding='utf-8', newline='') as file: return list(csv.reader(file)) Write Rows to CSV File def write_to_csv_file(filename, rows): with open(filename, 'w', encoding='utf-8', newline='') as file: writer = csv.writer(file) writer.writerows(rows) SQLite Server-less database engine that stores each database into a separate file. Connect Opens a connection to the database file. Creates a new file if path doesn't exist. import sqlite3 &lt;con&gt; = sqlite3.connect('&lt;path&gt;') # Also ':memory:'. &lt;con&gt;.close() Read Returned values can be of type str, int, float, bytes or None. &lt;cursor&gt; = &lt;con&gt;.execute('&lt;query&gt;') # Can raise a subclass of sqlite3.Error. &lt;tuple&gt; = &lt;cursor&gt;.fetchone() # Returns next row. Also next(&lt;cursor&gt;). &lt;list&gt; = &lt;cursor&gt;.fetchall() # Returns remaining rows. Also list(&lt;cursor&gt;). Write &lt;con&gt;.execute('&lt;query&gt;') &lt;con&gt;.commit() Or: with &lt;con&gt;: &lt;con&gt;.execute('&lt;query&gt;') Placeholders Passed values can be of type str, int, float, bytes, None, bool, datetime.date or datetime.datetme. Bools will be stored and returned as ints and dates as ISO formatted strings. &lt;con&gt;.execute('&lt;query&gt;', &lt;list/tuple&gt;) # Replaces '?'s in query with values. &lt;con&gt;.execute('&lt;query&gt;', &lt;dict/namedtuple&gt;) # Replaces ':&lt;key&gt;'s with values. &lt;con&gt;.executemany('&lt;query&gt;', &lt;coll_of_above&gt;) # Runs execute() many times. Example In this example values are not actually saved because 'con.commit()' is omitted! &gt;&gt;&gt; con = sqlite3.connect('test.db') &gt;&gt;&gt; con.execute('create table person (person_id integer primary key, name, height)') &gt;&gt;&gt; con.execute('insert into person values (null, ?, ?)', ('Jean-Luc', 187)).lastrowid 1 &gt;&gt;&gt; con.execute('select * from person').fetchall() [(1, 'Jean-Luc', 187)] MySQL Has a very similar interface, with differences listed below. # $ pip3 install mysql-connector from mysql import connector &lt;con&gt; = connector.connect(host=&lt;str&gt;, …) # `user=&lt;str&gt;, password=&lt;str&gt;, database=&lt;str&gt;`. &lt;cursor&gt; = &lt;con&gt;.cursor() # Only cursor has execute method. &lt;cursor&gt;.execute('&lt;query&gt;') # Can raise a subclass of connector.Error. &lt;cursor&gt;.execute('&lt;query&gt;', &lt;list/tuple&gt;) # Replaces '%s's in query with values. &lt;cursor&gt;.execute('&lt;query&gt;', &lt;dict/namedtuple&gt;) # Replaces '%(&lt;key&gt;)s's with values. Bytes Bytes object is an immutable sequence of single bytes. Mutable version is called bytearray. &lt;bytes&gt; = b'&lt;str&gt;' # Only accepts ASCII characters and \\x00 - \\xff. &lt;int&gt; = &lt;bytes&gt;[&lt;index&gt;] # Returns int in range from 0 to 255. &lt;bytes&gt; = &lt;bytes&gt;[&lt;slice&gt;] # Returns bytes even if it has only one element. &lt;bytes&gt; = &lt;bytes&gt;.join(&lt;coll_of_bytes&gt;) # Joins elements using bytes object as separator. Encode &lt;bytes&gt; = bytes(&lt;coll_of_ints&gt;) # Ints must be in range from 0 to 255. &lt;bytes&gt; = bytes(&lt;str&gt;, 'utf-8') # Or: &lt;str&gt;.encode('utf-8') &lt;bytes&gt; = &lt;int&gt;.to_bytes(n_bytes, …) # `byteorder='big/little', signed=False`. &lt;bytes&gt; = bytes.fromhex('&lt;hex&gt;') # Hex numbers can be separated by spaces. Decode &lt;list&gt; = list(&lt;bytes&gt;) # Returns ints in range from 0 to 255. &lt;str&gt; = str(&lt;bytes&gt;, 'utf-8') # Or: &lt;bytes&gt;.decode('utf-8') &lt;int&gt; = int.from_bytes(&lt;bytes&gt;, …) # `byteorder='big/little', signed=False`. '&lt;hex&gt;' = &lt;bytes&gt;.hex() # Returns a string of hexadecimal numbers. Read Bytes from File def read_bytes(filename): with open(filename, 'rb') as file: return file.read() Write Bytes to File def write_bytes(filename, bytes_obj): with open(filename, 'wb') as file: file.write(bytes_obj) Struct Module that performs conversions between a sequence of numbers and a bytes object. Machine’s native type sizes and byte order are used by default. from struct import pack, unpack, iter_unpack &lt;bytes&gt; = pack('&lt;format&gt;', &lt;num_1&gt; [, &lt;num_2&gt;, ...]) &lt;tuple&gt; = unpack('&lt;format&gt;', &lt;bytes&gt;) &lt;tuples&gt; = iter_unpack('&lt;format&gt;', &lt;bytes&gt;) Example &gt;&gt;&gt; pack('&gt;hhl', 1, 2, 3) b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03' &gt;&gt;&gt; unpack('&gt;hhl', b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03') (1, 2, 3) Format For standard type sizes start format string with: '=' - native byte order '&lt;' - little-endian '&gt;' - big-endian (also '!') Integer types. Use a capital letter for unsigned type. Standard sizes are in brackets: 'x' - pad byte 'b' - char (1) 'h' - short (2) 'i' - int (4) 'l' - long (4) 'q' - long long (8) Floating point types: 'f' - float (4) 'd' - double (8) Array List that can only hold numbers of a predefined type. Available types and their sizes in bytes are listed above. from array import array &lt;array&gt; = array('&lt;typecode&gt;', &lt;collection&gt;) # Array from collection of numbers. &lt;array&gt; = array('&lt;typecode&gt;', &lt;bytes&gt;) # Array from bytes object. &lt;array&gt; = array('&lt;typecode&gt;', &lt;array&gt;) # Treats array as a sequence of numbers. &lt;bytes&gt; = bytes(&lt;array&gt;) # Or: &lt;array&gt;.tobytes() Memory View A sequence object that points to the memory of another object. Each element can reference a single or multiple consecutive bytes, depending on format. Order and number of elements can be changed with slicing. &lt;mview&gt; = memoryview(&lt;bytes/bytearray/array&gt;) # Immutable if bytes, else mutable. &lt;real&gt; = &lt;mview&gt;[&lt;index&gt;] # Returns an int or a float. &lt;mview&gt; = &lt;mview&gt;[&lt;slice&gt;] # Mview with rearranged elements. &lt;mview&gt; = &lt;mview&gt;.cast('&lt;typecode&gt;') # Casts memoryview to the new format. &lt;mview&gt;.release() # Releases the object's memory buffer. Decode &lt;bin_file&gt;.write(&lt;mview&gt;) # Writes mview to the binary file. &lt;bytes&gt; = bytes(&lt;mview&gt;) # Creates a new bytes object. &lt;bytes&gt; = &lt;bytes&gt;.join(&lt;coll_of_mviews&gt;) # Joins mviews using bytes object as sep. &lt;array&gt; = array('&lt;typecode&gt;', &lt;mview&gt;) # Treats mview as a sequence of numbers. &lt;list&gt; = list(&lt;mview&gt;) # Returns list of ints or floats. &lt;str&gt; = str(&lt;mview&gt;, 'utf-8') # Treats mview as a bytes object. &lt;int&gt; = int.from_bytes(&lt;mview&gt;, …) # `byteorder='big/little', signed=False`. '&lt;hex&gt;' = &lt;mview&gt;.hex() # Treats mview as a bytes object. Deque A thread-safe list with efficient appends and pops from either side. Pronounced &quot;deck&quot;. from collections import deque &lt;deque&gt; = deque(&lt;collection&gt;, maxlen=None) &lt;deque&gt;.appendleft(&lt;el&gt;) # Opposite element is dropped if full. &lt;deque&gt;.extendleft(&lt;collection&gt;) # Collection gets reversed. &lt;el&gt; = &lt;deque&gt;.popleft() # Raises IndexError if empty. &lt;deque&gt;.rotate(n=1) # Rotates elements to the right. Threading CPython interpreter can only run a single thread at a time. That is why using multiple threads won't result in a faster execution, unless at least one of the threads contains an I/O operation. from threading import Thread, RLock, Semaphore, Event, Barrier Thread &lt;Thread&gt; = Thread(target=&lt;function&gt;) # Use `args=&lt;collection&gt;` to set arguments. &lt;Thread&gt;.start() # Starts the thread. &lt;bool&gt; = &lt;Thread&gt;.is_alive() # Checks if thread has finished executing. &lt;Thread&gt;.join() # Waits for thread to finish. Use 'kwargs=&lt;dict&gt;' to pass keyword arguments to the function. Use 'daemon=True', or the program will not be able to exit while the thread is alive. Lock &lt;lock&gt; = RLock() &lt;lock&gt;.acquire() # Waits for lock to be available. &lt;lock&gt;.release() # Makes the lock available again. Or: lock = RLock() with lock: ... Semaphore, Event, Barrier &lt;Semaphore&gt; = Semaphore(value=1) # Lock that can be acquired 'value' times. &lt;Event&gt; = Event() # Method wait() blocks until set() is called. &lt;Barrier&gt; = Barrier(n_times) # Method wait() blocks until it's called 'n_times'. Thread Pool Executor from concurrent.futures import ThreadPoolExecutor with ThreadPoolExecutor(max_workers=None) as executor: # Does not exit until done. &lt;iter&gt; = executor.map(lambda x: x + 1, range(3)) # (1, 2, 3) &lt;iter&gt; = executor.map(lambda x, y: x + y, 'abc', '123') # ('a1', 'b2', 'c3') &lt;Future&gt; = executor.submit(&lt;function&gt; [, &lt;arg_1&gt;, ...]) # Also visible outside block. Future: &lt;bool&gt; = &lt;Future&gt;.done() # Checks if thread has finished executing. &lt;obj&gt; = &lt;Future&gt;.result() # Waits for thread to finish and returns result. Queue A thread-safe FIFO queue. For LIFO queue use LifoQueue. from queue import Queue &lt;Queue&gt; = Queue(maxsize=0) &lt;Queue&gt;.put(&lt;el&gt;) # Blocks until queue stops being full. &lt;Queue&gt;.put_nowait(&lt;el&gt;) # Raises queue.Full exception if full. &lt;el&gt; = &lt;Queue&gt;.get() # Blocks until queue stops being empty. &lt;el&gt; = &lt;Queue&gt;.get_nowait() # Raises queue.Empty exception if empty. Operator Module of functions that provide the functionality of operators. from operator import add, sub, mul, truediv, floordiv, mod, pow, neg, abs from operator import eq, ne, lt, le, gt, ge from operator import and_, or_, not_ from operator import itemgetter, attrgetter, methodcaller import operator as op elementwise_sum = map(op.add, list_a, list_b) sorted_by_second = sorted(&lt;collection&gt;, key=op.itemgetter(1)) sorted_by_both = sorted(&lt;collection&gt;, key=op.itemgetter(1, 0)) product_of_elems = functools.reduce(op.mul, &lt;collection&gt;) LogicOp = enum.Enum('LogicOp', {'AND': op.and_, 'OR' : op.or_}) last_el = op.methodcaller('pop')(&lt;list&gt;) Introspection Inspecting code at runtime. Variables &lt;list&gt; = dir() # Names of local variables (incl. functions). &lt;dict&gt; = vars() # Dict of local variables. Also locals(). &lt;dict&gt; = globals() # Dict of global variables. Attributes &lt;list&gt; = dir(&lt;object&gt;) # Names of object's attributes (incl. methods). &lt;dict&gt; = vars(&lt;object&gt;) # Dict of object's fields. Also &lt;obj&gt;.__dict__. &lt;bool&gt; = hasattr(&lt;object&gt;, '&lt;attr_name&gt;') # Checks if getattr() raises an error. value = getattr(&lt;object&gt;, '&lt;attr_name&gt;') # Raises AttributeError if attribute is missing. setattr(&lt;object&gt;, '&lt;attr_name&gt;', value) # Only works on objects with __dict__ attribute. delattr(&lt;object&gt;, '&lt;attr_name&gt;') # Equivalent to `del &lt;object&gt;.&lt;attr_name&gt;`. Parameters from inspect import signature &lt;sig&gt; = signature(&lt;function&gt;) no_of_params = len(&lt;sig&gt;.parameters) param_names = list(&lt;sig&gt;.parameters.keys()) param_kinds = [a.kind for a in &lt;sig&gt;.parameters.values()] Metaprograming Code that generates code. Type Type is the root class. If only passed an object it returns its type (class). Otherwise it creates a new class. &lt;class&gt; = type('&lt;class_name&gt;', &lt;parents_tuple&gt;, &lt;attributes_dict&gt;) &gt;&gt;&gt; Z = type('Z', (), {'a': 'abcde', 'b': 12345}) &gt;&gt;&gt; z = Z() Meta Class A class that creates classes. def my_meta_class(name, parents, attrs): attrs['a'] = 'abcde' return type(name, parents, attrs) Or: class MyMetaClass(type): def __new__(cls, name, parents, attrs): attrs['a'] = 'abcde' return type.__new__(cls, name, parents, attrs) New() is a class method that gets called before init(). If it returns an instance of its class, then that instance gets passed to init() as a 'self' argument. It receives the same arguments as init(), except for the first one that specifies the desired type of the returned instance (MyMetaClass in our case). Like in our case, new() can also be called directly, usually from a new() method of a child class (def __new__(cls): return super().__new__(cls)). The only difference between the examples above is that my_meta_class() returns a class of type type, while MyMetaClass() returns a class of type MyMetaClass. Metaclass Attribute Right before a class is created it checks if it has the 'metaclass' attribute defined. If not, it recursively checks if any of his parents has it defined and eventually comes to type(). class MyClass(metaclass=MyMetaClass): b = 12345 &gt;&gt;&gt; MyClass.a, MyClass.b ('abcde', 12345) Type Diagram type(MyClass) == MyMetaClass # MyClass is an instance of MyMetaClass. type(MyMetaClass) == type # MyMetaClass is an instance of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass --&gt; MyMetaClass | | | v | | object -----&gt; type &lt;+ | | | ^ +--+ | | str ----------+ | +-------------+-------------+ Inheritance Diagram MyClass.__base__ == object # MyClass is a subclass of object. MyMetaClass.__base__ == type # MyMetaClass is a subclass of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass | MyMetaClass | | v | v | | object &lt;----- type | | ^ | | | str | | +-------------+-------------+ Eval &gt;&gt;&gt; from ast import literal_eval &gt;&gt;&gt; literal_eval('1 + 2') 3 &gt;&gt;&gt; literal_eval('[1, 2, 3]') [1, 2, 3] &gt;&gt;&gt; literal_eval('abs(1)') ValueError: malformed node or string Coroutines Coroutines have a lot in common with threads, but unlike threads, they only give up control when they call another coroutine and they don’t use as much memory. Coroutine definition starts with 'async' and its call with 'await'. 'asyncio.run(&lt;coroutine&gt;)' is the main entry point for asynchronous programs. Functions wait(), gather() and as_completed() can be used when multiple coroutines need to be started at the same time. Asyncio module also provides its own Queue, Event, Lock and Semaphore classes. Runs a terminal game where you control an asterisk that must avoid numbers: import asyncio, collections, curses, enum, random P = collections.namedtuple('P', 'x y') # Position D = enum.Enum('D', 'n e s w') # Direction def main(screen): curses.curs_set(0) # Makes cursor invisible. screen.nodelay(True) # Makes getch() non-blocking. asyncio.run(main_coroutine(screen)) # Starts running asyncio code. async def main_coroutine(screen): state = {'*': P(0, 0), **{id_: P(30, 10) for id_ in range(10)}} moves = asyncio.Queue() coros = (*(random_controller(id_, moves) for id_ in range(10)), human_controller(screen, moves), model(moves, state, *screen.getmaxyx()), view(state, screen)) await asyncio.wait(coros, return_when=asyncio.FIRST_COMPLETED) async def random_controller(id_, moves): while True: moves.put_nowait((id_, random.choice(list(D)))) await asyncio.sleep(random.random() / 2) async def human_controller(screen, moves): while True: ch = screen.getch() key_mappings = {259: D.n, 261: D.e, 258: D.s, 260: D.w} if ch in key_mappings: moves.put_nowait(('*', key_mappings[ch])) await asyncio.sleep(0.01) async def model(moves, state, height, width): while state['*'] not in {p for id_, p in state.items() if id_ != '*'}: id_, d = await moves.get() p = state[id_] deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)} new_p = P(*[sum(a) for a in zip(p, deltas[d])]) if 0 &lt;= new_p.x &lt; width-1 and 0 &lt;= new_p.y &lt; height: state[id_] = new_p async def view(state, screen): while True: screen.clear() for id_, p in state.items(): screen.addstr(p.y, p.x, str(id_)) await asyncio.sleep(0.01) curses.wrapper(main) Libraries Progress Bar # $ pip3 install tqdm from tqdm import tqdm from time import sleep for el in tqdm([1, 2, 3]): sleep(0.2) Plot # $ pip3 install matplotlib from matplotlib import pyplot pyplot.plot(&lt;y_data&gt; [, label=&lt;str&gt;]) pyplot.plot(&lt;x_data&gt;, &lt;y_data&gt;) pyplot.legend() # Adds a legend. pyplot.savefig('&lt;path&gt;') # Saves the figure. pyplot.show() # Displays the figure. pyplot.clf() # Clears the figure. Table Prints a CSV file as an ASCII table: # $ pip3 install tabulate import csv, tabulate with open('test.csv', encoding='utf-8', newline='') as file: rows = csv.reader(file) header = [a.title() for a in next(rows)] table = tabulate.tabulate(rows, header) print(table) Curses Clears the terminal, prints a message and waits for the ESC key press: from curses import wrapper, curs_set, ascii from curses import KEY_UP, KEY_RIGHT, KEY_DOWN, KEY_LEFT def main(): wrapper(draw) def draw(screen): curs_set(0) # Makes cursor invisible. screen.nodelay(True) # Makes getch() non-blocking. screen.clear() screen.addstr(0, 0, 'Press ESC to quit.') # Coordinates are y, x. while screen.getch() != ascii.ESC: pass def get_border(screen): from collections import namedtuple P = namedtuple('P', 'x y') height, width = screen.getmaxyx() return P(width-1, height-1) if __name__ == '__main__': main() Logging # $ pip3 install loguru from loguru import logger logger.add('debug_{time}.log', colorize=True) # Connects a log file. logger.add('error_{time}.log', level='ERROR') # Another file for errors or higher. logger.&lt;level&gt;('A logging message.') Levels: 'debug', 'info', 'success', 'warning', 'error', 'critical'. Exceptions Exception description, stack trace and values of variables are appended automatically. try: ... except &lt;exception&gt;: logger.exception('An error happened.') Rotation Argument that sets a condition when a new log file is created. rotation=&lt;int&gt;|&lt;datetime.timedelta&gt;|&lt;datetime.time&gt;|&lt;str&gt; '&lt;int&gt;' - Max file size in bytes. '&lt;timedelta&gt;' - Max age of a file. '&lt;time&gt;' - Time of day. '&lt;str&gt;' - Any of above as a string: '100 MB', '1 month', 'monday at 12:00', ... Retention Sets a condition which old log files get deleted. retention=&lt;int&gt;|&lt;datetime.timedelta&gt;|&lt;str&gt; '&lt;int&gt;' - Max number of files. '&lt;timedelta&gt;' - Max age of a file. '&lt;str&gt;' - Max age as a string: '1 week, 3 days', '2 months', ... Scraping Scrapes Python's URL, version number and logo from Wikipedia page: # $ pip3 install requests beautifulsoup4 import requests, sys from bs4 import BeautifulSoup URL = 'https://en.wikipedia.org/wiki/Python_(programming_language)' try: html = requests.get(URL).text doc = BeautifulSoup(html, 'html.parser') table = doc.find('table', class_='infobox vevent') rows = table.find_all('tr') link = rows[11].find('a')['href'] ver = rows[6].find('div').text.split()[0] url_i = rows[0].find('img')['src'] image = requests.get(f'https:{url_i}').content with open('test.png', 'wb') as file: file.write(image) print(link, ver) except requests.exceptions.ConnectionError: print(&quot;You've got problems with connection.&quot;, file=sys.stderr) Web # $ pip3 install bottle from bottle import run, route, static_file, template, post, request, response import json Run run(host='localhost', port=8080) # Runs locally. run(host='0.0.0.0', port=80) # Runs globally. Static Request @route('/img/&lt;image&gt;') def send_image(image): return static_file(image, 'img_dir/', mimetype='image/png') Dynamic Request @route('/&lt;sport&gt;') def send_page(sport): return template('&lt;h1&gt;{{title}}&lt;/h1&gt;', title=sport) REST Request @post('/odds/&lt;sport&gt;') def odds_handler(sport): team = request.forms.get('team') home_odds, away_odds = 2.44, 3.29 response.headers['Content-Type'] = 'application/json' response.headers['Cache-Control'] = 'no-cache' return json.dumps([team, home_odds, away_odds]) Test: # $ pip3 install requests &gt;&gt;&gt; import requests &gt;&gt;&gt; url = 'http://localhost:8080/odds/football' &gt;&gt;&gt; data = {'team': 'arsenal f.c.'} &gt;&gt;&gt; response = requests.post(url, data=data) &gt;&gt;&gt; response.json() ['arsenal f.c.', 2.44, 3.29] Profiling Stopwatch from time import time start_time = time() # Seconds since the Epoch. ... duration = time() - start_time High performance: from time import perf_counter start_time = perf_counter() # Seconds since restart. ... duration = perf_counter() - start_time Timing a Snippet &gt;&gt;&gt; from timeit import timeit &gt;&gt;&gt; timeit('&quot;-&quot;.join(str(a) for a in range(100))', ... number=10000, globals=globals(), setup='pass') 0.34986 Profiling by Line # $ pip3 install line_profiler memory_profiler @profile def main(): a = [*range(10000)] b = {*range(10000)} main() $ kernprof -lv test.py Line # Hits Time Per Hit % Time Line Contents ======================================================= 1 @profile 2 def main(): 3 1 1128.0 1128.0 27.4 a = [*range(10000)] 4 1 2994.0 2994.0 72.6 b = {*range(10000)} $ python3 -m memory_profiler test.py Line # Mem usage Increment Line Contents ======================================================= 1 35.387 MiB 35.387 MiB @profile 2 def main(): 3 35.734 MiB 0.348 MiB a = [*range(10000)] 4 36.160 MiB 0.426 MiB b = {*range(10000)} Call Graph Generates a PNG image of a call graph with highlighted bottlenecks: # $ pip3 install pycallgraph from pycallgraph import output, PyCallGraph from datetime import datetime time_str = datetime.now().strftime('%Y%m%d%H%M%S') filename = f'profile-{time_str}.png' drawer = output.GraphvizOutput(output_file=filename) with PyCallGraph(drawer): &lt;code_to_be_profiled&gt; NumPy Array manipulation mini-language. It can run up to one hundred times faster than the equivalent Python code. # $ pip3 install numpy import numpy as np &lt;array&gt; = np.array(&lt;list&gt;) &lt;array&gt; = np.arange(from_inclusive, to_exclusive, ±step_size) &lt;array&gt; = np.ones(&lt;shape&gt;) &lt;array&gt; = np.random.randint(from_inclusive, to_exclusive, &lt;shape&gt;) &lt;array&gt;.shape = &lt;shape&gt; &lt;view&gt; = &lt;array&gt;.reshape(&lt;shape&gt;) &lt;view&gt; = np.broadcast_to(&lt;array&gt;, &lt;shape&gt;) &lt;array&gt; = &lt;array&gt;.sum(axis) indexes = &lt;array&gt;.argmin(axis) Shape is a tuple of dimension sizes. Axis is the index of a dimension that gets collapsed. The leftmost dimension has index 0. Indexing &lt;el&gt; = &lt;2d_array&gt;[0, 0] # First element. &lt;1d_view&gt; = &lt;2d_array&gt;[0] # First row. &lt;1d_view&gt; = &lt;2d_array&gt;[:, 0] # First column. Also [..., 0]. &lt;3d_view&gt; = &lt;2d_array&gt;[None, :, :] # Expanded by dimension of size 1. &lt;1d_array&gt; = &lt;2d_array&gt;[&lt;1d_row_indexes&gt;, &lt;1d_column_indexes&gt;] &lt;2d_array&gt; = &lt;2d_array&gt;[&lt;2d_row_indexes&gt;, &lt;2d_column_indexes&gt;] &lt;2d_bools&gt; = &lt;2d_array&gt; &gt; 0 &lt;1d_array&gt; = &lt;2d_array&gt;[&lt;2d_bools&gt;] If row and column indexes differ in shape, they are combined with broadcasting. Broadcasting Broadcasting is a set of rules by which NumPy functions operate on arrays of different sizes and/or dimensions. left = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [ 0.1 , 0.6 , 0.8 ] # Shape: (3) 1. If array shapes differ in length, left-pad the shorter shape with ones: left = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [[0.1 , 0.6 , 0.8]] # Shape: (1, 3) &lt;- ! 2. If any dimensions differ in size, expand the ones that have size 1 by duplicating their elements: left = [[0.1, 0.1, 0.1], [0.6, 0.6, 0.6], [0.8, 0.8, 0.8]] # Shape: (3, 3) &lt;- ! right = [[0.1, 0.6, 0.8], [0.1, 0.6, 0.8], [0.1, 0.6, 0.8]] # Shape: (3, 3) &lt;- ! 3. If neither non-matching dimension has size 1, raise an error. Example For each point returns index of its nearest point ([0.1, 0.6, 0.8] =&gt; [1, 2, 1]): &gt;&gt;&gt; points = np.array([0.1, 0.6, 0.8]) [ 0.1, 0.6, 0.8] &gt;&gt;&gt; wrapped_points = points.reshape(3, 1) [[ 0.1], [ 0.6], [ 0.8]] &gt;&gt;&gt; distances = wrapped_points - points [[ 0. , -0.5, -0.7], [ 0.5, 0. , -0.2], [ 0.7, 0.2, 0. ]] &gt;&gt;&gt; distances = np.abs(distances) [[ 0. , 0.5, 0.7], [ 0.5, 0. , 0.2], [ 0.7, 0.2, 0. ]] &gt;&gt;&gt; i = np.arange(3) [0, 1, 2] &gt;&gt;&gt; distances[i, i] = np.inf [[ inf, 0.5, 0.7], [ 0.5, inf, 0.2], [ 0.7, 0.2, inf]] &gt;&gt;&gt; distances.argmin(1) [1, 2, 1] Image # $ pip3 install pillow from PIL import Image &lt;Image&gt; = Image.new('&lt;mode&gt;', (width, height)) &lt;Image&gt; = Image.open('&lt;path&gt;') &lt;Image&gt; = &lt;Image&gt;.convert('&lt;mode&gt;') &lt;Image&gt;.save('&lt;path&gt;') &lt;Image&gt;.show() &lt;tuple/int&gt; = &lt;Image&gt;.getpixel((x, y)) # Returns a pixel. &lt;Image&gt;.putpixel((x, y), &lt;tuple/int&gt;) # Writes a pixel to the image. &lt;ImagingCore&gt; = &lt;Image&gt;.getdata() # Returns a sequence of pixels. &lt;Image&gt;.putdata(&lt;list/ImagingCore&gt;) # Writes a sequence of pixels. &lt;Image&gt;.paste(&lt;Image&gt;, (x, y)) # Writes an image to the image. &lt;2d_array&gt; = np.array(&lt;Image&gt;) # Creates NumPy array from greyscale image. &lt;3d_array&gt; = np.array(&lt;Image&gt;) # Creates NumPy array from color image. &lt;Image&gt; = Image.fromarray(&lt;array&gt;) # Creates image from NumPy array of floats. Modes '1' - 1-bit pixels, black and white, stored with one pixel per byte. 'L' - 8-bit pixels, greyscale. 'RGB' - 3x8-bit pixels, true color. 'RGBA' - 4x8-bit pixels, true color with transparency mask. 'HSV' - 3x8-bit pixels, Hue, Saturation, Value color space. Examples Creates a PNG image of a rainbow gradient: WIDTH, HEIGHT = 100, 100 size = WIDTH * HEIGHT hues = [255 * i/size for i in range(size)] img = Image.new('HSV', (WIDTH, HEIGHT)) img.putdata([(int(h), 255, 255) for h in hues]) img.convert('RGB').save('test.png') Adds noise to a PNG image: from random import randint add_noise = lambda value: max(0, min(255, value + randint(-20, 20))) img = Image.open('test.png').convert('HSV') img.putdata([(add_noise(h), s, v) for h, s, v in img.getdata()]) img.convert('RGB').save('test.png') Drawing from PIL import ImageDraw &lt;ImageDraw&gt; = ImageDraw.Draw(&lt;Image&gt;) &lt;ImageDraw&gt;.point((x, y), fill=None) &lt;ImageDraw&gt;.line((x1, y1, x2, y2 [, ...]), fill=None, width=0, joint=None) &lt;ImageDraw&gt;.arc((x1, y1, x2, y2), from_deg, to_deg, fill=None, width=0) &lt;ImageDraw&gt;.rectangle((x1, y1, x2, y2), fill=None, outline=None, width=0) &lt;ImageDraw&gt;.polygon((x1, y1, x2, y2 [, ...]), fill=None, outline=None) &lt;ImageDraw&gt;.ellipse((x1, y1, x2, y2), fill=None, outline=None, width=0) Use 'fill=&lt;color&gt;' to set the primary color. Use 'outline=&lt;color&gt;' to set the secondary color. Color can be specified as a tuple, int, '#rrggbb' string or a color name. Animation Creates a GIF of a bouncing ball: # $ pip3 install pillow imageio from PIL import Image, ImageDraw import imageio WIDTH, R = 126, 10 frames = [] for velocity in range(15): y = sum(range(velocity+1)) frame = Image.new('L', (WIDTH, WIDTH)) draw = ImageDraw.Draw(frame) draw.ellipse((WIDTH/2-R, y, WIDTH/2+R, y+R*2), fill='white') frames.append(frame) frames += reversed(frames[1:-1]) imageio.mimsave('test.gif', frames, duration=0.03) Audio import wave &lt;Wave_read&gt; = wave.open('&lt;path&gt;', 'rb') # Opens the WAV file. framerate = &lt;Wave_read&gt;.getframerate() # Number of frames per second. nchannels = &lt;Wave_read&gt;.getnchannels() # Number of samples per frame. sampwidth = &lt;Wave_read&gt;.getsampwidth() # Sample size in bytes. nframes = &lt;Wave_read&gt;.getnframes() # Number of frames. &lt;params&gt; = &lt;Wave_read&gt;.getparams() # Immutable collection of above. &lt;bytes&gt; = &lt;Wave_read&gt;.readframes(nframes) # Returns next 'nframes' frames. &lt;Wave_write&gt; = wave.open('&lt;path&gt;', 'wb') # Truncates existing file. &lt;Wave_write&gt;.setframerate(&lt;int&gt;) # 44100 for CD, 48000 for video. &lt;Wave_write&gt;.setnchannels(&lt;int&gt;) # 1 for mono, 2 for stereo. &lt;Wave_write&gt;.setsampwidth(&lt;int&gt;) # 2 for CD quality sound. &lt;Wave_write&gt;.setparams(&lt;params&gt;) # Sets all parameters. &lt;Wave_write&gt;.writeframes(&lt;bytes&gt;) # Appends frames to the file. Bytes object contains a sequence of frames, each consisting of one or more samples. In a stereo signal, the first sample of a frame belongs to the left channel. Each sample consists of one or more bytes that, when converted to an integer, indicate the displacement of a speaker membrane at a given moment. If sample width is one, then the integer should be encoded unsigned. For all other sizes, the integer should be encoded signed with little-endian byte order. Sample Values +-----------+-------------+------+-------------+ | sampwidth | min | zero | max | +-----------+-------------+------+-------------+ | 1 | 0 | 128 | 255 | | 2 | -32768 | 0 | 32767 | | 3 | -8388608 | 0 | 8388607 | | 4 | -2147483648 | 0 | 2147483647 | +-----------+-------------+------+-------------+ Read Float Samples from WAV File def read_wav_file(filename): def get_int(a_bytes): an_int = int.from_bytes(a_bytes, 'little', signed=width!=1) return an_int - 128 * (width == 1) with wave.open(filename, 'rb') as file: width = file.getsampwidth() frames = file.readframes(file.getnframes()) byte_samples = (frames[i: i + width] for i in range(0, len(frames), width)) return [get_int(b) / pow(2, width * 8 - 1) for b in byte_samples] Write Float Samples to WAV File def write_to_wav_file(filename, float_samples, nchannels=1, sampwidth=2, framerate=44100): def get_bytes(a_float): a_float = max(-1, min(1 - 2e-16, a_float)) a_float += sampwidth == 1 a_float *= pow(2, sampwidth * 8 - 1) return int(a_float).to_bytes(sampwidth, 'little', signed=sampwidth!=1) with wave.open(filename, 'wb') as file: file.setnchannels(nchannels) file.setsampwidth(sampwidth) file.setframerate(framerate) file.writeframes(b''.join(get_bytes(f) for f in float_samples)) Examples Saves a sine wave to a mono WAV file: from math import pi, sin samples_f = (sin(i * 2 * pi * 440 / 44100) for i in range(100000)) write_to_wav_file('test.wav', samples_f) Adds noise to a mono WAV file: from random import random add_noise = lambda value: value + (random() - 0.5) * 0.03 samples_f = (add_noise(f) for f in read_wav_file('test.wav')) write_to_wav_file('test.wav', samples_f) Plays a WAV file: # $ pip3 install simpleaudio from simpleaudio import play_buffer with wave.open('test.wav', 'rb') as file: p = file.getparams() frames = file.readframes(p.nframes) play_buffer(frames, p.nchannels, p.sampwidth, p.framerate) Text to Speech # $ pip3 install pyttsx3 import pyttsx3 engine = pyttsx3.init() engine.say('Sally sells seashells by the seashore.') engine.runAndWait() Synthesizer Plays Popcorn by Gershon Kingsley: # $ pip3 install simpleaudio import simpleaudio, math, struct from itertools import chain, repeat F = 44100 P1 = '71♪,69,,71♪,66,,62♪,66,,59♪,,,' P2 = '71♪,73,,74♪,73,,74,,71,,73♪,71,,73,,69,,71♪,69,,71,,67,,71♪,,,' get_pause = lambda seconds: repeat(0, int(seconds * F)) sin_f = lambda i, hz: math.sin(i * 2 * math.pi * hz / F) get_wave = lambda hz, seconds: (sin_f(i, hz) for i in range(int(seconds * F))) get_hz = lambda key: 8.176 * 2 ** (int(key) / 12) parse_note = lambda note: (get_hz(note[:2]), 0.25 if '♪' in note else 0.125) get_samples = lambda note: get_wave(*parse_note(note)) if note else get_pause(0.125) samples_f = chain.from_iterable(get_samples(n) for n in f'{P1}{P1}{P2}'.split(',')) samples_b = b''.join(struct.pack('&lt;h', int(f * 30000)) for f in samples_f) simpleaudio.play_buffer(samples_b, 1, 2, F) Pygame Basic Example # $ pip3 install pygame import pygame as pg pg.init() screen = pg.display.set_mode((500, 500)) rect = pg.Rect(240, 240, 20, 20) while all(event.type != pg.QUIT for event in pg.event.get()): deltas = {pg.K_UP: (0, -3), pg.K_RIGHT: (3, 0), pg.K_DOWN: (0, 3), pg.K_LEFT: (-3, 0)} for delta in (deltas.get(i) for i, on in enumerate(pg.key.get_pressed()) if on): rect = rect.move(delta) if delta else rect screen.fill((0, 0, 0)) pg.draw.rect(screen, (255, 255, 255), rect) pg.display.flip() Rectangle Object for storing rectangular coordinates. &lt;Rect&gt; = pg.Rect(x, y, width, height) # X and y are coordinates of topleft corner. &lt;int&gt; = &lt;Rect&gt;.x/y/centerx/centery/… # Top, right, bottom, left. &lt;tup.&gt; = &lt;Rect&gt;.topleft/center/… # Topright, bottomright, bottomleft. &lt;Rect&gt; = &lt;Rect&gt;.move((x, y)) # Use move_ip() to move in place. &lt;bool&gt; = &lt;Rect&gt;.collidepoint((x, y)) # Tests if a point is inside a rectangle. &lt;bool&gt; = &lt;Rect&gt;.colliderect(&lt;Rect&gt;) # Tests if two rectangles overlap. &lt;int&gt; = &lt;Rect&gt;.collidelist(&lt;list_of_Rect&gt;) # Returns index of first colliding Rect or -1. &lt;list&gt; = &lt;Rect&gt;.collidelistall(&lt;list_of_Rect&gt;) # Returns indexes of all colliding Rects. Surface Object for representing images. &lt;Surf&gt; = pg.display.set_mode((width, height)) # Returns the display surface. &lt;Surf&gt; = pg.Surface((width, height)) # Creates a new surface. &lt;Surf&gt; = pg.image.load('&lt;path&gt;') # Loads the image. &lt;Surf&gt; = &lt;Surf&gt;.subsurface(&lt;Rect&gt;) # Returns a subsurface. &lt;Surf&gt;.fill(color) # Fills the whole surface. &lt;Surf&gt;.set_at((x, y), color) # Updates pixel. &lt;Surf&gt;.blit(&lt;Surface&gt;, (x, y)) # Draws passed surface to the surface. &lt;Surf&gt; = pg.transform.flip(&lt;Surf&gt;, xbool, ybool) &lt;Surf&gt; = pg.transform.rotate(&lt;Surf&gt;, degrees) &lt;Surf&gt; = pg.transform.scale(&lt;Surf&gt;, (width, height)) pg.draw.line(&lt;Surf&gt;, color, (x1, y1), (x2, y2), width) pg.draw.arc(&lt;Surf&gt;, color, &lt;Rect&gt;, from_radians, to_radians) pg.draw.rect(&lt;Surf&gt;, color, &lt;Rect&gt;) pg.draw.polygon(&lt;Surf&gt;, color, points) pg.draw.ellipse(&lt;Surf&gt;, color, &lt;Rect&gt;) Font &lt;Font&gt; = pg.font.SysFont('&lt;name&gt;', size, bold=False, italic=False) &lt;Font&gt; = pg.font.Font('&lt;path&gt;', size) &lt;Surf&gt; = &lt;Font&gt;.render(text, antialias, color, background=None) Sound &lt;Sound&gt; = pg.mixer.Sound('&lt;path&gt;') # Loads the WAV file. &lt;Sound&gt;.play() # Starts playing the sound. Basic Mario Brothers Example import collections, dataclasses, enum, io, pygame, urllib.request, itertools as it from random import randint P = collections.namedtuple('P', 'x y') # Position D = enum.Enum('D', 'n e s w') # Direction SIZE, MAX_SPEED = 50, P(5, 10) # Screen size, Speed limit def main(): def get_screen(): pygame.init() return pygame.display.set_mode(2 * [SIZE*16]) def get_images(): url = 'https://gto76.github.io/python-cheatsheet/web/mario_bros.png' img = pygame.image.load(io.BytesIO(urllib.request.urlopen(url).read())) return [img.subsurface(get_rect(x, 0)) for x in range(img.get_width() // 16)] def get_mario(): Mario = dataclasses.make_dataclass('Mario', 'rect spd facing_left frame_cycle'.split()) return Mario(get_rect(1, 1), P(0, 0), False, it.cycle(range(3))) def get_tiles(): positions = [p for p in it.product(range(SIZE), repeat=2) if {*p} &amp; {0, SIZE-1}] + \\ [(randint(1, SIZE-2), randint(2, SIZE-2)) for _ in range(SIZE**2 // 10)] return [get_rect(*p) for p in positions] def get_rect(x, y): return pygame.Rect(x*16, y*16, 16, 16) run(get_screen(), get_images(), get_mario(), get_tiles()) def run(screen, images, mario, tiles): clock = pygame.time.Clock() while all(event.type != pygame.QUIT for event in pygame.event.get()): keys = {pygame.K_UP: D.n, pygame.K_RIGHT: D.e, pygame.K_DOWN: D.s, pygame.K_LEFT: D.w} pressed = {keys.get(i) for i, on in enumerate(pygame.key.get_pressed()) if on} update_speed(mario, tiles, pressed) update_position(mario, tiles) draw(screen, images, mario, tiles, pressed) clock.tick(28) def update_speed(mario, tiles, pressed): x, y = mario.spd x += 2 * ((D.e in pressed) - (D.w in pressed)) x -= x // abs(x) if x else 0 y += 1 if D.s not in get_boundaries(mario.rect, tiles) else (-10 if D.n in pressed else 0) mario.spd = P(*[max(-limit, min(limit, s)) for limit, s in zip(MAX_SPEED, P(x, y))]) def update_position(mario, tiles): new_p = mario.rect.topleft larger_speed = max(abs(s) for s in mario.spd) for _ in range(larger_speed): mario.spd = stop_on_collision(mario.spd, get_boundaries(mario.rect, tiles)) new_p = P(*[a + s/larger_speed for a, s in zip(new_p, mario.spd)]) mario.rect.topleft = new_p def get_boundaries(rect, tiles): deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)} return {d for d, delta in deltas.items() if rect.move(delta).collidelist(tiles) != -1} def stop_on_collision(spd, bounds): return P(x=0 if (D.w in bounds and spd.x &lt; 0) or (D.e in bounds and spd.x &gt; 0) else spd.x, y=0 if (D.n in bounds and spd.y &lt; 0) or (D.s in bounds and spd.y &gt; 0) else spd.y) def draw(screen, images, mario, tiles, pressed): def get_frame_index(): if D.s not in get_boundaries(mario.rect, tiles): return 4 return next(mario.frame_cycle) if {D.w, D.e} &amp; pressed else 6 screen.fill((85, 168, 255)) mario.facing_left = (D.w in pressed) if {D.w, D.e} &amp; pressed else mario.facing_left screen.blit(images[get_frame_index() + mario.facing_left * 9], mario.rect) for rect in tiles: screen.blit(images[18 if {*rect.topleft} &amp; {0, (SIZE-1)*16} else 19], rect) pygame.display.flip() if __name__ == '__main__': main() Basic Script Template #!/usr/bin/env python3 # # Usage: .py # from collections import namedtuple from dataclasses import make_dataclass from enum import Enum from sys import argv import re def main(): pass ### ## UTIL # def read_file(filename): with open(filename, encoding='utf-8') as file: return file.readlines() if __name__ == '__main__': main() ","link":"https://yueqingsheng.github.io/python-cheatsheet/"},{"title":"月报 6月","content":"本周有很多互联网趋势的总结报告和 AI相关的内容。 报告 行业内最有权威的两个行业趋势报告，在同一周发布 技术雷达，nestjs 上榜了，感觉这属于nodejs 后端比较适合规模化的一个框架了，有点像前端框架，每个模块可以复用，组合。这一期还包括了一些远程工作的内容。 technology radar typescript 的喜爱度超越了 python, 个人感觉虽然ts语法进步了，但是nodejs的包管理，像一个 shit hole。虽然原作者已经做出了 Denojs（使用 URL加载包，本地缓存）, 但还在 1.0阶段。不太喜欢 nodejs的动不动几万个依赖，简直是噩梦的存在。 Rust 受欢迎度排名第一，因为速度可以媲美 C++，而且保证了内存安全。 中文总结 英文源链接 AI 一些可以在线使用的 AI,文章摘要生成，AI 画画之类的 无聊的人类 OPENAI 发布了1750亿参数的神经网络，应用效果惊人。 GPT3 只要训练集大，效果吓死人，话说这玩意除了OPENAI,谁能训练。。。 Python github star很多的一份python快速查阅手册 github源地址 复制了一份放到博客上，增加了侧栏目录 Github 这周写了个生成用户假数据的脚本。用了 Github上的几个项目 中文人名生成，蛮有意思的一个人名生成器 Chinese-Names-Corpus 汉字转拼音,可以选多种格式，包括声调 python-pinyin 文章 一个理想主义者的破灭 罗永浩：薛定谔的理想主义 视频 尽管我们的手中空无一物 僕らの手には何もないけど 本周词汇 单词 个人理解 英文解释 解耦（decoupling） 我的理解就是尽可能把共用的部分提出来，把一个大的项目，拆成一堆小项目，使小项目的复用性变高。 If two classes make calls to methods of each other then they are tightly coupled, as changing one would mean having to change the other. Decoupling is the process of making something that was tightly coupled less so, or not at all. ... &quot;Decoupling&quot; is just another name for &quot;little/low coupling&quot;. 敏捷式开发 （Agile software development) 一边测试一边开发，测试/用户驱动 Agile software development comprises various approaches to software development under which requirements and solutions evolve through the collaborative effort of self-organizing and cross-functional teams and their customer/end user. Why decoupling? Ultimately decoupling promotes scalability, as you can scale the pieces of your infrastructure that your capacity planning identifies to be bottlenecks. What's more you can make those pieces redundant, increasing high availability at the same time. ","link":"https://yueqingsheng.github.io/zhou-bao-5-yue-di-2-qi/"},{"title":"关于refresh token","content":"refresh token 如何增加后端安全性呢？ 根据refresh token 的实现，它只在每次登陆的时候才会返回。从请求频率的上减少了暴露的可能性（减少了登录接口请求次数）。一般refresh token的有效期很长。 那跟它相比的是什么呢，是只使用token登陆，考虑两种情况 有效期较长或永久有效的token(非常不安全)，没有登出或长时间不登出的话，其他用户可以在这个期间进行操作 请求多次有效期相对较短的token，这样增加了登陆的次数。对用户非常不方便。 所以refresh token 既减少了登录的次数，又实现了自动刷新token, 减少了用户的操作。主要安全性增强的方面就是在减少登录上。 ","link":"https://yueqingsheng.github.io/guan-yu-refresh-token/"},{"title":"后端基础","content":"SQL 语句 一般常使用大写 INSERT 插入 INSERT INTO `post`(数据表名,使用反引号或者不使用反引号也可以) （`title`, `content`）(表格内字段名) VALUES ('文章1'，'我是一个内容')， （标题和内容，分隔用逗号） ('文章2'，'我是一个内容')； （结尾用分号） SELECT 选择 SELECT * FROM `post` LIMIT 1 OFFSET 1; (选择所有数据，limit条数， offset 偏移量) SELECT `id`, `title` FROM `post` LIMIT 1 OFFSET 1 WHERE `id` = 1;(选择字段， where 查找条件) SELECT `id`, `title` FROM `post` LIMIT 1 OFFSET 1 ORDER BY `id` DESC;(排序) UPDATE 更新 DELETE 删除 INDEX 索引 定义 有序性的目录 为什么使用？ 加快表单的查询速度 加快 where=某个值 和范围查询 原理 B+树 索引类型 联合索引，按照两个字段建立索引 复合索引 先按 A 不相等的排，相等的话按照B排。不能做 A B 同时的 range query MEMCACHED 主键和外键 主键： 用于表示数据的唯一标示，不能为null。 如：id 外键： 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 如：post 里的userId 哈希函数 key-hash function-&gt; hash code 简单hash 不考虑冲突 Put Get hash 是不可逆的 MD5 string=&gt;string(32位16进制字符串) 相同hash有可能由不同字符串生成 靠key,hash 对 可以猜到密码。盐（通过添加其他字符，生成不同的hash） CSRF(Cross site request forgery) CSRF攻击攻击原理及过程如下： 1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； Http Status Code http status code 消息队列 需要缓冲，等待的任务队列，等待 webserver 执行完返回 Cookie(客户端） &amp; Cookie(浏览器) ","link":"https://yueqingsheng.github.io/hou-duan-ji-chu/"},{"title":"月报 5月","content":"每周会总结一些最近用到的工具或者看到的文章。 工具 比谷歌翻译更好用的 AI翻译，翻译的很自然。 DeepL 提供了基本上网上所有的社交媒体和信息来源的 RSS RSShub AI 可溯源的I搜索引擎，可以知道一些词的主要来源和引用Magi 跨端同步文件夹，我用它把mac和windows的Gridea博客文件同步起来。坚果云 python 一个很方便的给现成代码添加命令行的库Fire 详细讲了列表生成式的用法。Python 成为专业人士笔记–comprehension生成式 后端 推荐两个课程虽然都是付费的，但是自己听过还可以 从 0 开始学习开发后端，内容很全，一如皓哥平时的风格，视频简练，每个不超过 5 分钟。可以作为 js 开发入门，或者后端查阅使用。小白兔的开发之路 需要一定的算法和后端基础，可以作为进阶学习，主要讲了如何优化后端，如访问量巨大或高并发的情况。至于价格见仁见智，我觉得有点小贵了。优点是讲的比较系统。系统设计 文章 蛮有意思的一篇文章，一直对这类的文笔比较感兴趣。残局 WannaCry解决者的故事 22岁阻止席卷网络的病毒，却因开发恶意软件被捕，这是传奇黑客马库斯的故事 视频 赛博朋克山海经，惊了。Cyberpunk Shanhaijing 每周英文 每周读几篇英文文章，或者听电台节目（podcast) ,或者写点英文技术文章，或者转译一篇。 本周文章： 不要学编程，学会自动化。主要讲了生活中很多重复无聊的事都可以自动化起来，写代码只是其中实现的一个选择。Don't Learn to Code — Learn to Automate 词汇表：列出英文解释的原因，是我觉得有的时候英文解释比中文更好理解单词原本的意思。 单词 英文解释 中文含义 heady having a powerful effect, making you feel slightly drunk or excited 令人兴奋，有点冲动的 surreal strange; not seeming real; like a dream 超现实的,不真实的 intimaditing making you feel frightened or nervous 令人紧张的，吓人的 overwhelming difficult to fight against 难以抵挡的；无法抗拒的 folly 愚蠢的 rebuttal a statement that says that something is not true 反驳 zeitgeist the general set of ideas, beliefs, feelings, etc. that is typical of a particular period in history 时代思潮 overarching most important, because of including or affecting all other areas 首要的；包罗万象的，支配一切的 nuance a very slight difference in appearance, meaning, sound, etc. （外表、意义、声音等的）细微差别 hung up having a hang-up (= feeling of worry about yourself) 焦虑的，烦恼的 per se by or of itself 自身，本身 savvy practical knowledge and ability 常识；实际能力 copy editor A copy editor is a person whose job it is to check and correct articles in newspapers or magazines before they are printed. 文字编辑 wince 退缩 laboriously in a way that needs a lot of time and effort 费力地；艰难地；辛苦地 拓展: ruby 是一门编程语言 文章中提及的热火队的广告链接 ","link":"https://yueqingsheng.github.io/zhou-bao-5-yue-di-1-qi 2/"},{"title":"系统设计 Week 1 4S分析 ","content":"4s 4s是指 Scenario(场景) Service(服务) Storgae(储存) Scale(升级) Scenario(场景) DAU(https://yueqingsheng.github.io/post-images/1590461765777.png) MAU(\b月活跃用户 ) 估计 MAU约等于2*DAU Enumerate(列举)列出所有功能 Sort 筛选核心功能 Timeline(用户发布的内容) News Feed(用户关注的内容/信息流) 3.分析 QPS(Queries per second) QPS = DAU*用户平均每天请求次数/每天多少秒（86400） PEAK(峰值) 约等于= QPS *3 快速增长 Fast Growing 将来的增长 读频率 写频率 &lt;=1 每个用户 QPS Single point failure(一个坏了，快速切换到另一台服务器) 普通web server 只能达到 10QPS SQL Databsase 1k QPS (join index很慢) NoSQL 10k ~ 1m Service(服务) Service oriented(微服务化，大系统拆分小服务) Replay 每个需求添加一个服务 Merge 归并相同的服务 Storage 存储 每个Service 选择存储结构 Database File System Cache Schema 细化表结构 primary key 一般使用id作为primary key,因为username和email有可能被修改，导致连串修改。 News Feed pull model: merge k sorted arrays 缺点： 现算，每次发送请求 push model: fanout: In message-oriented middleware solutions, fan-out is a messaging pattern used to model an information exchange that implies the delivery (or spreading) of a message to one or multiple destinations possibly in parallel, and not halting the process that executes the messaging to wait for any response to that message.(在面向消息的中间件解决方案中，fan-out是一种用于建模的消息交换体式格局，它意味着向一个或多个目的地可能并行地传递(或传播)一个消息，而不是让执行消息的进程停止等待对该消息的任何响应。) Denormalized 叫去标准化。通俗的解释是，通过在不同的 Table 中存储同一份数据的（也就是说至少一份是冗余数据）的形式，来加速数据的查询。因为当数据只存储在一个固定的 Table A 的时候，其他 Table B访问时如果需要同时取得关联的 Table A 的数据，则需要进行 join 操作之类的，会比较慢。一个例子就是在，统计有多少人点赞了一个帖子，可以通过 select count() from like_table where post_id= 的方式来获取，但是也可以在 post table 中新增一个 like_count，每次点赞就 +1。这里 like_count 就是一个 denormalized field，因为是可以通过 select count() 在 like table 中获得的。 fanout 过程异步执行 async 缺点 粉丝过多，创建的记录会变多 push 对1对特别多的 现象速度很慢，每次加一个新的内容，通知所有关注的人。 Scale Pull 改进： Cache N cache请求（N是关注的好友数） Trade off: Cache 1000条，或200条 Push 改进： 在现有基础上做尽可能小的改动 Push+ Pull 普通用户 push 明星用户 pull 在获取更新之前，主动merge明星的更新 定义明星问题 掉粉前，明星不push,掉粉后状态改变，不pull。数据丢失 =》永久状态，只要达到过就固定状态 Done is than perfect 课后习题分析以及改进 我的数据结构设计： Tweet_extend 扩展tweet加上创建时间。 tweet 储存每个用户的tweet list follow_relation 储存了用户的关注关系表 答案中关系用了map&lt;int, set&gt; 用户id到这个用户关注的人的id的映射，这样设计1对多关系的映射少了在代码中loop判断用户。提升了查询速度。 Push model: 把每个人建立一个newsfeed map&lt;int, newsfeed&gt;, 每当新建一个新twitter，给所有关注的 newsfeed里添加一个。如果Push的时候是按照时间顺序，获取newsfeed的时候就不用sort，拿头10个就行了。 ","link":"https://yueqingsheng.github.io/xi-tong-she-ji-4s-fen-xi/"},{"title":"RSS订阅（Feedly + RSShub）","content":" RSS 是用于分发Web 站点上的内容的摘要的一种简单的XML 格式。它能够用于共享各种各样的信息。 每天被各个网站上和app的推荐算法烦到了，被动接受了很多无用信息，RSS 最吸引人之处，就在于它能让你看到「开放互联网未经过滤的样子」，给你一个「自己决定看什么」的机会。 一直有个想法搭个RSS信息聚合的网站，找了一圈发现有很多现成的工具了。完全可以使用这些工具解决。（不用写代码了，yeah!） Feedly 网站链接 找了几个，发现feedly是页面展示最好的一个，而且还有手机端app。 网页 app 唯一的缺点，对图片的预览不是很好。 看图片推荐切换到cards view, 设置成直接打开网站。 RSS源 RSSHUB已经包含了大多数获取的来源，如果还没有的话，推荐RSSHUB Radar这个插件，可以自动获取当前网站是否有rss link。 结合这两个基本上，每天所有的信息源都可以获取到了，比如接入常看的youtube频道，网易云歌单, b站up主，画师，微博，电台，直播。 添加源方法 在Feedly里直接复制RSSHUB里的链接就行了。 欢迎订阅我的博客。RSS链接: https://yueqingsheng.github.io/atom.xml RSS里看视频 我感觉可以把RSS理解成爬虫爬下来然后整理的一种数据格式，所以基本上，网上能浏览的网页，都可以做成RSS来看。也可以把它利用成获取各种通知和推送的工具，比如看直播课，大学信息，追剧更新。 Done! 在想RSS能否扩展成一个网站浏览所有信息呢？（使用视频播放，音频播放，以及直播流） 拓展： 推荐阅读 你的新闻 App 被推荐算法「毁」了，但 RSS 真的能拯救你吗 随着RSS进化，某一天这个技术本身也会拿来做推荐算法的优化。所以重点不是在于技术本身，而是个人是否有寻求有价值信息的能力。 ","link":"https://yueqingsheng.github.io/rss-ding-yue-feedly-rsshub/"},{"title":"用sao从0写一个脚手架（cli, scafolding, sao）","content":"看了一些文章，发现saojs 包括了一个简单的generator流程。但是网上详细介绍的文章太少了，作为一个js小白，把流程记录下。 Run/Test 第一步是先把脚手架跑起来，这里使用了ava测试。参考 AVA 安装 ：npm install ava -g 开始测试：ava snapshot testing 第一次测试ava会生成main.js.snap和main.js.md，然后自动比对之后生成的snapshot是否跟储存的一致。参考 snapshot更新：ava -u Sao generators test parameters 测试能跑起来了下面看一下，sao testing的参数 answers 的格式为 { useRouter: true } Ejs docs Inquiryjs docs ps: 放弃使用sao了,不是因为这个包不好。有两个原因，一个是对python比较熟练，系统级操作比较用户友好，jupter直接支持bash命令。第二是因为我需要很多对文件的操作，不单单是替换，用js的话需要用的第三方包太多了，学习成本有点高。 参考 如何开发一个可爱的CLI（一） ava test ","link":"https://yueqingsheng.github.io/yong-sao-cong-0-xie-yi-ge-jiao-shou-jia-cli-scafolding-sao/"},{"title":"nestjs 后端代码自动生成（数据表，curd接口，文档）","content":"起因 最近给公司写接口的过程中，发现每有一种新的数据形式，出现就需要重新写一个数据表，并提供相关的数据接口。这个过程中有很多的代码复用。 一开始我写了一组使用范类的常用controller和service，并让新写的controller和service继承他们，效果还可以，但是还是要自己写entity以及配置数据库一些重复的操作。所以我想能否也省去写这些部分的时间。 实现结果 只通过一个json文件（即数据格式），生成一系列接口以及文档。 test.json {&quot;name&quot;: &quot;hi&quot;, &quot;age&quot;: 1} 生成效果（下面都是通过一个json生成的内容） 生成的文档目录(更新了app.module) 接口 接口内包括筛选，查找，分页，缓存等一系列选项。 数据格式文档 数据表 实现思路 nesjs有类似component的概念，component之间可以通过插入继承来实现复用。我这里使用了继承，因为想复用的部分都是可以共用的增查删改操作。 在网上搜索资料的时候发现，有人也有同样的思路，并写了一个包nestjsx/crud。star数有点少, 不过很好用，暂时只支持typeorm。既然有了轮子就不用自己造了。这个包含了swagger的配置，所以会自动生成文档。 基于这个包扩展开来，我要做的只是把json转成entity.ts文件，生成module,controller, service(继承crud)以及配置好数据库就行了。实现很简单我用了jupter notebook 然后转成了python。源码地址 实现过程在ipynb里，py是转换好的文件。 运行 ipython beg.py test(实例/数据表名) test.json(数据内容) 对nestjsx/crud的改进部分 增加了json转entity 补充了swagger分区（ApiTags）和显示entity内部属性（ApiModelProperty） 生成module,controller,service,并注入entiity repository 更新app.module 之后的扩展方向 丰富json数据类型支持，目前只支持string, int, bool 添加mongodb支持 提供更多entity column选项 添加接口权限控制 根据list of json 批量生成接口 生成一个接口，供前端使用，前端可以根据数据需求创造接口。 js重新打包成cli发布到npm 0.0.1 添加relation {} 为 one to one or many to one (default one to one) [] 为 one to many or many to many (default one to many) 只生成entity 描述 descrption 根据 已知bug json 中不能用id属性，因为id是由primaryGenerateColumn默认生成的。 ","link":"https://yueqingsheng.github.io/nestjs-hou-duan-dai-ma-zi-dong-sheng-cheng-shu-ju-biao-curd-jie-kou-wen-dang 2/"},{"title":"青春有你2 评论分析拓展","content":"2020/4/30 更新 1. 多线程数据爬取 获取视频列表 获取视频列表的url为https://www.iqiyi.com/v_19ryi480ks.html。 即任意一期右侧的正片这一栏。 找到 li标签下 class为play-list-item的data-td属性 需要注意爬取后的列表第一个为预告，可以去掉，这里只爬取所有正片 获取评论列表 接口 url参数： content_id: 视频id 通过上方的的视频列表中获取 last_id: 上个最后的视频id，每次获取完成后，使用最后一个id，作为下次获取的last_id page: 翻页的页数 page_size: 每页评论的个数 upremaining: 1最后一页， 0 后面还有内容 如何获取全部评论 两个思路 检查lastid 是否重复了，说明获取到最后一个 其实返回的data里有一个参数，&quot;upremaining&quot;:0。检查这个为1就可以了。 大部分同学都使用last_id翻页，其实参数里自带page,使用page=1，2，3，4也可以实现翻页 page_size可以设大一点，减少请求次数。最大为40 因为评论数量过多，使用多进程爬取。每一个进程爬取一个视频下的评论,总共花了1分3秒。不用多线程的话，估计要20多分钟。 截至2020日4月29日总共爬取了254287条数据。 2. 数据清洗 发现很多评论里出现多次刷同一个选手名的现象。所以做一下选手名去重，这样能在预测选手成绩时能保证合理性，防止多计算出现次数。 如: 虞书欣虞书欣虞书欣虞书欣虞书欣冲呀！！！ 清洗后为 虞书欣冲呀！！！ 3. 分词 数据请求后, 评论列表不再改变可以转化为tuple使用, tuple的access速度会比list快 使用tuple分词用了 9分3秒，会比list快十几秒。 4. 选手词频统计 经过26万条评论统计，按前20选手姓名出现频率排序 人名去重后，词频少了很多。 根据25号官方排名，前9名内除第9不一样，其他基本吻合。 5. 词云 按照词频显示词云 之前用形状和上色绘制了下词云，但是感觉效果没有原生的好。(这个是基于1000条数据生成的) 6. 节目评价 总体还是正向和中性评价占了绝大多数，95%。 随机打印一点 评价 正向： ['因为看了书欣的电视剧才来看这个的，喜欢她的性格', '我也喜欢左卓', '好喜欢刘雨昕！', '我真的太爱刘雨昕了', '好看好看', '看了这期，真的很心疼喻言', '安崎反差萌真的绝了，好看的颜值和有趣的灵魂她都拥有。', '我也喜欢虞书欣', '虞书欣加油', '冲着虞书欣搞笑视频来的，后面发现太太太多想pick的了。这种模式是看的第一个，努力又融洽的氛围真好。'] 中性： ['乃万！', '乃万', '我要去看男团了拜拜，记得给我点赞', '大家要帮忙投票了吗我这儿还有13票', '大家有要帮忙投票的吗我还有14', '虞书欣', '乃万简直是可盐可甜可rap 可vocal， 随时写词的到处撩妹的博爱艺术家 。', '谢可寅小姐姐要加油喽。', '刘雨昕', '林凡'] 负面; ['刘雨昕你咋不是个男的啊太帅了', '看得累死了磨磨叽叽', '我爱死所有训练生了', '傅如乔 爱死你了', '我就是看美女跳舞的，谁是谁，这个真不关心，长的都挺好看的，挺养眼', ''安琪的肚子真的不好看 感觉肚子肉好多 总喜欢露着腰,'入股不亏', '赵小棠什么鬼哦！', '真失望 为什么不是刘雨欣！ 突然不想看了', '不要脸', '小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！真的很棒！'] 模型把很多人名识别成了中性词，对英文的词性识别可能还不是很好。 有一些负面评价识别还行，但是也有不准的时候。比如“爱死了”， &quot;小蝴蝶胡馨尹很棒，呜呜呜不好意思之前没有发现你，不管在哪里都要继续加油呀！&quot;可能把呜呜呜识别成负面了。 总结 跟原项目主要区别：多进程爬虫，多视频爬取，选手名去重，list改用tuple 经过爬取所有评论和同一句子人名去重后，发现数据可视化后还是变化挺大的。有很多人一个评论发很多重复的一个人名。 可拓展方面 评论生成，用文本生成模型生成一些青春有你相关的评论。 其实表情也是很好的反映观众心情的label, 也可以做这方面情感分析，finetuning 一下。根据评论生成表情，也会很有意思。 评论中还包括了大量的图片和动图，抓取下来，也可以做一些相应的拓展。 评论的用户信息分析，如地区 生成一个动态直方图，用户根据日期看不同日期的统计变化。参考视频，随便一个视频几万的播放量，我酸了 ","link":"https://yueqingsheng.github.io/qing-chun-you-ni-2-ping-lun-fen-xi 2/"},{"title":"Vue","content":"使用 CDN &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 数据绑定 括号绑定 {{message}} //括号中可使用表达式 如 {{message+ message}} 指令式绑定 &lt;div v-bind:id=&quot;message&quot;&gt;&lt;/div&gt; 简写形式 &lt;div :id=&quot;message&quot;&gt;&lt;/div&gt; 这里我们遇到了一点新东西。你看到的 v-bind attribute 被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title attribute 和 Vue 实例的 message 属性保持一致”。 响应式 可以这样理解：当一个状态改变之后，与这个状态相关的事务也立即随之改变，从前端来看就是数据状态改变后相关 DOM 也随之改变。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。 v-if v-else v-show v-for &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{message}}{{message+ message}} &lt;div :id=&quot;message&quot;&gt;&lt;/div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt; &lt;span v-if=&quot;!item.del&quot;&gt;{{item.title}}&lt;/span&gt; &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{item.title}}&lt;/span&gt; &lt;button v-show=&quot;!item.del&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { message: &quot;Hello World&quot;, list: [ { title: &quot;课程1&quot;, del: false, }, { title: &quot;课程2&quot;, del: true, }, ], }, }); &lt;/script&gt; &lt;/body&gt; 组件 Vue.component(&quot;todo-item&quot;,{ props:{ title: String, del: { type: Boolean, default: false, }, }, template: ` &lt;li &gt; &lt;span v-if=&quot;!del&quot;&gt;{{title}}&lt;/span&gt; &lt;span v-else style=&quot;text-decoration: line-through;&quot;&gt;{{title}}&lt;/span&gt; &lt;button v-show=&quot;!del&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; `, data: function(){ return {} }, methods: { }, }) Vue.component(&quot;todo-list&quot;, { template: ` &lt;ul&gt; &lt;todo-item v-for=&quot;item in list&quot; :title=&quot;item.title&quot; :del=&quot;!item.del&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; `, data: function () { return { list: [ { title: &quot;课程1&quot;, del: false, }, { title: &quot;课程2&quot;, del: true, }, ]} } }) 组件中data 不能使用同一个data,因为pass by reference ，在一个地方改变，其他地方也会改变。data要求唯一化。 ","link":"https://yueqingsheng.github.io/vue 2/"},{"title":"第一次神经网络实践","content":"简单总结下教训： 输入，输出 输入就是 a和 b, 输出是c。 First attempt 一开始想把天数，1到28天作为输入，28天的感染人数作为输出。去找 天数和 感染的函数关系。错误的原因，28天只是任意的28天时间段，去强行找 1-28 和感染的关系是不成立的。也没有关系。 Second attempt 用RNN实现，方向是对的。能力不够复现RNN或LSTM(吐槽下，老师说如果要写的话，要从0复现一个，地狱级难度任务) 总结 其实确认输入输出，最重要的就是确立，想找的是什么与什么直接的关系。相互影响的那两个量。题目写的已经很清楚了，用c_t 和 t_pd 预测 c_inf 其中忽视的问题 只看到了cost变大，没有去考虑原因。原因是因为梯度爆炸。梯度爆炸的原因是，输入之间差值太大，呈现exponetial爆炸增长。 ！！！！ 最重要学到的点，什么时候要做归一化，即Normalizition 归一化，在处理奇异值时候特别重要，如果数据存在极大或极小值，会严重影响weight 的收敛。归一化即，把输入和输出限制在同意范围内，如[0,1],映射到同一维度内。 参考:机器学习——标准化/归一化的目的和作用 Anyway, 有空的话，可以用LSTM复现个玩玩。获取一个多维度输入，输出将来的感染人数。直到感染变化为0为止。 ","link":"https://yueqingsheng.github.io/di-yi-ci-shen-jing-wang-luo-shi-jian/"},{"title":"Python","content":"Random int import random random.randint(1,3) k unique samples import random random.sample(tags_id, 3) Print print 会自动换行，print(end=&quot;&quot;)会取消换行，end为结束后缀 遍历文件 os.walk() Python method walk() generates the file names in a directory tree by walking the tree either top-down or bottom-up. for root,dirs,files in os.walk(path): for fname in files: if filename in fname: result.append([id,fname]) string check contains str = \"Messi is the best soccer player\" >>> \"soccer\" in str True >>> \"football\" in str False 三引号 三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。 print('''I'm going to the movies''') html = ''' &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt; Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt; &lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt; &lt;B&gt;%s&lt;/B&gt;&lt;P&gt; &lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt; &lt;/BODY&gt;&lt;/HTML&gt; ''' print(html) 元组和列表 元组是不可变的， 而列表是可变的。 我们可以修改列表的值，但是不能修改元组的值。 由于列表是可变的，我们不能将列表用作字典中的key。 但可以使用元组作为字典key。 同构与异构 习惯上元组多用于用于存储异构元素，异构元素即不同数据类型的元素，比如(ip,port)。 另一方面，列表用于存储异构元素，这些元素属于相同类型的元素，比如[int1,in2,in3]。 list reverse sublist a[start:stop:step] # start through not past stop, by step step为-1的时候是reverse order a[:-11:-1] # the last 10 items, reversed sort The sort() method doesn't return any value. Rather, it changes the original list. list.sort(key=..., reverse=...) If you want a function to return the sorted list rather than change the original list, use sorted(). sorted(list, key=..., reverse=...) paramter reverse - If True, the sorted list is reversed (or sorted in Descending order) key - function that serves as a key for the sort comparison JSON Python list(dict) to json string json.dumps 用于将 Python 对象编码成 JSON 字符串。 import json data = [ { 'b' : 2, 'd' : 4, 'a' : 1, 'c' : 3, 'e' : 5 } ] json = json.dumps(data) print(json) [{&quot;b&quot;: 2, &quot;d&quot;: 4, &quot;a&quot;: 1, &quot;c&quot;: 3, &quot;e&quot;: 5}] json string to python list(dict)_ json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。 import json jsonData = '{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}' text = json.loads(jsonData) #将string转换为dict print(text) 打包并压缩 把当前目录下所有文件打包压缩成a.tar.zip tar -zcvf a.tar.zip ./ 解压 -C 指定目录 tar -zxvf a.tar.zip -C ../ 爬虫 request模块： requests是python实现的简单易用的HTTP库，官网地址：http://cn.python-requests.org/zh_CN/latest/ requests.get(url)可以发送一个http get请求，返回服务器响应内容。 BeautifulSoup库： BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。网址：https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ BeautifulSoup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml。 BeautifulSoup(markup, &quot;html.parser&quot;)或者BeautifulSoup(markup, &quot;lxml&quot;)，推荐使用lxml作为解析器,因为效率更高。 通过tag标签逐层查找: soup.select(&quot;body a&quot;) 获取属性 tag.get('href') 或者 tag['href'] 如果不确定某个属性是否存在时,用 tag.get('attr') 方法去获取它,跟获取Python字典的key一样 tag['class'] KeyError: 'class' print(tag.get('class')) None link = star['link'] headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } #！！！请在以下完成对每个选手图片的爬取，将所有图片url存储在一个列表pic_urls中！！！ pic_urls = [] response = requests.get(link,headers=headers) #将一段文档传入BeautifulSoup的构造方法,就能得到一个文档的对象, 可以传入一段字符串 soup = BeautifulSoup(response.text,'lxml') pic_list_url = soup.select(&quot;.summary-pic a&quot;)[0]['href'] tags1 = soup.select('div .shixian_zhaobiao') tag1 = tags1[0] tag2 = tag1.find(name = 'dl') tags2 = tag2.find_all(name = 'a') jsonp to json response_json = response[ response.index(&quot;(&quot;) + 1 : response.rindex(&quot;) } catch&quot;)] 或者get请求的时候，去掉callback=,则会返回json 动态请求 如果数据是动态加载，可以在浏览器network里查看请求的api 写入文件 With the &quot;With&quot; statement, you get better syntax and exceptions handling. &quot;The with statement simplifies exception handling by encapsulating common preparation and cleanup tasks.&quot; In addition, it will automatically close the file. The with statement provides a way for ensuring that a clean-up is always used. with open('output.txt', 'w') as file: # Use file to refer to the file object file.write('Hi there!') with 省去写exception handler和close file pandas read csv df = pd.read_csv('tag.csv') dataframe cut 将age按0-5，5-20...bins 分成 既几部分，label为[婴儿，青年...] ages = np.array([1,5,10,40,36,12,58,62,77,89,100,18,20,25,30,32]) #年龄数据 pd.cut(ages, [0,5,20,30,50,100], labels=[u&quot;婴儿&quot;,u&quot;青年&quot;,u&quot;中年&quot;,u&quot;壮年&quot;,u&quot;老年&quot;]) 参考 value_counts df.value_counts() 以Series形式返回指定列的不同取值的频率,默认按频率从高到低排序 groupby df['name'].groupby(df['zone']) s = grouped.count() zone 中国上海 5 中国北京 9 df = pd.DataFrame({'Animal': ['Falcon', 'Falcon', 'Parrot', 'Parrot'], 'Max Speed': [380., 370., 24., 26.]}) df Animal Max Speed 0 Falcon 380.0 1 Falcon 370.0 2 Parrot 24.0 3 Parrot 26.0 df.groupby(['Animal']).mean() Max Speed Animal Falcon 375.0 Parrot 25.0 matplot size plt.figure(figsize=(12, 12)) %matplotlib inline %matplotlib inline 可以在Ipython编译器里直接使用，功能是可以内嵌绘图，并且可以省略掉plt.show()这一步 pie 参数： x :(每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化； labels :(每一块)饼图外侧显示的说明文字； explode :(每一块)离开中心距离； startangle :起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起； shadow :在饼图下面画一个阴影。默认值：False，即不画阴影； ## draw pie labels = [&quot;45-50kg&quot;,'&lt;45kg','50-55kg','55kg'] plt.pie(weightsfreq.values, explode=(0.1,0.1,0.1,0.1),labels=labels, shadow=True,autopct='%.2f%%',startangle=90) plt.axis('equal') plt.legend(loc=&quot;upper right&quot;,fontsize=10,bbox_to_anchor=(1.1,1.05),borderaxespad=0.3) plt.title('''《青春有你2》选手体重分布''',fontsize = 10) plt.savefig('/home/aistudio/work/result/bar_result03.jpg') 参考 正圆 plt.axis('equal') string format python &gt;3.6 &gt;&gt;&gt; name = 'hoxis' &gt;&gt;&gt; age = 18 &gt;&gt;&gt; f&quot;hi, {name}, are you {age}&quot; 'hi, hoxis, are you 18' 百分号 %%表示百分号 &gt;&gt;&gt; print('数据的比例是:%.2f%%' %(scale * 100)) 数据的比例是:10.00% &gt;&gt;&gt; print('数据的比例是:%d%%' %(scale * 100)) 数据的比例是:10% 参考 词云 根据词频绘制词云图 参数 word_f:统计出的词频结果 # 生成对象 mask = np.array(Image.open(&quot;alice_mask.png&quot;)) wc = WordCloud(mask=mask, font_path='SimHei.ttf', mode='RGBA', background_color=None) wc.fit_words(word_f) # 显示词云 plt.imshow(wc, interpolation='bilinear') plt.axis(&quot;off&quot;) plt.show() # 保存到文件 wc.to_file('wordcloud.png') matlibplot 加载中文字体 #下载中文字体 wget https://mydueros.cdn.bcebos.com/font/simhei.ttf #在操作系统中创建字体目录fonts（可能已经有 mkdir .fonts # 复制字体文件到该路径 cp simhei.ttf .fonts/ #复制字体到当前使用的conda环境中的matplotlib下的指定路径 cp simhei.ttf /opt/conda/envs/python35-paddle120-env/lib/python3.7/site-packages/matplotlib/mpl-data/fonts/ttf/ # Linux系统默认字体文件路径 ls /usr/share/fonts/ # 查看系统可用的ttf格式中文字体 fc-list :lang=zh | grep &quot;.ttf&quot; # 设置显示中文 matplotlib.rcParams['font.san-serif'] = ['SimHei'] # 解决负号'-'显示为方块的问题 matplotlib.rcParams['axes.unicode_minus'] = False 如果没成功，尝试 from matplotlib.font_manager import _rebuild _rebuild() #reload一下 jieba 分词 jieba.load_userdict('name.txt') #name.txt 为用户自定义分词 seg = jieba.lcut(text,cut_all=False) 停用词 stopwords = [line.strip() for line in open(file_path, encoding=&quot;UTF-8&quot;).readlines()] for word in sentence: if word not in stopwords: if len(word) &gt; 1: counts[word] = counts.get(word, 0) + 1 字典 .get(key,value) value为如果不存在返回的值，counts.get(word, 0)： word不存在于counts中则返回 0 中文常用停用词词表 多进程 多进程共同的全局变量，需要使用特殊方式声明： from multiprocessing import Process, Value, Array, Manager def f(n, a): n.value = 3.1415927 for i in range(len(a)): a[i] = -a[i] if __name__ == '__main__': num = Value('d', 0.0) arr = Array('i', range(10)) lis = Manager().list() p = Process(target=f, args=(num, arr)) p.start() p.join() print(num.value) print(arr[:]) 多进程list 使用前需转换回普通list， list(lis) .join() 可以等待进程执行结束后再输出 多进程的一个大坑：broken pipe 解决方案不要在主线程外使用shared object,这样主线程使用的时候修改，会影响子线程的这个object 解决方案：移除主线程的修改，或者把修改放到子线程跑完之后 解释 .join() 主线程等待子线程跑完。python默认是先执行完主线程 process= [] for c_id in content_ids: # 每个进程爬取一个视频下的评论 p = Process(target=getMovieinfo,args=(c_id,)) process.append(p) p.start() #等待所有线程任务结束。 for p in process: p.join() print(&quot;总共获取了&quot;,len(comments),'条评论') 这样主线程就会阻塞了 参考 ","link":"https://yueqingsheng.github.io/python 2/"},{"title":"Angular","content":"为什么js推荐使用单引号 单引号和多引号区别，没啥区别，单引号编译速度更快，而且单引号内可以使用双引号，有时候内部是json 格式必须用双引号 中文解释 模块 创建模块post 放在 modules/post 下 ng generate module modules/post componet 是生成的html 和css,ts 文件 模块导入 需要导出的模块在module 的 exports中添加，exports: [PostComponent], 引用的模块导入：imports: [PostModule], 数据绑定 在component.ts 内声明 .html 使用{{值}} *ngFor *ngfor 会自动扩展成 &lt;ng-template ngfor&gt; *是一种语法糖，缩写形式 &lt;li *ngFor=&quot;let entity of entities&quot;&gt; &lt;h4&gt;{{ entity.title }}&lt;/h4&gt; &lt;/li&gt; *ngIf &lt;p *ngIf=&quot;entity.body&quot;&gt;{{ entity.body }}&lt;/p&gt; 属性绑定 &lt;a title=&quot;{{ entity.title }}&quot; &gt;{{ entity.title }}&lt;/a&gt; &lt;a [title]=&quot;entity.title&quot;&gt;{{ entity.title }}&lt;/a&gt; 第二种形式可以绑定标签不存在的属性值 如 text-content, Angular 官方文档在绑定属性几乎都是使用[]，而插值表达式{{}}更多是用于显示，两者最大的区别就是后者会将{{}}语句里执行完的值再转换string 类型。 事件绑定 &lt;button (click)=&quot;removeItem(i)&quot;&gt;Remove&lt;/button&gt; 参数直接填就行 双向绑定 Module import { FormsModule } from '@angular/forms'; // &lt;-- NgModel lives here app.module.ts (@NgModule imports) content_copy imports: [ BrowserModule, FormsModule ], &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt; [(ngModel)] 是 Angular 的双向数据绑定语法。 这里把 hero.name 属性绑定到了 HTML 的 textbox 元素上，以便数据流可以双向流动：从 hero.name 属性流动到 textbox，并且从 textbox 流回到 hero.name 。 父子组件 父传子 传递数据， 父组件ul, 数据为entities在父组件内， 必须在子部件属性内赋值， 子部件使用@Input,， //@Input 此命令用来修饰属性是用来接收父组件传递的值 参考 有兴趣了解下单向数据流 angular 更新view，是在model更新阶段进行，不是model生成view阶段。 &lt;ul&gt; &lt;app-post-item *ngFor = &quot;let entity of entities&quot; [entity] = entity&gt; &lt;/app-post-item&gt; &lt;/ul&gt; 子传父（function） This example features an &lt;input&gt; where a user can enter a value and click a &lt;button&gt; that raises an event. The EventEmitter then relays the data to the parent component. 子部件 @Output() newItemEvent = new EventEmitter&lt;string&gt;(); addNewItem(value: string) { this.newItemEvent.emit(value); } &lt;button (click)=&quot;addNewItem(newItem.value)&quot;&gt;Add to parent's list&lt;/button&gt; 父部件 &lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;&lt;/app-item-output&gt; The event binding, (newItemEvent)='addItem($event)', tells Angular to connect the event in the child, newItemEvent, to the method in the parent, addItem(), 路由 basics app-routing.module.ts const routes: Routes = [{ path: 'posts', component: PostComponent }]; router link &lt;a [routerLink]=&quot;['/posts', entity.id]&quot; [title]=&quot;entity.title&quot; [textContent]=&quot;entity.title&quot; &gt;&lt;/a&gt; import from app-routing module paramMap constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.route.paramMap.subscribe((params) =&gt; { const postId = +params.get('id'); console.log(postId); }); Model 标记可选属性使用问号 body? 服务 @Injectable({ providedIn: 'root' }) root表示在任何位置可以使用 注入 componet.ts constructor(private postService: PostService) { this.entities = posts; } 表单 看这个文章，更详细点 pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 演示： 这是一个pre标签 哈 哈 formBuilder registerForm = this.formBuilder.group({ username: ['', Validators.required], password: ['', [Validators.required, Validators.minLength(6)]], }); ","link":"https://yueqingsheng.github.io/angular 2/"},{"title":"nestjs的坑","content":"不定期更新 变量名 变量命名时尽量不要用type, class 这些名称，以免用的时候，报一些奇怪的错误。编译器不知道是，自定义的名，还是语法里的意思。comment 也是关键字，需自己导包，我也是服了。 eager eager 谨慎使用，特别是relation有相互包含的时候。必须只能加在一边，防止重复包含，导致stack overflow。 eager 只会在find里生效,querybuilder 必须join find find 有很多选项足够用了可以代替 queryBuilder OneToMany Save 例子： 商品储存多个价格， data 是发送的商品数据，其中包含了price data.price = await this.priceRepository.save(price); data = await this.repository.create(data); return await this.repository.save(data); 注意 data.price 这一步是必须的，是为了更新刚储存完的id号，typeorm 用id 来建立关系 环境变量 process.env. 在for root里不好使，即使在main.ts里提前执行了config()。 非 for root 使用 require('dotenv').config() rocess.env. for root 使用 aynscfor root 在服务器更新 .env 文件 ##数据库更新 typeorm 更新的很随缘，如果发现数据格式不符bug。可以把dist文件夹删了 重跑一遍。 如 enum更新，或Column type更新 typeorm 从 entity.js 读取column 信息。 Controller 切记不要写这种路径 Get(':id') Get('user') Swagger paramter 参数必须声明类型，swagger才能识别到 nestjsx/crud 版本最好4.6.0， 4.5同时get by id和relation会报sql syntax error typescript 类型错误或不匹配时候可以强行转成any You can always temporarily cast $ to any: delete ($ as any).summernote mysql: 3306 eradr 出现这个错误大概率是，.env或production.env 的问题，本地的话检查下port端口，设置为localhost Observable nestjs httpservice 默认返回Observable Observable异常处理 .pipe( catchError(err =&gt; { return of(err.message); }), ); Observable值异步处理 result.subscribe((value)=&gt; { console.log(value); }); ","link":"https://yueqingsheng.github.io/nestjs-de-keng 2/"},{"title":"Pull request（第一次参与开源项目）","content":"学了CSS 和 html 基础，突然想起来前几天给主题作者提的意见，他刚好比较忙，那能不能我自己改下呢，嘿嘿。 fork 项目到自己git 下 git remote add upstream https://github.com/QibaiAluminum/EKT.git 添加源项目链接 push 改动 到github 提交 pull request ","link":"https://yueqingsheng.github.io/pull-requestdi-yi-ci-can-yu-kai-yuan-xiang-mu 2/"},{"title":"javascript cheatsheet","content":"DOM（文档对象模型） 文档树： each label is a node in the tree getElementById document.getElementById('page-title') getElementsByTagName document.getElementsByTagName('li') querySelectorAll querySelectorAll('.class a') 返回所有 querySelector 返回找到的第一个 访问属性 e.nodeName 标签名 e.innerText 内部文字 e.paretnNode 父节点 e.nextElementSibling 下一个兄弟元素 previousElementSibling e.childNodes 子节点 e.childElementCount 返回子节点数量 e.firstELementChild 第一个子节点 e.lastELementChild 最后一个子节点 修改 用=赋值 创建新的节点 步骤： var newMember = document.creatElement('li') var text = document.createTextNode('你好啊'); newMember.appendChild(text) document.querySelector('#list').appendChild(newMember) 添加到最后 insertBefore 插入到特定位置 countrylist.insertBefore(newMember, countrylist.firstChild) 修改CSS document.getElementById(id).style.property=新样式 事件 onclick=JavaScript <!DOCTYPE html> 点击文本! 绑定函数 &lt;p&gt;点击按钮执行 &lt;em&gt;displayDate()&lt;/em&gt; 函数.&lt;/p&gt; &lt;button onclick=&quot;displayDate()&quot;&gt;点这里&lt;/button&gt; &lt;script&gt; function displayDate(){ document.getElementById(&quot;demo&quot;).innerHTML=Date(); } &lt;/script&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; onload onunload onload 和 onunload 事件会在用户进入或离开页面时被触发 onmouseover 和 onmouseout 事件 onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 JavaScript HTML DOM EventListener document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate); ","link":"https://yueqingsheng.github.io/javascript-cheatsheet 2/"},{"title":"docker 自动化脚本配置","content":" clone https://github.com/YueqingSheng/auto-deploy.git 在主目录下编写脚本 在 routes/index.js 下添加接口 参考Route这里 push 服务器 脚本添加权限 forever restart ./bin/www TODO: 自动化 4-6步 By webhook spawn exec方法 在 node.js child_process模块中的应用及区别 解决 Error: maxBuffer exceeded docker logs－查看docker容器日志 ","link":"https://yueqingsheng.github.io/docker-zi-dong-hua-jiao-ben-pei-zhi 2/"},{"title":"CSS cheatsheet","content":"目的 结构样式相分离, html只做结构，css做样式 h1 { color: orange; } p { color: pink; } 字体 font-size font-family 支持汉字， 默认14px microsoft yahei， 尽量使用偶数号，各种字体用逗号隔开 &quot;微软雅黑&quot;,arial, sans-serif 按顺序没有的话往后找 如果字体内包括 空格 #$ 需要加引号 尽量使用默认字体 Unicode 字体 不支持中文字体的时候，使用Unicode代替 font-weight normal bold bolder lighter, 100-900 100的整数倍 font-style normal italic 综合字体样式 {font: font-style font-weight font-size font-family;}必须按顺序 前面可以省略，必须包括 font-size 和 font-family 注释 快捷键 ctrl + / 或者 /* 注释*/ 选择器 标签选择器 p{ } div{ } 标签作为选择器 类选择器 .类名{属性：属性1 } &lt;div class=&quot;类名&quot;&gt; 命名规则 相应的效果 或者主体名 （见名知义） 多类名选择器 &lt;div class=&quot;font20 pink&quot;&gt; id选择器 #class{ } &lt;div id=&quot;class&quot;&gt; class选择器和id选择器区别 类选择器是可以重复多次使用的，如人名 id选择器好比身份证，是唯一的 通配符选择器 *{ *代表所有选择器 color: red; } &lt;div id=&quot;class&quot;&gt; 伪类选择器 链接伪类 主要针对于&lt;a&gt; 简写方式 a{} a:hover{} 派生选择器 比方说，你希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： li strong { font-style: italic; font-weight: normal; } 群选择器 #main, #header{ main 跟 header 共同的样式 } 样式 内嵌样式 &lt;h2 style=&quot;color:green&quot; &gt;测试&lt;/h2&gt; 外部样式 &lt;link rel=&quot;stylesheet&quot;样式表 href=&quot;outside_style.css&quot; type=&quot;text/css&quot; /&gt; CSS 特性 继承 内部标签会继承外部内部的样式 不是所有的属性都会被继承，如边框，边距 层叠 内部标签会叠加所有外部的样式， 如果外部样式有冲突，继承离最近的外部标签，或者当前定义的样式 标签&lt;类 &lt;id &lt;行内样式 行内style，派生选择器会累计分数，#mainbody h2 101 盒模型 小技巧： margin:0 auto; (上下边距0，左右边距自动，即居中) 浮动 img style=&quot;float:right;margin-left:20px;margin-bottom:20px h2 style=&quot;clear:both&quot; 背景 background: url(b.jpg) ; 定位 position: absolute;right:0;top:0: ","link":"https://yueqingsheng.github.io/css/"},{"title":"Today's little fun","content":" h1 { color: orange; } 闲着没事，把Gridea主题商店逛了下,发现了个很好看的免费主题啊，点这里，配置了一下博客完全焕然一新啊，云养猫，计划通。 顺藤摸瓜找到了源作者的博客，和他模仿的源源作者的博客（俄罗斯套娃）， 源作者 源源作者 很漂亮啊，跟我的审美差不多（臭不要脸） 再就是很羡慕，这些能把自己的技术转换成实际生产力的人啊，为了兴趣而写代码，看看他们写的博客，再看看自己。。。还是要努力啊。希望自己有天也有能力，能实现自己想做的想法。 另外，源作者网站的音乐很好听啊，我直接copy到我的网站上了，哈哈，有兴趣可以听听，我循环了一晚上。 ","link":"https://yueqingsheng.github.io/todays-little-fun 2/"},{"title":"简单总结下我的全栈学习路线","content":"加油，加油！😄 前端 前端学习中不用刻意去记一些东西，记好笔记（或者直接用我的），到时候查就行了。理解优先 课程选择： html 阿里云大学 css 课程链接： 同一个老师，分集太多，学第一部分到选择器然后转宁皓网就行 + ninghao比较简练 js: 宁皓网 新手推荐这个系列 框架： angular因为我后端用的是nestjs angular去屎吧, vue万岁！ vue推荐极客大学 推荐工具 有些课历史比较久了，所以开发工具有点老，推荐开发工具vscode +插件： VScode 插件推荐 open in browser(写完代码，直接 ctrl+s 保存 ，alt+b 浏览器打开超方便) tabnine+ autoimport + auto close tag （以上三个全是自动补全） prettier (自动格式化代码) angular essential(插件包) Settings Sync 在不同设备同步设置插件 终端推荐使用zsh windows 配置方法： 安装bash, wsl 安装oh-my-zsh bash 内设置默认shell为zsh 下载必要组件如 node npm 在vscode 里配置默认shell 为 wsl html,css 自动补全 (有兴趣可以了解下, 用习惯了开发效率很高) Emmet 可以用缩写写标签和属性 其他 github 这个必须要有啊，懂得都懂 强烈建议写个博客网站，原因么，很多，一个是云端保存笔记，一个是可以使用 Markdown, Markdown 内部可以使用 HTML, CSS 语法，边学边写。（另外个原因，可以自己魔改网站啊，很有动力，学以致用） 0基础搭建博客 推荐这个 Gridea 写博客时，会经常用到局部截图工具，Windows 推荐 PickPick 后端 目前学习计划是 后端nestjs（mongodb + graphql +exception handler(完成)+ environment storage（完成）） 下一步就是学 pandas ,numpy 基础 + 爬虫+ pytorch or tf 学习整理数据。 ","link":"https://yueqingsheng.github.io/jian-dan-zong-jie-xia-wo-de-wang-zhan-xue-xi-lu-xian 2/"},{"title":"html cheatsheet","content":"html 转义工具 here Basics The visible part of the HTML document is between &lt;body&gt; and &lt;/body&gt;. &lt;html&gt; 根标签 &lt;head&gt; 头标签 &lt;title&gt;&lt;/title&gt; 标题标签（网站标题） &lt;/head&gt; &lt;body&gt; 主体标签 &lt;/body&gt; &lt;/html&gt; example 快速生成 html:5 或者 ! 单标签 &lt;label /&gt; &lt;br /&gt; 多标签 &lt;lable&gt; 内容&lt;/label&gt; 关系 嵌套 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;/html&gt; 并列 &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; 文档类型 &lt;!DOCTYPE&gt; 声明 html 版本 &lt;!DOCTYPE html&gt; : html5 html5向下兼容其他版本 &lt;meta charset=&quot;UTF-8&quot;&gt; 字符集 标题 &lt;h1&gt; 到 &lt;h6&gt; 段落 &lt;p&gt; 分段，自动换行 水平线标签 &lt;hr/&gt; horizontal 换行 &lt;br/&gt; 段落会自动空出间隔 div span 网页布局 &lt;div&gt; &lt;span&gt; 文本格式化 加粗 important text 斜体 emphasized 删除线 deleted 下划线 inserted 标签属性 key=&quot;value&quot; 图像标签 &lt;img src=&quot;wo.jpg&quot;/&gt; 链接标签 &lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; 锚点定位 &lt;a href=&quot;#go&quot;&gt; &lt;h3 id=&quot;go&quot;&gt; base标签 &lt;head&gt;&lt;base target=&quot;_blank&quot; /&gt;&lt;/head&gt; 所有链接以新窗口打开 特殊字符 注释标签 &lt;!--注释--&gt; 无序列表 &lt;ul&gt; &lt;li&gt;elements&lt;/li&gt; &lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;elements&lt;/li&gt; &lt;/ol&gt; 自定义列表 &lt;dl&gt; &lt;dt&gt;elements&lt;/dt&gt; &lt;dd&gt;subelements&lt;/dd&gt; &lt;/dl&gt; ","link":"https://yueqingsheng.github.io/html-cheatsheet 2/"},{"title":"markdown cheatsheet","content":"行内代码 &lt;html&gt; &lt;head&gt; &lt;title&gt;多行代码，第一行反引号后面，输入代码块所使用的语言，实现代码高亮&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 上方是☝️分割线 斜体 斜体 加粗 done to do &lt; 转义字符&gt; html 转义工具 here 区块 这里 第一层嵌套 第二层嵌套 使用latex \\begin{equation} p\\left[s_{t+1}, r_{t^{\\star}} | s_{t}, a_{t}\\right] \\end{equation} bilibili 视频 ","link":"https://yueqingsheng.github.io/markdown-cheetsheet 2/"},{"title":"关于","content":"最近想用 angular + mongodb + graphql + nestjs 搭个网站，在这里记录下流程 反正也没人看，就写点自己想写的东西吧。😊 网站文章封面图片来源 ","link":"https://yueqingsheng.github.io/about 2/"}]}